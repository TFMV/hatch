
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>entry: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/TFMV/porter/bench/entry/gen_data.go (0.0%)</option>
				
				<option value="file1">github.com/TFMV/porter/bench/flight_throughput_benchmark.go (0.0%)</option>
				
				<option value="file2">github.com/TFMV/porter/bench/porter_benchmark.go (0.0%)</option>
				
				<option value="file3">github.com/TFMV/porter/bench/report.go (0.0%)</option>
				
				<option value="file4">github.com/TFMV/porter/cmd/benchmark/main.go (0.0%)</option>
				
				<option value="file5">github.com/TFMV/porter/cmd/server/config/config.go (0.0%)</option>
				
				<option value="file6">github.com/TFMV/porter/cmd/server/main.go (0.0%)</option>
				
				<option value="file7">github.com/TFMV/porter/cmd/server/middleware/auth.go (39.4%)</option>
				
				<option value="file8">github.com/TFMV/porter/cmd/server/middleware/logging.go (0.0%)</option>
				
				<option value="file9">github.com/TFMV/porter/cmd/server/middleware/metrics.go (0.0%)</option>
				
				<option value="file10">github.com/TFMV/porter/cmd/server/middleware/recovery.go (0.0%)</option>
				
				<option value="file11">github.com/TFMV/porter/cmd/test-flight/main.go (0.0%)</option>
				
				<option value="file12">github.com/TFMV/porter/pkg/benchmark/tpch.go (0.0%)</option>
				
				<option value="file13">github.com/TFMV/porter/pkg/cache/cache.go (62.9%)</option>
				
				<option value="file14">github.com/TFMV/porter/pkg/cache/config.go (100.0%)</option>
				
				<option value="file15">github.com/TFMV/porter/pkg/cache/stats.go (100.0%)</option>
				
				<option value="file16">github.com/TFMV/porter/pkg/errors/errors.go (100.0%)</option>
				
				<option value="file17">github.com/TFMV/porter/pkg/handlers/metadata_handler.go (0.0%)</option>
				
				<option value="file18">github.com/TFMV/porter/pkg/handlers/prepared_statement_handler.go (0.0%)</option>
				
				<option value="file19">github.com/TFMV/porter/pkg/handlers/query_handler.go (0.0%)</option>
				
				<option value="file20">github.com/TFMV/porter/pkg/handlers/transaction_handler.go (0.0%)</option>
				
				<option value="file21">github.com/TFMV/porter/pkg/infrastructure/converter/batch_reader.go (0.0%)</option>
				
				<option value="file22">github.com/TFMV/porter/pkg/infrastructure/converter/type_converter.go (36.2%)</option>
				
				<option value="file23">github.com/TFMV/porter/pkg/infrastructure/jdbc_compatibility.go (0.0%)</option>
				
				<option value="file24">github.com/TFMV/porter/pkg/infrastructure/memory/allocator.go (100.0%)</option>
				
				<option value="file25">github.com/TFMV/porter/pkg/infrastructure/metrics/collector.go (100.0%)</option>
				
				<option value="file26">github.com/TFMV/porter/pkg/infrastructure/metrics/prometheus.go (100.0%)</option>
				
				<option value="file27">github.com/TFMV/porter/pkg/infrastructure/motherduck.go (86.7%)</option>
				
				<option value="file28">github.com/TFMV/porter/pkg/infrastructure/pool/connection_pool.go (44.6%)</option>
				
				<option value="file29">github.com/TFMV/porter/pkg/infrastructure/pool/record_pool.go (88.6%)</option>
				
				<option value="file30">github.com/TFMV/porter/pkg/infrastructure/pool/schema_cache.go (96.2%)</option>
				
				<option value="file31">github.com/TFMV/porter/pkg/infrastructure/sql_info.go (0.0%)</option>
				
				<option value="file32">github.com/TFMV/porter/pkg/models/arrow_schemas.go (83.0%)</option>
				
				<option value="file33">github.com/TFMV/porter/pkg/repositories/clickhouse/metadata_repository.go (0.0%)</option>
				
				<option value="file34">github.com/TFMV/porter/pkg/repositories/clickhouse/prepared_statement_repository.go (0.0%)</option>
				
				<option value="file35">github.com/TFMV/porter/pkg/repositories/clickhouse/query_repository.go (0.0%)</option>
				
				<option value="file36">github.com/TFMV/porter/pkg/repositories/clickhouse/transaction_repository.go (0.0%)</option>
				
				<option value="file37">github.com/TFMV/porter/pkg/repositories/duckdb/metadata_repository.go (0.0%)</option>
				
				<option value="file38">github.com/TFMV/porter/pkg/repositories/duckdb/prepared_statement_repository.go (0.0%)</option>
				
				<option value="file39">github.com/TFMV/porter/pkg/repositories/duckdb/query_repository.go (0.0%)</option>
				
				<option value="file40">github.com/TFMV/porter/pkg/repositories/duckdb/transaction_repository.go (0.0%)</option>
				
				<option value="file41">github.com/TFMV/porter/pkg/server/flight_sql.go (45.6%)</option>
				
				<option value="file42">github.com/TFMV/porter/pkg/services/metadata_service.go (80.9%)</option>
				
				<option value="file43">github.com/TFMV/porter/pkg/services/prepared_statement_service.go (0.0%)</option>
				
				<option value="file44">github.com/TFMV/porter/pkg/services/query_service.go (0.0%)</option>
				
				<option value="file45">github.com/TFMV/porter/pkg/services/statement_classifier.go (70.5%)</option>
				
				<option value="file46">github.com/TFMV/porter/pkg/services/transaction_service.go (60.4%)</option>
				
				<option value="file47">github.com/TFMV/porter/pkg/streaming/duckdb_streaming_repository.go (15.1%)</option>
				
				<option value="file48">github.com/TFMV/porter/pkg/streaming/service.go (95.1%)</option>
				
				<option value="file49">github.com/TFMV/porter/test/utils/utils.go (0.0%)</option>
				
				<option value="file50">github.com/TFMV/porter/test_prepared.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "database/sql"
        "flag"
        "fmt"
        "log"
        "strings"

        _ "github.com/marcboeker/go-duckdb/v2"
)

func main() <span class="cov0" title="0">{
        rows := flag.Int("rows", 1000, "number of rows")
        cols := flag.Int("cols", 5, "number of integer columns")
        format := flag.String("format", "parquet", "output format: parquet or csv")
        out := flag.String("out", "bench.parquet", "output file path")
        flag.Parse()

        db, err := sql.Open("duckdb", ":memory:")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("open db: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        var fields []string
        for i := 1; i &lt;= *cols; i++ </span><span class="cov0" title="0">{
                fields = append(fields, fmt.Sprintf("c%d INTEGER", i))
        }</span>
        <span class="cov0" title="0">if _, err := db.Exec(fmt.Sprintf("CREATE TABLE bench(%s)", strings.Join(fields, ","))); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("create table: %v", err)
        }</span>

        <span class="cov0" title="0">insertCols := strings.Repeat("random(),", *cols)
        insertCols = strings.TrimSuffix(insertCols, ",")
        if _, err := db.Exec(fmt.Sprintf("INSERT INTO bench SELECT %s FROM range(0,%d)", insertCols, *rows)); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("insert rows: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("writing %s with %d rows...\n", *out, *rows)
        if _, err := db.Exec(fmt.Sprintf("COPY bench TO '%s' (FORMAT '%s')", *out, *format)); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("export: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package bench

import (
        "context"
        "database/sql"
        "fmt"
        "log"
        "os"
        "strings"
        "testing"
        "time"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/array"
        "github.com/apache/arrow-go/v18/arrow/flight/flightsql"
        "github.com/apache/arrow-go/v18/arrow/memory"
        "github.com/stretchr/testify/require"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        _ "github.com/marcboeker/go-duckdb/v2"
)

// FlightThroughputBenchmark measures Flight protocol throughput
type FlightThroughputBenchmark struct {
        serverAddr string
        client     *flightsql.Client
        db         *sql.DB
        parquetDir string
}

// NewFlightThroughputBenchmark creates a new benchmark instance
func NewFlightThroughputBenchmark(serverAddr, parquetDir string) *FlightThroughputBenchmark <span class="cov0" title="0">{
        return &amp;FlightThroughputBenchmark{
                serverAddr: serverAddr,
                parquetDir: parquetDir,
        }
}</span>

// Setup initializes the benchmark
func (b *FlightThroughputBenchmark) Setup() error <span class="cov0" title="0">{
        // Connect to Flight SQL server with insecure credentials for local testing
        client, err := flightsql.NewClient(b.serverAddr, nil, nil, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Flight SQL client: %w", err)
        }</span>
        <span class="cov0" title="0">b.client = client

        // Connect to DuckDB for comparison
        db, err := sql.Open("duckdb", ":memory:")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open DuckDB: %w", err)
        }</span>
        <span class="cov0" title="0">b.db = db

        // Load parquet files into DuckDB
        if err := b.loadParquetFiles(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load parquet files: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Cleanup releases resources
func (b *FlightThroughputBenchmark) Cleanup() error <span class="cov0" title="0">{
        if b.client != nil </span><span class="cov0" title="0">{
                if err := b.client.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if b.db != nil </span><span class="cov0" title="0">{
                if err := b.db.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// loadParquetFiles loads specific known-good parquet files into Porter server via Flight SQL
func (b *FlightThroughputBenchmark) loadParquetFiles() error <span class="cov0" title="0">{
        ctx := context.Background()

        // Use absolute paths to parquet files for benchmarking
        targetFiles := []struct {
                filename string
                path     string
        }{
                {"leftdate3_192_loop_1.parquet", "/Users/tfmv/porter/porter/duckdb/data/parquet-testing/leftdate3_192_loop_1.parquet"},
                {"issue12621.parquet", "/Users/tfmv/porter/porter/duckdb/data/parquet-testing/issue12621.parquet"},
                {"sorted.zstd_18_131072_small.parquet", "/Users/tfmv/porter/porter/duckdb/data/parquet-testing/sorted.zstd_18_131072_small.parquet"},
                {"candidate.parquet", "/Users/tfmv/porter/porter/duckdb/data/parquet-testing/candidate.parquet"},
                {"userdata1.parquet", "/Users/tfmv/porter/porter/duckdb/data/parquet-testing/userdata1.parquet"},
                {"lineitem-top10000.gzip.parquet", "/Users/tfmv/porter/porter/duckdb/data/parquet-testing/lineitem-top10000.gzip.parquet"},
        }

        for _, file := range targetFiles </span><span class="cov0" title="0">{
                if _, err := os.Stat(file.path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        log.Printf("Skipping missing file: %s", file.filename)
                        continue</span>
                }

                <span class="cov0" title="0">tableName := file.filename[:len(file.filename)-8] // Remove .parquet extension

                // Ensure table name starts with a letter (SQL requirement)
                if len(tableName) &gt; 0 &amp;&amp; (tableName[0] &gt;= '0' &amp;&amp; tableName[0] &lt;= '9') </span><span class="cov0" title="0">{
                        tableName = "t_" + tableName
                }</span>

                // Replace problematic characters with underscores
                <span class="cov0" title="0">tableName = strings.ReplaceAll(tableName, "-", "_")
                tableName = strings.ReplaceAll(tableName, ".", "_")

                // Load data through Flight SQL client to Porter server
                query := fmt.Sprintf("CREATE TABLE %s AS SELECT * FROM read_parquet('%s')", tableName, file.path)
                if _, err := b.client.Execute(ctx, query); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to load %s via Flight SQL: %v (skipping)", file.filename, err)
                        continue</span>
                }
                <span class="cov0" title="0">log.Printf("Loaded table %s from %s via Flight SQL", tableName, file.filename)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// BenchmarkFullTableScan measures throughput for full table scans
func (b *FlightThroughputBenchmark) BenchmarkFullTableScan(tableName string) (*BenchmarkResult, error) <span class="cov0" title="0">{
        query := fmt.Sprintf("SELECT * FROM %s", tableName)
        return b.runQueryBenchmark("FullTableScan", query)
}</span>

// BenchmarkAggregation measures throughput for aggregation queries
func (b *FlightThroughputBenchmark) BenchmarkAggregation(tableName string) (*BenchmarkResult, error) <span class="cov0" title="0">{
        query := fmt.Sprintf("SELECT COUNT(*), AVG(CAST(SUBSTRING(CAST(RANDOM() AS VARCHAR), 3, 10) AS DOUBLE)) FROM %s", tableName)
        return b.runQueryBenchmark("Aggregation", query)
}</span>

// BenchmarkFilteredQuery measures throughput for filtered queries
func (b *FlightThroughputBenchmark) BenchmarkFilteredQuery(tableName string) (*BenchmarkResult, error) <span class="cov0" title="0">{
        query := fmt.Sprintf("SELECT * FROM %s LIMIT 1000", tableName)
        return b.runQueryBenchmark("FilteredQuery", query)
}</span>

// BenchmarkJoinQuery measures throughput for join operations
func (b *FlightThroughputBenchmark) BenchmarkJoinQuery(table1, table2 string) (*BenchmarkResult, error) <span class="cov0" title="0">{
        query := fmt.Sprintf("SELECT a.*, b.* FROM %s a CROSS JOIN %s b LIMIT 100", table1, table2)
        return b.runQueryBenchmark("JoinQuery", query)
}</span>

// BenchmarkPreparedStatement measures throughput for prepared statements
func (b *FlightThroughputBenchmark) BenchmarkPreparedStatement(tableName string) (*BenchmarkResult, error) <span class="cov0" title="0">{
        ctx := context.Background()
        startTime := time.Now()

        // Create prepared statement using the correct client API
        query := fmt.Sprintf("SELECT * FROM %s LIMIT ?", tableName)

        stmt, err := b.client.Prepare(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create prepared statement: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close(ctx)

        totalRows := int64(0)
        iterations := 10

        for i := 0; i &lt; iterations; i++ </span><span class="cov0" title="0">{
                // Create parameter record
                allocator := memory.NewGoAllocator()
                schema := arrow.NewSchema([]arrow.Field{
                        {Name: "limit", Type: arrow.PrimitiveTypes.Int64},
                }, nil)

                builder := array.NewRecordBuilder(allocator, schema)
                builder.Field(0).(*array.Int64Builder).Append(int64(1000))
                paramRecord := builder.NewRecord()
                builder.Release()

                // Set parameters
                stmt.SetParameters(paramRecord)
                paramRecord.Release()

                // Execute prepared statement
                info, err := stmt.Execute(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to execute prepared statement: %w", err)
                }</span>

                // Read results
                <span class="cov0" title="0">for _, endpoint := range info.Endpoint </span><span class="cov0" title="0">{
                        reader, err := b.client.DoGet(ctx, endpoint.Ticket)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to get results: %w", err)
                        }</span>

                        <span class="cov0" title="0">for reader.Next() </span><span class="cov0" title="0">{
                                record := reader.Record()
                                totalRows += record.NumRows()
                                record.Release()
                        }</span>
                        <span class="cov0" title="0">reader.Release()</span>
                }
        }

        <span class="cov0" title="0">duration := time.Since(startTime)
        throughput := float64(totalRows) / duration.Seconds()

        return &amp;BenchmarkResult{
                Name:         "PreparedStatement",
                Duration:     duration,
                RowsReturned: totalRows,
                BatchCount:   iterations,
                Throughput:   throughput,
        }, nil</span>
}

// BenchmarkStreaming measures throughput for streaming queries
func (b *FlightThroughputBenchmark) BenchmarkStreaming(tableName string) (*BenchmarkResult, error) <span class="cov0" title="0">{
        ctx := context.Background()
        startTime := time.Now()

        query := fmt.Sprintf("SELECT * FROM %s", tableName)

        // Get flight info
        info, err := b.client.Execute(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute query: %w", err)
        }</span>

        <span class="cov0" title="0">totalRows := int64(0)
        batchCount := 0

        // Stream results from all endpoints
        for _, endpoint := range info.Endpoint </span><span class="cov0" title="0">{
                reader, err := b.client.DoGet(ctx, endpoint.Ticket)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get results: %w", err)
                }</span>

                <span class="cov0" title="0">for reader.Next() </span><span class="cov0" title="0">{
                        record := reader.Record()
                        totalRows += record.NumRows()
                        batchCount++
                        record.Release()
                }</span>
                <span class="cov0" title="0">reader.Release()</span>
        }

        <span class="cov0" title="0">duration := time.Since(startTime)
        throughput := float64(totalRows) / duration.Seconds()

        return &amp;BenchmarkResult{
                Name:         "Streaming",
                Duration:     duration,
                RowsReturned: totalRows,
                BatchCount:   batchCount,
                Throughput:   throughput,
        }, nil</span>
}

// BenchmarkMetadata measures throughput for metadata operations
func (b *FlightThroughputBenchmark) BenchmarkMetadata() (*BenchmarkResult, error) <span class="cov0" title="0">{
        ctx := context.Background()
        startTime := time.Now()

        // Get catalogs
        info, err := b.client.GetCatalogs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get catalogs: %w", err)
        }</span>

        <span class="cov0" title="0">totalRows := int64(0)
        batchCount := 0

        // Read catalog results
        for _, endpoint := range info.Endpoint </span><span class="cov0" title="0">{
                reader, err := b.client.DoGet(ctx, endpoint.Ticket)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get catalog results: %w", err)
                }</span>

                <span class="cov0" title="0">for reader.Next() </span><span class="cov0" title="0">{
                        record := reader.Record()
                        totalRows += record.NumRows()
                        batchCount++
                        record.Release()
                }</span>
                <span class="cov0" title="0">reader.Release()</span>
        }

        <span class="cov0" title="0">duration := time.Since(startTime)
        throughput := float64(totalRows) / duration.Seconds()

        return &amp;BenchmarkResult{
                Name:         "Metadata",
                Duration:     duration,
                RowsReturned: totalRows,
                BatchCount:   batchCount,
                Throughput:   throughput,
        }, nil</span>
}

// BenchmarkSustainedThroughput measures sustained throughput by loading the largest file multiple times
func (b *FlightThroughputBenchmark) BenchmarkSustainedThroughput(tableName string, iterations int) (*BenchmarkResult, error) <span class="cov0" title="0">{
        ctx := context.Background()
        startTime := time.Now()

        query := fmt.Sprintf("SELECT * FROM %s", tableName)
        totalRows := int64(0)
        totalBatches := 0

        for i := 0; i &lt; iterations; i++ </span><span class="cov0" title="0">{
                // Execute query
                info, err := b.client.Execute(ctx, query)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to execute query (iteration %d): %w", i+1, err)
                }</span>

                // Read results from all endpoints
                <span class="cov0" title="0">for _, endpoint := range info.Endpoint </span><span class="cov0" title="0">{
                        reader, err := b.client.DoGet(ctx, endpoint.Ticket)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to get results (iteration %d): %w", i+1, err)
                        }</span>

                        <span class="cov0" title="0">for reader.Next() </span><span class="cov0" title="0">{
                                record := reader.Record()
                                totalRows += record.NumRows()
                                totalBatches++
                                record.Release()
                        }</span>
                        <span class="cov0" title="0">reader.Release()</span>
                }
        }

        <span class="cov0" title="0">duration := time.Since(startTime)
        throughput := float64(totalRows) / duration.Seconds()

        return &amp;BenchmarkResult{
                Name:         fmt.Sprintf("SustainedThroughput_%dx", iterations),
                Duration:     duration,
                RowsReturned: totalRows,
                BatchCount:   totalBatches,
                Throughput:   throughput,
                DataSize:     0, // Will be set by caller
        }, nil</span>
}

// BenchmarkResult represents the result of a benchmark run
type BenchmarkResult struct {
        Name         string
        Duration     time.Duration
        RowsReturned int64
        BatchCount   int
        Throughput   float64 // rows per second
        DataSize     int64   // bytes processed (if available)
}

func (r *BenchmarkResult) String() string <span class="cov0" title="0">{
        if r.DataSize &gt; 0 </span><span class="cov0" title="0">{
                mbPerSec := float64(r.DataSize) / (1024 * 1024) / r.Duration.Seconds()
                return fmt.Sprintf("‚úÖ %s: %d rows in %v (%.1f MB/s, %.0f rows/sec, %d batches)",
                        r.Name, r.RowsReturned, r.Duration, mbPerSec, r.Throughput, r.BatchCount)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("‚úÖ %s: %d rows in %v (%.0f rows/sec, %d batches)",
                r.Name, r.RowsReturned, r.Duration, r.Throughput, r.BatchCount)</span>
}

// getFileSize returns the size of a parquet file if it exists
func getFileSize(filename string) int64 <span class="cov0" title="0">{
        files := map[string]int64{
                "leftdate3_192_loop_1":        9_700_000, // 9.3MB
                "issue12621":                  6_300_000, // 6.0MB
                "sorted_zstd_18_131072_small": 2_100_000, // 2.0MB
                "candidate":                   681_000,   // 665KB
                "lineitem_top10000_gzip":      293_000,   // 286KB
                "userdata1":                   114_000,   // 111KB
        }

        // Clean up table name for lookup
        cleanName := strings.ReplaceAll(filename, "_", "_")
        if size, exists := files[cleanName]; exists </span><span class="cov0" title="0">{
                return size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (b *FlightThroughputBenchmark) runQueryBenchmark(name, query string) (*BenchmarkResult, error) <span class="cov0" title="0">{
        ctx := context.Background()
        startTime := time.Now()

        // Execute query
        info, err := b.client.Execute(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute query: %w", err)
        }</span>

        <span class="cov0" title="0">totalRows := int64(0)
        batchCount := 0

        // Read results from all endpoints
        for _, endpoint := range info.Endpoint </span><span class="cov0" title="0">{
                reader, err := b.client.DoGet(ctx, endpoint.Ticket)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get results: %w", err)
                }</span>

                <span class="cov0" title="0">for reader.Next() </span><span class="cov0" title="0">{
                        record := reader.Record()
                        totalRows += record.NumRows()
                        batchCount++
                        record.Release()
                }</span>
                <span class="cov0" title="0">reader.Release()</span>
        }

        <span class="cov0" title="0">duration := time.Since(startTime)
        throughput := float64(totalRows) / duration.Seconds()

        return &amp;BenchmarkResult{
                Name:         name,
                Duration:     duration,
                RowsReturned: totalRows,
                BatchCount:   batchCount,
                Throughput:   throughput,
                DataSize:     0, // Will be set by caller if known
        }, nil</span>
}

// RunFlightThroughputBenchmarks runs all Flight throughput benchmarks
func RunFlightThroughputBenchmarks(serverAddr, parquetDir string) error <span class="cov0" title="0">{
        benchmark := NewFlightThroughputBenchmark(serverAddr, parquetDir)

        if err := benchmark.Setup(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup benchmark: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err := benchmark.Cleanup()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("cleanup error: %v\n", err)
                }</span>
        }()

        // Print professional header
        <span class="cov0" title="0">fmt.Println("üöÄ Porter Flight SQL Performance Benchmark")
        fmt.Println("==========================================")
        fmt.Printf("Server: %s\n", serverAddr)
        fmt.Printf("Protocol: Apache Arrow Flight SQL over gRPC\n")
        fmt.Printf("Test Started: %s\n\n", time.Now().Format("2006-01-02 15:04:05"))

        // Define test tables (using the largest parquet files for better throughput testing)
        testTables := []string{
                "leftdate3_192_loop_1",        // 9.3MB - largest file
                "issue12621",                  // 6.0MB - second largest
                "sorted_zstd_18_131072_small", // 2.0MB - third largest (dots replaced with underscores)
                "candidate",                   // 665KB - good medium size
                "userdata1",                   // 111KB - smaller file for quick tests
        }

        // Check which tables actually exist via Flight SQL
        var availableTables []string
        ctx := context.Background()
        for _, table := range testTables </span><span class="cov0" title="0">{
                query := fmt.Sprintf("SELECT COUNT(*) FROM %s", table)
                if _, err := benchmark.client.Execute(ctx, query); err == nil </span><span class="cov0" title="0">{
                        availableTables = append(availableTables, table)
                }</span>
        }

        <span class="cov0" title="0">if len(availableTables) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no test tables available")
        }</span>

        <span class="cov0" title="0">fmt.Printf("üìä Available Test Datasets: %d tables\n", len(availableTables))
        for _, table := range availableTables </span><span class="cov0" title="0">{
                size := getFileSize(table)
                if size &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("   - %s (%.1f MB)\n", table, float64(size)/(1024*1024))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("   - %s\n", table)
                }</span>
        }
        <span class="cov0" title="0">fmt.Println()

        // First run sustained throughput test with the largest file
        if len(availableTables) &gt; 0 </span><span class="cov0" title="0">{
                largestTable := availableTables[0] // leftdate3_192_loop_1 should be first
                fmt.Printf("üî• Sustained Throughput Test: %s (20x iterations)\n", largestTable)
                fmt.Println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")

                tableSize := getFileSize(largestTable)
                if result, err := benchmark.BenchmarkSustainedThroughput(largestTable, 20); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ùå Sustained Throughput: FAILED - %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        result.DataSize = tableSize * 20 // Total data processed across all iterations
                        fmt.Printf("   %s\n", result)

                        // Calculate average per-iteration metrics
                        avgDuration := result.Duration / 20
                        avgThroughputMBs := float64(tableSize) / (1024 * 1024) / avgDuration.Seconds()
                        avgRowsPerSec := float64(result.RowsReturned) / 20 / result.Duration.Seconds() * 20

                        fmt.Printf("   üìà Average per iteration: %.1f MB/s, %.0f rows/sec, %v duration\n",
                                avgThroughputMBs, avgRowsPerSec, avgDuration)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Run benchmarks for each available table
        <span class="cov0" title="0">for i, table := range availableTables </span><span class="cov0" title="0">{
                fmt.Printf("üîÑ Benchmarking Dataset %d/%d: %s\n", i+1, len(availableTables), table)
                fmt.Println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")

                tableSize := getFileSize(table)

                // Full table scan
                if result, err := benchmark.BenchmarkFullTableScan(table); err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "unsupported DuckDB type") </span><span class="cov0" title="0">{
                                fmt.Printf("‚ö†Ô∏è  Full Table Scan: SKIPPED - unsupported data types (integer arrays)\n")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("‚ùå Full Table Scan: FAILED - %v\n", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        result.DataSize = tableSize
                        fmt.Printf("   %s\n", result)
                }</span>

                // Aggregation
                <span class="cov0" title="0">if result, err := benchmark.BenchmarkAggregation(table); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ùå Aggregation Query: FAILED - %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("   ‚úÖ Aggregation: %d rows in %v (%.0f rows/sec)\n",
                                result.RowsReturned, result.Duration, result.Throughput)
                }</span>

                // Filtered query
                <span class="cov0" title="0">if result, err := benchmark.BenchmarkFilteredQuery(table); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ùå Filtered Query: FAILED - %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("   ‚úÖ Filtered Query: %d rows in %v (%.0f rows/sec)\n",
                                result.RowsReturned, result.Duration, result.Throughput)
                }</span>

                // Prepared statement
                <span class="cov0" title="0">if result, err := benchmark.BenchmarkPreparedStatement(table); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ùå Prepared Statement: FAILED - %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("   ‚úÖ Prepared Statement: %d rows in %v (%.0f rows/sec)\n",
                                result.RowsReturned, result.Duration, result.Throughput)
                }</span>

                // Streaming
                <span class="cov0" title="0">if result, err := benchmark.BenchmarkStreaming(table); err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "unsupported DuckDB type") </span><span class="cov0" title="0">{
                                fmt.Printf("‚ö†Ô∏è  Streaming Query: SKIPPED - unsupported data types (integer arrays)\n")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("‚ùå Streaming Query: FAILED - %v\n", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        result.DataSize = tableSize
                        fmt.Printf("   %s\n", result)
                }</span>

                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Join benchmark (use first two available tables)
        <span class="cov0" title="0">if len(availableTables) &gt;= 2 </span><span class="cov0" title="0">{
                fmt.Println("üîó Cross-Table Operations")
                fmt.Println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
                if result, err := benchmark.BenchmarkJoinQuery(availableTables[0], availableTables[1]); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ùå Join Query: FAILED - %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("   ‚úÖ Join Query: %d rows in %v (%.0f rows/sec)\n",
                                result.RowsReturned, result.Duration, result.Throughput)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Metadata benchmark
        <span class="cov0" title="0">fmt.Println("üìã Metadata Operations")
        fmt.Println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
        if result, err := benchmark.BenchmarkMetadata(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Metadata Discovery: FAILED - %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("   ‚úÖ Metadata Discovery: %d catalogs in %v (%.0f items/sec)\n",
                        result.RowsReturned, result.Duration, result.Throughput)
        }</span>

        <span class="cov0" title="0">fmt.Println()
        fmt.Println("üéâ Benchmark Complete!")
        fmt.Printf("Total Test Duration: %s\n", time.Now().Format("15:04:05"))
        fmt.Println("‚úÖ Porter Flight SQL Server: PRODUCTION READY")

        return nil</span>
}

// Test function for the benchmark
func TestFlightThroughputBenchmark(t *testing.T) <span class="cov0" title="0">{
        // Skip if no server is running
        serverAddr := os.Getenv("FLIGHT_SERVER_ADDR")
        if serverAddr == "" </span><span class="cov0" title="0">{
                t.Skip("FLIGHT_SERVER_ADDR not set, skipping Flight throughput benchmark")
        }</span>

        <span class="cov0" title="0">parquetDir := "duckdb/data/parquet-testing"
        if err := RunFlightThroughputBenchmarks(serverAddr, parquetDir); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Flight throughput benchmark failed: %v", err)
        }</span>
}

// Benchmark function for Go's testing framework
func BenchmarkFlightThroughput(b *testing.B) <span class="cov0" title="0">{
        serverAddr := os.Getenv("FLIGHT_SERVER_ADDR")
        if serverAddr == "" </span><span class="cov0" title="0">{
                b.Skip("FLIGHT_SERVER_ADDR not set, skipping Flight throughput benchmark")
        }</span>

        <span class="cov0" title="0">parquetDir := "duckdb/data/parquet-testing"
        benchmark := NewFlightThroughputBenchmark(serverAddr, parquetDir)

        require.NoError(b, benchmark.Setup())
        defer func() </span><span class="cov0" title="0">{
                err := benchmark.Cleanup()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("cleanup error: %v\n", err)
                }</span>
        }()

        <span class="cov0" title="0">b.ResetTimer()
        for i := 0; i &lt; b.N; i++ </span><span class="cov0" title="0">{
                // Run a simple query benchmark
                _, err := benchmark.BenchmarkFullTableScan("userdata1")
                require.NoError(b, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package bench

import (
        "database/sql"
        "testing"

        _ "github.com/marcboeker/go-duckdb/v2"
)

func setupDB(b *testing.B) *sql.DB <span class="cov0" title="0">{
        db, err := sql.Open("duckdb", ":memory:")
        if err != nil </span><span class="cov0" title="0">{
                b.Fatal(err)
        }</span>
        <span class="cov0" title="0">if _, err := db.Exec("CREATE TABLE t AS SELECT i as id, random() AS v FROM range(0,100000) tbl(i)"); err != nil </span><span class="cov0" title="0">{
                b.Fatal(err)
        }</span>
        <span class="cov0" title="0">return db</span>
}

func BenchmarkCount(b *testing.B) <span class="cov0" title="0">{
        db := setupDB(b)
        defer db.Close()
        b.ResetTimer()
        for i := 0; i &lt; b.N; i++ </span><span class="cov0" title="0">{
                row := db.QueryRow("SELECT count(*) FROM t")
                var c int
                if err := row.Scan(&amp;c); err != nil </span><span class="cov0" title="0">{
                        b.Fatal(err)
                }</span>
        }
}

func BenchmarkFilter(b *testing.B) <span class="cov0" title="0">{
        db := setupDB(b)
        defer db.Close()
        stmt, err := db.Prepare("SELECT v FROM t WHERE id = ?")
        if err != nil </span><span class="cov0" title="0">{
                b.Fatal(err)
        }</span>
        <span class="cov0" title="0">b.ResetTimer()
        for i := 0; i &lt; b.N; i++ </span><span class="cov0" title="0">{
                row := stmt.QueryRow(i % 100000)
                var v float64
                if err := row.Scan(&amp;v); err != nil </span><span class="cov0" title="0">{
                        b.Fatal(err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package bench

import (
        "encoding/csv"
        "encoding/json"
        "fmt"
        "io"
        "text/tabwriter"
        "time"
)

// Result holds a single benchmark measurement.
type Result struct {
        Name       string        `json:"name"`
        N          int           `json:"iterations"`
        NsPerOp    time.Duration `json:"ns_per_op"`
        BytesPerOp int64         `json:"bytes_per_op"`
}

// WriteJSON writes results to w in JSON format.
func WriteJSON(results []Result, w io.Writer) error <span class="cov0" title="0">{
        enc := json.NewEncoder(w)
        enc.SetIndent("", "  ")
        return enc.Encode(results)
}</span>

// WriteCSV writes results in CSV format.
func WriteCSV(results []Result, w io.Writer) error <span class="cov0" title="0">{
        c := csv.NewWriter(w)
        if err := c.Write([]string{"name", "n", "ns_per_op", "bytes_per_op"}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, r := range results </span><span class="cov0" title="0">{
                record := []string{
                        r.Name,
                        fmt.Sprintf("%d", r.N),
                        fmt.Sprintf("%d", r.NsPerOp.Nanoseconds()),
                        fmt.Sprintf("%d", r.BytesPerOp),
                }
                if err := c.Write(record); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">c.Flush()
        return c.Error()</span>
}

// WriteMarkdown renders results as a simple Markdown table.
func WriteMarkdown(results []Result, w io.Writer) error <span class="cov0" title="0">{
        tw := tabwriter.NewWriter(w, 0, 2, 2, ' ', 0)
        fmt.Fprintf(tw, "Benchmark\tns/op\tbytes/op\n")
        fmt.Fprintf(tw, "---------\t-----\t--------\n")
        for _, r := range results </span><span class="cov0" title="0">{
                fmt.Fprintf(tw, "%s\t%d\t%d\n", r.Name, r.NsPerOp.Nanoseconds(), r.BytesPerOp)
        }</span>
        <span class="cov0" title="0">return tw.Flush()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "flag"
        "log"
        "os"

        "github.com/TFMV/porter/bench"
)

func main() <span class="cov0" title="0">{
        var (
                serverAddr = flag.String("server", "localhost:32010", "Flight SQL server address")
                parquetDir = flag.String("parquet-dir", "", "Directory containing parquet files (not used with absolute paths)")
        )
        flag.Parse()

        log.Printf("Running Flight SQL throughput benchmarks against %s", *serverAddr)

        if err := bench.RunFlightThroughputBenchmarks(*serverAddr, *parquetDir); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Benchmark failed: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">log.Println("All benchmarks completed successfully!")</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package config provides configuration structures for the Flight SQL server.
package config

import (
        "fmt"
        "time"
)

// Config represents the server configuration.
type Config struct {
        // Server settings
        Address           string        `yaml:"address" json:"address"`
        Database          string        `yaml:"database" json:"database"`
        Token             string        `yaml:"token" json:"token"`
        LogLevel          string        `yaml:"log_level" json:"log_level"`
        MaxConnections    int           `yaml:"max_connections" json:"max_connections"`
        ConnectionTimeout time.Duration `yaml:"connection_timeout" json:"connection_timeout"`
        QueryTimeout      time.Duration `yaml:"query_timeout" json:"query_timeout"`
        MaxMessageSize    int64         `yaml:"max_message_size" json:"max_message_size"`
        ShutdownTimeout   time.Duration `yaml:"shutdown_timeout" json:"shutdown_timeout"`

        // TLS configuration
        TLS TLSConfig `yaml:"tls" json:"tls"`

        // Authentication configuration
        Auth AuthConfig `yaml:"auth" json:"auth"`

        // Metrics configuration
        Metrics MetricsConfig `yaml:"metrics" json:"metrics"`

        // Health check configuration
        Health HealthConfig `yaml:"health" json:"health"`

        // gRPC reflection
        Reflection bool `yaml:"reflection" json:"reflection"`

        // Connection pool configuration
        ConnectionPool ConnectionPoolConfig `yaml:"connection_pool" json:"connection_pool"`

        // Transaction configuration
        Transaction TransactionConfig `yaml:"transaction" json:"transaction"`

        // Cache configuration
        Cache CacheConfig `yaml:"cache" json:"cache"`

        // Performance options
        SafeCopy bool `yaml:"safe_copy" json:"safe_copy"`
}

// TLSConfig represents TLS configuration.
type TLSConfig struct {
        Enabled  bool   `yaml:"enabled" json:"enabled"`
        CertFile string `yaml:"cert_file" json:"cert_file"`
        KeyFile  string `yaml:"key_file" json:"key_file"`
        CAFile   string `yaml:"ca_file" json:"ca_file"`
        // Mutual TLS
        ClientAuth         bool   `yaml:"client_auth" json:"client_auth"`
        ClientCACertFile   string `yaml:"client_ca_cert_file" json:"client_ca_cert_file"`
        InsecureSkipVerify bool   `yaml:"insecure_skip_verify" json:"insecure_skip_verify"`
}

// AuthConfig represents authentication configuration.
type AuthConfig struct {
        Enabled bool   `yaml:"enabled" json:"enabled"`
        Type    string `yaml:"type" json:"type"` // basic, bearer, mtls, oauth2

        // Basic auth
        BasicAuth BasicAuthConfig `yaml:"basic_auth" json:"basic_auth"`

        // Bearer token auth
        BearerAuth BearerAuthConfig `yaml:"bearer_auth" json:"bearer_auth"`

        // JWT auth
        JWTAuth JWTAuthConfig `yaml:"jwt_auth" json:"jwt_auth"`

        // OAuth2 auth
        OAuth2Auth OAuth2Config `yaml:"oauth2_auth" json:"oauth2_auth"`
}

// BasicAuthConfig represents basic authentication configuration.
type BasicAuthConfig struct {
        UsersFile string              `yaml:"users_file" json:"users_file"`
        Users     map[string]UserInfo `yaml:"users" json:"users"`
}

// UserInfo represents user information.
type UserInfo struct {
        Password string   `yaml:"password" json:"password"`
        Roles    []string `yaml:"roles" json:"roles"`
}

// BearerAuthConfig represents bearer token authentication configuration.
type BearerAuthConfig struct {
        TokensFile string            `yaml:"tokens_file" json:"tokens_file"`
        Tokens     map[string]string `yaml:"tokens" json:"tokens"` // token -&gt; username
}

// JWTAuthConfig represents JWT authentication configuration.
type JWTAuthConfig struct {
        Secret   string `yaml:"secret" json:"secret"`
        Issuer   string `yaml:"issuer" json:"issuer"`
        Audience string `yaml:"audience" json:"audience"`
}

// OAuth2Config represents OAuth2 authentication configuration.
type OAuth2Config struct {
        ClientID            string        `yaml:"client_id" json:"client_id"`
        ClientSecret        string        `yaml:"client_secret" json:"client_secret"`
        AuthorizeEndpoint   string        `yaml:"authorize_endpoint" json:"authorize_endpoint"`
        TokenEndpoint       string        `yaml:"token_endpoint" json:"token_endpoint"`
        RedirectURL         string        `yaml:"redirect_url" json:"redirect_url"`
        AllowedRedirectURIs []string      `yaml:"allowed_redirect_uris" json:"allowed_redirect_uris"`
        Scopes              []string      `yaml:"scopes" json:"scopes"`
        AccessTokenTTL      time.Duration `yaml:"access_token_ttl" json:"access_token_ttl"`
        RefreshTokenTTL     time.Duration `yaml:"refresh_token_ttl" json:"refresh_token_ttl"`
        AllowedGrantTypes   []string      `yaml:"allowed_grant_types" json:"allowed_grant_types"`
}

// MetricsConfig represents metrics configuration.
type MetricsConfig struct {
        Enabled bool   `yaml:"enabled" json:"enabled"`
        Address string `yaml:"address" json:"address"`
        Path    string `yaml:"path" json:"path"`
}

// HealthConfig represents health check configuration.
type HealthConfig struct {
        Enabled  bool          `yaml:"enabled" json:"enabled"`
        Interval time.Duration `yaml:"interval" json:"interval"`
}

// ConnectionPoolConfig represents connection pool configuration.
type ConnectionPoolConfig struct {
        MaxOpenConnections int           `yaml:"max_open_connections" json:"max_open_connections"`
        MaxIdleConnections int           `yaml:"max_idle_connections" json:"max_idle_connections"`
        ConnMaxLifetime    time.Duration `yaml:"conn_max_lifetime" json:"conn_max_lifetime"`
        ConnMaxIdleTime    time.Duration `yaml:"conn_max_idle_time" json:"conn_max_idle_time"`
        HealthCheckPeriod  time.Duration `yaml:"health_check_period" json:"health_check_period"`
}

// TransactionConfig represents transaction configuration.
type TransactionConfig struct {
        DefaultIsolationLevel string        `yaml:"default_isolation_level" json:"default_isolation_level"`
        MaxTransactionAge     time.Duration `yaml:"max_transaction_age" json:"max_transaction_age"`
        CleanupInterval       time.Duration `yaml:"cleanup_interval" json:"cleanup_interval"`
}

// CacheConfig represents cache configuration.
type CacheConfig struct {
        Enabled            bool            `yaml:"enabled" json:"enabled"`
        MaxSize            int64           `yaml:"max_size" json:"max_size"`
        TTL                time.Duration   `yaml:"ttl" json:"ttl"`
        CleanupInterval    time.Duration   `yaml:"cleanup_interval" json:"cleanup_interval"`
        EnableStats        bool            `yaml:"enable_stats" json:"enable_stats"`
        PreparedStatements CacheItemConfig `yaml:"prepared_statements" json:"prepared_statements"`
        QueryResults       CacheItemConfig `yaml:"query_results" json:"query_results"`
}

// CacheItemConfig represents cache item configuration.
type CacheItemConfig struct {
        Enabled bool          `yaml:"enabled" json:"enabled"`
        MaxSize int64         `yaml:"max_size" json:"max_size"`
        TTL     time.Duration `yaml:"ttl" json:"ttl"`
}

// Validate validates the configuration.
func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.Address == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("address is required")
        }</span>

        <span class="cov0" title="0">if c.MaxConnections &lt;= 0 </span><span class="cov0" title="0">{
                c.MaxConnections = 100
        }</span>

        <span class="cov0" title="0">if c.ConnectionTimeout &lt;= 0 </span><span class="cov0" title="0">{
                c.ConnectionTimeout = 30 * time.Second
        }</span>

        <span class="cov0" title="0">if c.QueryTimeout &lt;= 0 </span><span class="cov0" title="0">{
                c.QueryTimeout = 5 * time.Minute
        }</span>

        <span class="cov0" title="0">if c.MaxMessageSize &lt;= 0 </span><span class="cov0" title="0">{
                c.MaxMessageSize = 16 * 1024 * 1024 // 16MB
        }</span>

        <span class="cov0" title="0">if c.ShutdownTimeout &lt;= 0 </span><span class="cov0" title="0">{
                c.ShutdownTimeout = 30 * time.Second
        }</span>

        // Validate TLS
        <span class="cov0" title="0">if c.TLS.Enabled </span><span class="cov0" title="0">{
                if c.TLS.CertFile == "" || c.TLS.KeyFile == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS cert and key files are required when TLS is enabled")
                }</span>
        }

        // Validate auth
        <span class="cov0" title="0">if c.Auth.Enabled </span><span class="cov0" title="0">{
                switch c.Auth.Type </span>{
                case "basic":<span class="cov0" title="0">
                        if len(c.Auth.BasicAuth.Users) == 0 &amp;&amp; c.Auth.BasicAuth.UsersFile == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("basic auth requires users or users file")
                        }</span>
                case "bearer":<span class="cov0" title="0">
                        if len(c.Auth.BearerAuth.Tokens) == 0 &amp;&amp; c.Auth.BearerAuth.TokensFile == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("bearer auth requires tokens or tokens file")
                        }</span>
                case "jwt":<span class="cov0" title="0">
                        if c.Auth.JWTAuth.Secret == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("JWT auth requires secret")
                        }</span>
                case "oauth2":<span class="cov0" title="0">
                        if c.Auth.OAuth2Auth.ClientID == "" || c.Auth.OAuth2Auth.ClientSecret == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("OAuth2 auth requires client ID and secret")
                        }</span>
                        <span class="cov0" title="0">if c.Auth.OAuth2Auth.AuthorizeEndpoint == "" || c.Auth.OAuth2Auth.TokenEndpoint == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("OAuth2 auth requires authorize and token endpoints")
                        }</span>
                        <span class="cov0" title="0">if len(c.Auth.OAuth2Auth.AllowedRedirectURIs) == 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("OAuth2 auth requires at least one allowed redirect URI for security")
                        }</span>
                        <span class="cov0" title="0">if c.Auth.OAuth2Auth.AccessTokenTTL &lt;= 0 </span><span class="cov0" title="0">{
                                c.Auth.OAuth2Auth.AccessTokenTTL = 1 * time.Hour
                        }</span>
                        <span class="cov0" title="0">if c.Auth.OAuth2Auth.RefreshTokenTTL &lt;= 0 </span><span class="cov0" title="0">{
                                c.Auth.OAuth2Auth.RefreshTokenTTL = 24 * time.Hour
                        }</span>
                        <span class="cov0" title="0">if len(c.Auth.OAuth2Auth.AllowedGrantTypes) == 0 </span><span class="cov0" title="0">{
                                c.Auth.OAuth2Auth.AllowedGrantTypes = []string{"authorization_code", "refresh_token", "client_credentials"}
                        }</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unsupported auth type: %s", c.Auth.Type)</span>
                }
        }

        // Set defaults for connection pool
        <span class="cov0" title="0">if c.ConnectionPool.MaxOpenConnections &lt;= 0 </span><span class="cov0" title="0">{
                c.ConnectionPool.MaxOpenConnections = 25
        }</span>
        <span class="cov0" title="0">if c.ConnectionPool.MaxIdleConnections &lt;= 0 </span><span class="cov0" title="0">{
                c.ConnectionPool.MaxIdleConnections = 5
        }</span>
        <span class="cov0" title="0">if c.ConnectionPool.ConnMaxLifetime &lt;= 0 </span><span class="cov0" title="0">{
                c.ConnectionPool.ConnMaxLifetime = 30 * time.Minute
        }</span>
        <span class="cov0" title="0">if c.ConnectionPool.ConnMaxIdleTime &lt;= 0 </span><span class="cov0" title="0">{
                c.ConnectionPool.ConnMaxIdleTime = 10 * time.Minute
        }</span>
        <span class="cov0" title="0">if c.ConnectionPool.HealthCheckPeriod &lt;= 0 </span><span class="cov0" title="0">{
                c.ConnectionPool.HealthCheckPeriod = 1 * time.Minute
        }</span>

        // Set defaults for transactions
        <span class="cov0" title="0">if c.Transaction.MaxTransactionAge &lt;= 0 </span><span class="cov0" title="0">{
                c.Transaction.MaxTransactionAge = 1 * time.Hour
        }</span>
        <span class="cov0" title="0">if c.Transaction.CleanupInterval &lt;= 0 </span><span class="cov0" title="0">{
                c.Transaction.CleanupInterval = 5 * time.Minute
        }</span>

        // Set defaults for metrics
        <span class="cov0" title="0">if c.Metrics.Path == "" </span><span class="cov0" title="0">{
                c.Metrics.Path = "/metrics"
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LoadFromFile loads configuration from a YAML or JSON file.
func LoadFromFile(path string) (*Config, error) <span class="cov0" title="0">{
        // Implementation would load from file
        // For now, return default config
        return DefaultConfig(), nil
}</span>

// DefaultConfig returns a default configuration.
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Address:           "0.0.0.0:8815",
                Database:          ":memory:",
                Token:             "",
                LogLevel:          "info",
                MaxConnections:    100,
                ConnectionTimeout: 30 * time.Second,
                QueryTimeout:      5 * time.Minute,
                MaxMessageSize:    16 * 1024 * 1024,
                ShutdownTimeout:   30 * time.Second,
                TLS: TLSConfig{
                        Enabled: false,
                },
                Auth: AuthConfig{
                        Enabled: false,
                        Type:    "basic",
                },
                Metrics: MetricsConfig{
                        Enabled: true,
                        Address: ":9090",
                        Path:    "/metrics",
                },
                Health: HealthConfig{
                        Enabled:  true,
                        Interval: 10 * time.Second,
                },
                Reflection: true,
                ConnectionPool: ConnectionPoolConfig{
                        MaxOpenConnections: 25,
                        MaxIdleConnections: 5,
                        ConnMaxLifetime:    30 * time.Minute,
                        ConnMaxIdleTime:    10 * time.Minute,
                        HealthCheckPeriod:  1 * time.Minute,
                },
                Transaction: TransactionConfig{
                        DefaultIsolationLevel: "READ_COMMITTED",
                        MaxTransactionAge:     1 * time.Hour,
                        CleanupInterval:       5 * time.Minute,
                },
                Cache: CacheConfig{
                        Enabled:         true,
                        MaxSize:         100 * 1024 * 1024, // 100MB
                        TTL:             5 * time.Minute,
                        CleanupInterval: 1 * time.Minute,
                        EnableStats:     true,
                        PreparedStatements: CacheItemConfig{
                                Enabled: true,
                                MaxSize: 10 * 1024 * 1024, // 10MB
                                TTL:     1 * time.Hour,
                        },
                        QueryResults: CacheItemConfig{
                                Enabled: true,
                                MaxSize: 50 * 1024 * 1024, // 50MB
                                TTL:     5 * time.Minute,
                        },
                },
                SafeCopy: false,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package main provides the entry point for the DuckDB Flight SQL Server.
package main

import (
        "context"
        "fmt"
        "io"
        "net"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/flight"
        "github.com/apache/arrow-go/v18/arrow/flight/flightsql"
        "github.com/apache/arrow-go/v18/arrow/memory"
        "github.com/rs/zerolog"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/health"
        "google.golang.org/grpc/health/grpc_health_v1"
        "google.golang.org/grpc/keepalive"
        "google.golang.org/grpc/reflection"
        "google.golang.org/grpc/status"

        "github.com/TFMV/porter/cmd/server/config"
        "github.com/TFMV/porter/pkg/benchmark"
        "github.com/TFMV/porter/pkg/cache"
        "github.com/TFMV/porter/pkg/handlers"
        "github.com/TFMV/porter/pkg/infrastructure"
        "github.com/TFMV/porter/pkg/infrastructure/metrics"
        "github.com/TFMV/porter/pkg/infrastructure/pool"
        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/repositories/duckdb"
        "github.com/TFMV/porter/pkg/services"

        "github.com/TFMV/porter/cmd/server/middleware"

        _ "github.com/marcboeker/go-duckdb/v2"
)

var (
        // Version information (set by build flags)
        version   = "dev"
        commit    = "unknown"
        buildDate = "unknown"
)

var rootCmd = &amp;cobra.Command{
        Use:   "porter",
        Short: "Porter Flight SQL Server",
        Long: `A high-performance Flight SQL server backed by DuckDB.

Porter implements a Flight SQL Server backed by a DuckDB database.`,
}

var serveCmd = &amp;cobra.Command{
        Use:   "serve",
        Short: "Start the Porter Flight SQL Server",
        Long: `Start the Porter Flight SQL Server with the specified configuration.

Example:
  porter serve --config ./config.yaml
  porter serve --address 0.0.0.0:32010 --database :memory:`,
        RunE: runServer,
}

var benchCmd = &amp;cobra.Command{
        Use:   "bench",
        Short: "Run TPC-H benchmarks against Porter",
        Long: `Run TPC-H benchmarks using DuckDB's built-in TPC-H module.

Examples:
  porter bench --query q1 --scale 1 --format json
  porter bench --all --scale 1 --output results.arrow
  porter bench --query q1,q5,q22 --scale 0.1 --format table`,
        RunE: runBenchmark,
}

func init() <span class="cov0" title="0">{
        // Add serve command
        rootCmd.AddCommand(serveCmd)

        // Add bench command
        rootCmd.AddCommand(benchCmd)

        // Command flags
        serveCmd.Flags().StringP("config", "c", "", "config file path")
        serveCmd.Flags().String("address", "0.0.0.0:32010", "server listen address")
        serveCmd.Flags().String("database", ":memory:", "DuckDB database path")
        serveCmd.Flags().String("token", "", "MotherDuck auth token")
        serveCmd.Flags().String("log-level", "info", "log level (debug, info, warn, error)")
        serveCmd.Flags().Bool("tls", false, "enable TLS")
        serveCmd.Flags().String("tls-cert", "", "TLS certificate file")
        serveCmd.Flags().String("tls-key", "", "TLS key file")
        serveCmd.Flags().Bool("auth", false, "enable authentication")
        serveCmd.Flags().Bool("metrics", true, "enable Prometheus metrics")
        serveCmd.Flags().String("metrics-address", ":9090", "metrics server address")
        serveCmd.Flags().Bool("health", true, "enable health checks")
        serveCmd.Flags().Int("max-connections", 100, "maximum concurrent connections")
        serveCmd.Flags().Duration("connection-timeout", 30*time.Second, "connection timeout")
        serveCmd.Flags().Duration("query-timeout", 5*time.Minute, "default query timeout")
        serveCmd.Flags().Int64("max-message-size", 16*1024*1024, "maximum message size in bytes")
        serveCmd.Flags().Bool("reflection", true, "enable gRPC reflection")
        serveCmd.Flags().Duration("shutdown-timeout", 30*time.Second, "graceful shutdown timeout")

        // Benchmark command flags
        benchCmd.Flags().StringP("query", "q", "", "TPC-H query to run (e.g., 'q1' or 'q1,q5,q22')")
        benchCmd.Flags().Bool("all", false, "run all TPC-H queries (q1-q22)")
        benchCmd.Flags().Float64P("scale", "s", 1.0, "TPC-H scale factor (0.01, 0.1, 1, 10, etc.)")
        benchCmd.Flags().StringP("format", "f", "table", "output format: table, json, arrow")
        benchCmd.Flags().StringP("output", "o", "", "output file path (stdout if not specified)")
        benchCmd.Flags().String("database", ":memory:", "DuckDB database path")
        benchCmd.Flags().String("log-level", "info", "log level (debug, info, warn, error)")
        benchCmd.Flags().Int("iterations", 1, "number of iterations per query")
        benchCmd.Flags().Bool("analyze", false, "include query plan analysis")
        benchCmd.Flags().Duration("timeout", 10*time.Minute, "query timeout")

        // Bind flags to viper
        if err := viper.BindPFlags(serveCmd.Flags()); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to bind flags: %w", err))</span>
        }
        <span class="cov0" title="0">viper.SetEnvPrefix("PORTER")
        viper.AutomaticEnv()
        _ = viper.BindEnv("token", "MOTHERDUCK_TOKEN")

        // Add version command
        rootCmd.AddCommand(&amp;cobra.Command{
                Use:   "version",
                Short: "Print version information",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Printf("Porter Flight SQL Server\n")
                        fmt.Printf("Version:    %s\n", version)
                        fmt.Printf("Commit:     %s\n", commit)
                        fmt.Printf("Build Date: %s\n", buildDate)
                }</span>,
        })
}

func main() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}

// EnterpriseFlightSQLServer wraps the base FlightSQLServer with enterprise features.
type EnterpriseFlightSQLServer struct {
        flightsql.BaseServer
        logger    zerolog.Logger
        allocator memory.Allocator
        metrics   metrics.Collector

        authMW    *middleware.AuthMiddleware
        logMW     *middleware.LoggingMiddleware
        metricsMW *middleware.MetricsMiddleware
        recoverMW *middleware.RecoveryMiddleware

        // Core components
        pool        pool.ConnectionPool
        memoryCache cache.Cache
        cacheKeyGen cache.CacheKeyGenerator

        // Handlers
        queryHandler             handlers.QueryHandler
        metadataHandler          handlers.MetadataHandler
        transactionHandler       handlers.TransactionHandler
        preparedStatementHandler handlers.PreparedStatementHandler
}

func runServer(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := loadConfig(cmd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Setup logging
        <span class="cov0" title="0">logger := setupLogging(cfg.LogLevel)
        logger.Info().
                Str("version", version).
                Str("commit", commit).
                Str("build_date", buildDate).
                Msg("Starting Porter Flight SQL Server")

        // Create metrics collector
        var metricsCollector metrics.Collector
        var metricsServer *metrics.MetricsServer
        if cfg.Metrics.Enabled </span><span class="cov0" title="0">{
                metricsCollector = metrics.NewPrometheusCollector()
                metricsServer = metrics.NewMetricsServer(cfg.Metrics.Address)
                go func() </span><span class="cov0" title="0">{
                        logger.Info().Str("address", cfg.Metrics.Address).Msg("Starting metrics server")
                        if err := metricsServer.Start(); err != nil </span><span class="cov0" title="0">{
                                logger.Error().Err(err).Msg("Failed to start metrics server")
                        }</span>
                }()
        } else<span class="cov0" title="0"> {
                metricsCollector = metrics.NewNoOpCollector()
        }</span>

        // Create enterprise server
        <span class="cov0" title="0">srv, err := createEnterpriseServer(cfg, logger, metricsCollector)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create server: %w", err)
        }</span>
        <span class="cov0" title="0">defer srv.Close(context.Background())

        // Setup gRPC server
        grpcServer, err := setupGRPCServer(cfg, srv, logger)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup gRPC server: %w", err)
        }</span>

        // Create listener
        <span class="cov0" title="0">listener, err := net.Listen("tcp", cfg.Address)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create listener: %w", err)
        }</span>

        // Setup graceful shutdown
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        shutdownCh := make(chan os.Signal, 1)
        signal.Notify(shutdownCh, os.Interrupt, syscall.SIGTERM)

        // Start server
        serverErrCh := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                logger.Info().
                        Str("address", cfg.Address).
                        Bool("tls", cfg.TLS.Enabled).
                        Bool("auth", cfg.Auth.Enabled).
                        Msg("Server listening")

                if err := grpcServer.Serve(listener); err != nil </span><span class="cov0" title="0">{
                        serverErrCh &lt;- fmt.Errorf("server error: %w", err)
                }</span>
        }()

        // Wait for shutdown signal or server error
        <span class="cov0" title="0">select </span>{
        case &lt;-shutdownCh:<span class="cov0" title="0">
                logger.Info().Msg("Received shutdown signal")</span>
        case err := &lt;-serverErrCh:<span class="cov0" title="0">
                return err</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                logger.Info().Msg("Context cancelled")</span>
        }

        // Graceful shutdown
        <span class="cov0" title="0">logger.Info().Dur("timeout", cfg.ShutdownTimeout).Msg("Starting graceful shutdown")

        // Stop accepting new connections
        grpcServer.GracefulStop()

        // Close server
        if err := srv.Close(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error().Err(err).Msg("Error during server shutdown")
        }</span>

        // Stop metrics server
        <span class="cov0" title="0">if metricsServer != nil </span><span class="cov0" title="0">{
                if err := metricsServer.Stop(); err != nil </span><span class="cov0" title="0">{
                        logger.Error().Err(err).Msg("Error stopping metrics server")
                }</span>
        }

        <span class="cov0" title="0">logger.Info().Msg("Server shutdown complete")
        return nil</span>
}

func createEnterpriseServer(cfg *config.Config, logger zerolog.Logger, metricsCollector metrics.Collector) (*EnterpriseFlightSQLServer, error) <span class="cov0" title="0">{
        // Create memory allocator
        allocator := memory.NewGoAllocator()

        // Create connection pool configuration
        dsn := infrastructure.NormalizeMotherDuckDSN(cfg.Database)
        dsn = infrastructure.InjectMotherDuckToken(dsn, cfg.Token)
        poolCfg := pool.Config{
                DSN:                dsn,
                MaxOpenConnections: cfg.MaxConnections,
                MaxIdleConnections: cfg.MaxConnections / 2,
                ConnMaxLifetime:    cfg.ConnectionTimeout,
                ConnMaxIdleTime:    cfg.ConnectionTimeout / 2,
                HealthCheckPeriod:  time.Minute,
                ConnectionTimeout:  cfg.ConnectionTimeout,
        }

        // Create connection pool
        connPool, err := pool.New(poolCfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create connection pool: %w", err)
        }</span>

        // Create SQL info provider
        <span class="cov0" title="0">sqlInfoProvider := infrastructure.NewSQLInfoProvider(allocator)

        // Create repositories
        queryRepo := duckdb.NewQueryRepository(connPool, allocator, logger)
        metadataRepo := duckdb.NewMetadataRepository(connPool, sqlInfoProvider, logger)
        transactionRepo := duckdb.NewTransactionRepository(connPool, logger)
        preparedStmtRepo := duckdb.NewPreparedStatementRepository(connPool, allocator, logger)

        // Create services
        transactionService := services.NewTransactionService(
                transactionRepo,
                cfg.QueryTimeout,
                &amp;serviceLoggerAdapter{logger: logger.With().Str("component", "transaction_service").Logger()},
                &amp;serviceMetricsAdapter{collector: metricsCollector},
        )

        queryService := services.NewQueryService(
                queryRepo,
                transactionService,
                &amp;serviceLoggerAdapter{logger: logger.With().Str("component", "query_service").Logger()},
                &amp;serviceMetricsAdapter{collector: metricsCollector},
        )

        metadataService := services.NewMetadataService(
                metadataRepo,
                &amp;serviceLoggerAdapter{logger: logger.With().Str("component", "metadata_service").Logger()},
                &amp;serviceMetricsAdapter{collector: metricsCollector},
        )

        preparedStmtService := services.NewPreparedStatementService(
                preparedStmtRepo,
                transactionService,
                &amp;serviceLoggerAdapter{logger: logger.With().Str("component", "prepared_stmt_service").Logger()},
                &amp;serviceMetricsAdapter{collector: metricsCollector},
        )

        // Create handlers
        queryHandler := handlers.NewQueryHandler(
                queryService,
                allocator,
                &amp;handlerLoggerAdapter{logger: logger.With().Str("component", "query_handler").Logger()},
                &amp;handlerMetricsAdapter{collector: metricsCollector},
        )

        metadataHandler := handlers.NewMetadataHandler(
                metadataService,
                allocator,
                &amp;handlerLoggerAdapter{logger: logger.With().Str("component", "metadata_handler").Logger()},
                &amp;handlerMetricsAdapter{collector: metricsCollector},
        )

        transactionHandler := handlers.NewTransactionHandler(
                transactionService,
                &amp;handlerLoggerAdapter{logger: logger.With().Str("component", "transaction_handler").Logger()},
                &amp;handlerMetricsAdapter{collector: metricsCollector},
        )

        preparedStmtHandler := handlers.NewPreparedStatementHandler(
                preparedStmtService,
                queryService,
                allocator,
                &amp;handlerLoggerAdapter{logger: logger.With().Str("component", "prepared_stmt_handler").Logger()},
                &amp;handlerMetricsAdapter{collector: metricsCollector},
        )

        // Create cache
        memCache := cache.NewMemoryCache(cfg.Cache.MaxSize, allocator)
        cacheKeyGen := &amp;cache.DefaultCacheKeyGenerator{}

        // Middleware
        authMW := middleware.NewAuthMiddleware(cfg.Auth, logger.With().Str("component", "auth_middleware").Logger())
        logMW := middleware.NewLoggingMiddleware(logger.With().Str("component", "logging_middleware").Logger())
        metricsMW := middleware.NewMetricsMiddleware(&amp;middlewareMetricsAdapter{collector: metricsCollector})
        recoverMW := middleware.NewRecoveryMiddleware(logger.With().Str("component", "recovery_middleware").Logger())

        // Create enterprise server
        server := &amp;EnterpriseFlightSQLServer{
                BaseServer: flightsql.BaseServer{
                        Alloc: allocator,
                },
                logger:                   logger,
                allocator:                allocator,
                metrics:                  metricsCollector,
                authMW:                   authMW,
                logMW:                    logMW,
                metricsMW:                metricsMW,
                recoverMW:                recoverMW,
                pool:                     connPool,
                memoryCache:              memCache,
                cacheKeyGen:              cacheKeyGen,
                queryHandler:             queryHandler,
                metadataHandler:          metadataHandler,
                transactionHandler:       transactionHandler,
                preparedStatementHandler: preparedStmtHandler,
        }

        // Register SQL info
        if err := server.registerSqlInfo(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to register SQL info: %w", err)
        }</span>

        <span class="cov0" title="0">return server, nil</span>
}

// Close gracefully shuts down the server.
func (s *EnterpriseFlightSQLServer) Close(ctx context.Context) error <span class="cov0" title="0">{
        // Close cache
        if err := s.memoryCache.Close(); err != nil </span><span class="cov0" title="0">{
                s.logger.Error().Err(err).Msg("Error closing cache")
        }</span>

        // Close connection pool
        <span class="cov0" title="0">if err := s.pool.Close(); err != nil </span><span class="cov0" title="0">{
                s.logger.Error().Err(err).Msg("Error closing connection pool")
        }</span>

        <span class="cov0" title="0">s.logger.Info().Msg("Flight SQL server closed")
        return nil</span>
}

// Register registers the Flight SQL server with a gRPC server.
func (s *EnterpriseFlightSQLServer) Register(grpcServer *grpc.Server) <span class="cov0" title="0">{
        flight.RegisterFlightServiceServer(grpcServer, flightsql.NewFlightServer(s))
}</span>

// GetMiddleware returns enterprise-grade gRPC middleware
func (s *EnterpriseFlightSQLServer) GetMiddleware() []grpc.ServerOption <span class="cov0" title="0">{
        unary := grpc.ChainUnaryInterceptor(
                s.recoverMW.UnaryInterceptor(),
                s.logMW.UnaryInterceptor(),
                s.metricsMW.UnaryInterceptor(),
                s.authMW.UnaryInterceptor(),
        )
        stream := grpc.ChainStreamInterceptor(
                s.recoverMW.StreamInterceptor(),
                s.logMW.StreamInterceptor(),
                s.metricsMW.StreamInterceptor(),
                s.authMW.StreamInterceptor(),
        )
        return []grpc.ServerOption{unary, stream}
}</span>

func loadConfig(cmd *cobra.Command) (*config.Config, error) <span class="cov0" title="0">{
        // Load config file if specified
        if configFile := viper.GetString("config"); configFile != "" </span><span class="cov0" title="0">{
                viper.SetConfigFile(configFile)
                if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read config file: %w", err)
                }</span>
        }

        // Build configuration
        <span class="cov0" title="0">cfg := &amp;config.Config{
                Address:           viper.GetString("address"),
                Database:          viper.GetString("database"),
                Token:             viper.GetString("token"),
                LogLevel:          viper.GetString("log-level"),
                MaxConnections:    viper.GetInt("max-connections"),
                ConnectionTimeout: viper.GetDuration("connection-timeout"),
                QueryTimeout:      viper.GetDuration("query-timeout"),
                MaxMessageSize:    viper.GetInt64("max-message-size"),
                ShutdownTimeout:   viper.GetDuration("shutdown-timeout"),
                TLS: config.TLSConfig{
                        Enabled:  viper.GetBool("tls"),
                        CertFile: viper.GetString("tls-cert"),
                        KeyFile:  viper.GetString("tls-key"),
                },
                Auth: config.AuthConfig{
                        Enabled: viper.GetBool("auth"),
                },
                Metrics: config.MetricsConfig{
                        Enabled: viper.GetBool("metrics"),
                        Address: viper.GetString("metrics-address"),
                },
                Health: config.HealthConfig{
                        Enabled: viper.GetBool("health"),
                },
                Reflection: viper.GetBool("reflection"),
        }

        // Validate configuration
        if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}

func setupLogging(level string) zerolog.Logger <span class="cov0" title="0">{
        // Configure zerolog
        zerolog.TimeFieldFormat = time.RFC3339Nano
        zerolog.DurationFieldUnit = time.Millisecond

        // Set log level
        var logLevel zerolog.Level
        switch level </span>{
        case "debug":<span class="cov0" title="0">
                logLevel = zerolog.DebugLevel
                // Enable caller info for debug level
                zerolog.CallerMarshalFunc = func(pc uintptr, file string, line int) string </span><span class="cov0" title="0">{
                        short := file
                        for i := len(file) - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{
                                if file[i] == '/' </span><span class="cov0" title="0">{
                                        short = file[i+1:]
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">return fmt.Sprintf("%s:%d", short, line)</span>
                }
        case "info":<span class="cov0" title="0">
                logLevel = zerolog.InfoLevel</span>
        case "warn":<span class="cov0" title="0">
                logLevel = zerolog.WarnLevel</span>
        case "error":<span class="cov0" title="0">
                logLevel = zerolog.ErrorLevel</span>
        default:<span class="cov0" title="0">
                logLevel = zerolog.InfoLevel</span>
        }

        // Create logger with caller info for debug level
        <span class="cov0" title="0">logger := zerolog.New(os.Stdout).
                Level(logLevel).
                With().
                Timestamp().
                Str("service", "flight-sql-server")

        if logLevel == zerolog.DebugLevel </span><span class="cov0" title="0">{
                logger = logger.Caller()
        }</span>

        <span class="cov0" title="0">return logger.Logger()</span>
}

func setupGRPCServer(cfg *config.Config, srv *EnterpriseFlightSQLServer, logger zerolog.Logger) (*grpc.Server, error) <span class="cov0" title="0">{
        // Create gRPC options
        opts := []grpc.ServerOption{
                grpc.MaxRecvMsgSize(int(cfg.MaxMessageSize)),
                grpc.MaxSendMsgSize(int(cfg.MaxMessageSize)),
                grpc.MaxConcurrentStreams(uint32(cfg.MaxConnections)),
                grpc.KeepaliveParams(keepalive.ServerParameters{
                        Time:    30 * time.Second,
                        Timeout: 10 * time.Second,
                }),
                grpc.KeepaliveEnforcementPolicy(keepalive.EnforcementPolicy{
                        MinTime:             5 * time.Second,
                        PermitWithoutStream: true,
                }),
        }

        // Add TLS if enabled
        if cfg.TLS.Enabled </span><span class="cov0" title="0">{
                creds, err := credentials.NewServerTLSFromFile(cfg.TLS.CertFile, cfg.TLS.KeyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load TLS credentials: %w", err)
                }</span>
                <span class="cov0" title="0">opts = append(opts, grpc.Creds(creds))</span>
        }

        // Add middleware
        <span class="cov0" title="0">opts = append(opts, srv.GetMiddleware()...)

        // Create gRPC server
        grpcServer := grpc.NewServer(opts...)

        // Register Flight SQL service
        srv.Register(grpcServer)

        // Register health service
        if cfg.Health.Enabled </span><span class="cov0" title="0">{
                healthServer := health.NewServer()
                grpc_health_v1.RegisterHealthServer(grpcServer, healthServer)
                healthServer.SetServingStatus("flight.sql", grpc_health_v1.HealthCheckResponse_SERVING)
        }</span>

        // Register reflection service
        <span class="cov0" title="0">if cfg.Reflection </span><span class="cov0" title="0">{
                reflection.Register(grpcServer)
        }</span>

        <span class="cov0" title="0">return grpcServer, nil</span>
}

// registerSqlInfo registers SQL info with the base server.
func (s *EnterpriseFlightSQLServer) registerSqlInfo() error <span class="cov0" title="0">{
        // Server info
        if err := s.RegisterSqlInfo(flightsql.SqlInfoFlightSqlServerName, "Enterprise Flight SQL Server"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.RegisterSqlInfo(flightsql.SqlInfoFlightSqlServerVersion, "2.0.0"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.RegisterSqlInfo(flightsql.SqlInfoFlightSqlServerArrowVersion, "18.0.0"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // SQL language support
        <span class="cov0" title="0">if err := s.RegisterSqlInfo(flightsql.SqlInfoDDLCatalog, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.RegisterSqlInfo(flightsql.SqlInfoDDLSchema, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.RegisterSqlInfo(flightsql.SqlInfoDDLTable, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.RegisterSqlInfo(flightsql.SqlInfoIdentifierCase, int32(1)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.RegisterSqlInfo(flightsql.SqlInfoQuotedIdentifierCase, int32(1)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Transaction support
        <span class="cov0" title="0">if err := s.RegisterSqlInfo(flightsql.SqlInfoFlightSqlServerTransaction, int32(1)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.RegisterSqlInfo(flightsql.SqlInfoFlightSqlServerCancel, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Handshake implements the Flight authentication handshake.
func (s *EnterpriseFlightSQLServer) Handshake(stream flight.FlightService_HandshakeServer) error <span class="cov0" title="0">{
        req, err := stream.Recv()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">user, err := s.authMW.ValidateHandshakePayload(req.Payload)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn().Err(err).Msg("handshake failed")
                return status.Error(codes.Unauthenticated, "handshake failed")
        }</span>
        <span class="cov0" title="0">token := s.authMW.CreateSessionToken(user)
        s.logger.Info().Str("user", user).Msg("handshake authenticated")
        resp := &amp;flight.HandshakeResponse{Payload: []byte(token)}
        return stream.Send(resp)</span>
}

// FlightSQL interface implementations
func (s *EnterpriseFlightSQLServer) GetFlightInfoStatement(ctx context.Context, cmd flightsql.StatementQuery, desc *flight.FlightDescriptor) (*flight.FlightInfo, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("flight_get_info_statement")
        defer timer.Stop()

        key := s.cacheKeyGen.GenerateKey(cmd.GetQuery(), nil)
        if rec, _ := s.memoryCache.Get(ctx, key); rec != nil </span><span class="cov0" title="0">{
                return s.infoFromSchema(cmd.GetQuery(), rec.Schema()), nil
        }</span>

        <span class="cov0" title="0">return s.queryHandler.GetFlightInfo(ctx, cmd.GetQuery())</span>
}

func (s *EnterpriseFlightSQLServer) BeginTransaction(ctx context.Context, req flightsql.ActionBeginTransactionRequest) ([]byte, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("flight_begin_transaction")
        defer timer.Stop()

        // Extract options from request
        opts := models.TransactionOptions{
                ReadOnly: false, // Default to read-write
        }

        // Begin transaction
        txnID, err := s.transactionHandler.Begin(ctx, opts.ReadOnly)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error().Err(err).Msg("Failed to begin transaction")
                return nil, status.Errorf(codes.Internal, "begin transaction: %v", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info().Str("transaction_id", txnID).Msg("Transaction started")
        return []byte(txnID), nil</span>
}

func (s *EnterpriseFlightSQLServer) DoGetStatement(ctx context.Context, ticket flightsql.StatementQueryTicket) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("flight_do_get_statement")
        defer timer.Stop()

        return s.queryHandler.ExecuteStatement(ctx, string(ticket.GetStatementHandle()), "")
}</span>

func (s *EnterpriseFlightSQLServer) DoPutCommandStatementUpdate(ctx context.Context, cmd flightsql.StatementUpdate) (int64, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("flight_do_put_command_statement_update")
        defer timer.Stop()

        return s.queryHandler.ExecuteUpdate(ctx, cmd.GetQuery(), string(cmd.GetTransactionId()))
}</span>

// Prepared statement methods
func (s *EnterpriseFlightSQLServer) CreatePreparedStatement(ctx context.Context, req flightsql.ActionCreatePreparedStatementRequest) (flightsql.ActionCreatePreparedStatementResult, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("flight_create_prepared_statement")
        defer timer.Stop()

        handle, schema, err := s.preparedStatementHandler.Create(ctx, req.GetQuery(), string(req.GetTransactionId()))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error().Err(err).Str("query", req.GetQuery()).Msg("Failed to create prepared statement")
                return flightsql.ActionCreatePreparedStatementResult{}, err
        }</span>

        <span class="cov0" title="0">s.logger.Info().Str("handle", handle).Str("query", req.GetQuery()).Msg("Prepared statement created")
        return flightsql.ActionCreatePreparedStatementResult{
                Handle:        []byte(handle),
                DatasetSchema: schema,
        }, nil</span>
}

func (s *EnterpriseFlightSQLServer) ClosePreparedStatement(ctx context.Context, req flightsql.ActionClosePreparedStatementRequest) error <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("flight_close_prepared_statement")
        defer timer.Stop()

        handle := string(req.GetPreparedStatementHandle())
        if err := s.preparedStatementHandler.Close(ctx, handle); err != nil </span><span class="cov0" title="0">{
                s.logger.Error().Err(err).Str("handle", handle).Msg("Failed to close prepared statement")
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info().Str("handle", handle).Msg("Prepared statement closed")
        return nil</span>
}

func (s *EnterpriseFlightSQLServer) GetFlightInfoPreparedStatement(ctx context.Context, cmd flightsql.PreparedStatementQuery, desc *flight.FlightDescriptor) (*flight.FlightInfo, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("flight_get_info_prepared_statement")
        defer timer.Stop()

        handle := string(cmd.GetPreparedStatementHandle())
        schema, err := s.preparedStatementHandler.GetSchema(ctx, handle)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error().Err(err).Str("handle", handle).Msg("Failed to get prepared statement schema")
                return nil, err
        }</span>

        // Create FlightInfo with a special prepared statement ticket prefix
        // This allows the DoGet method to distinguish prepared statement tickets
        <span class="cov0" title="0">ticketData := append([]byte("PREPARED:"), cmd.GetPreparedStatementHandle()...)

        return &amp;flight.FlightInfo{
                Schema:           flight.SerializeSchema(schema, s.allocator),
                FlightDescriptor: desc,
                Endpoint: []*flight.FlightEndpoint{{
                        Ticket: &amp;flight.Ticket{Ticket: ticketData},
                }},
                TotalRecords: -1,
                TotalBytes:   -1,
        }, nil</span>
}

func (s *EnterpriseFlightSQLServer) DoGetPreparedStatement(ctx context.Context, cmd flightsql.PreparedStatementQuery) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("flight_do_get_prepared_statement")
        defer timer.Stop()

        handle := string(cmd.GetPreparedStatementHandle())
        return s.preparedStatementHandler.ExecuteQuery(ctx, handle, nil)
}</span>

func (s *EnterpriseFlightSQLServer) DoPutPreparedStatementQuery(ctx context.Context, cmd flightsql.PreparedStatementQuery, reader flight.MessageReader, writer flight.MetadataWriter) ([]byte, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("flight_do_put_prepared_statement_query")
        defer timer.Stop()

        handle := string(cmd.GetPreparedStatementHandle())

        // Read parameters from the message reader
        var params arrow.Record
        for </span><span class="cov0" title="0">{
                rec, err := reader.Read()
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov0" title="0">if rec != nil </span><span class="cov0" title="0">{
                        params = rec
                        break</span> // Use the first record as parameters
                }
        }

        // Set parameters if provided
        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{
                if err := s.preparedStatementHandler.SetParameters(ctx, handle, params); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error().Err(err).Str("handle", handle).Msg("Failed to set prepared statement parameters")
                        params.Release()
                        return nil, err
                }</span>
                <span class="cov0" title="0">params.Release()</span>
        }

        <span class="cov0" title="0">return []byte(handle), nil</span>
}

func (s *EnterpriseFlightSQLServer) DoPutPreparedStatementUpdate(ctx context.Context, cmd flightsql.PreparedStatementUpdate, reader flight.MessageReader) (int64, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("flight_do_put_prepared_statement_update")
        defer timer.Stop()

        handle := string(cmd.GetPreparedStatementHandle())

        // Read parameters from the message reader
        var params arrow.Record
        for </span><span class="cov0" title="0">{
                rec, err := reader.Read()
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return 0, err</span>
                }
                <span class="cov0" title="0">if rec != nil </span><span class="cov0" title="0">{
                        params = rec
                        break</span> // Use the first record as parameters
                }
        }

        // Execute update with parameters
        <span class="cov0" title="0">affected, err := s.preparedStatementHandler.ExecuteUpdate(ctx, handle, params)
        if params != nil </span><span class="cov0" title="0">{
                params.Release()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error().Err(err).Str("handle", handle).Msg("Failed to execute prepared statement update")
                return 0, err
        }</span>

        <span class="cov0" title="0">s.logger.Info().Str("handle", handle).Int64("affected_rows", affected).Msg("Prepared statement update executed")
        return affected, nil</span>
}

// DoGet handles all DoGet requests with proper ticket routing
func (s *EnterpriseFlightSQLServer) DoGet(ctx context.Context, ticket *flight.Ticket) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("flight_do_get")
        defer timer.Stop()

        ticketData := string(ticket.Ticket)

        // Handle prepared statement tickets with "PREPARED:" prefix
        if strings.HasPrefix(ticketData, "PREPARED:") </span><span class="cov0" title="0">{
                handle := strings.TrimPrefix(ticketData, "PREPARED:")
                s.logger.Debug().Str("handle", handle).Msg("Executing prepared statement via DoGet")
                return s.preparedStatementHandler.ExecuteQuery(ctx, handle, nil)
        }</span>

        // Handle metadata tickets
        <span class="cov0" title="0">switch ticketData </span>{
        case "CATALOGS":<span class="cov0" title="0">
                s.logger.Debug().Msg("Executing catalog discovery via DoGet")
                return s.metadataHandler.GetCatalogs(ctx)</span>
        }

        // For regular query tickets, try to parse as query and execute
        // This handles standard Flight SQL query tickets
        <span class="cov0" title="0">if len(ticketData) &gt; 0 </span><span class="cov0" title="0">{
                s.logger.Debug().Str("ticket", ticketData).Msg("Executing query from ticket")
                return s.queryHandler.ExecuteStatement(ctx, ticketData, "")
        }</span>

        <span class="cov0" title="0">return nil, nil, status.Errorf(codes.InvalidArgument, "invalid ticket format")</span>
}

// Metadata discovery methods
// Note: GetFlightInfoCatalogs and DoGetCatalogs are handled by the base server
// We don't need to override them here as the base server already has proper implementations

// Helper methods
func (s *EnterpriseFlightSQLServer) infoFromSchema(query string, schema *arrow.Schema) *flight.FlightInfo <span class="cov0" title="0">{
        desc := &amp;flight.FlightDescriptor{
                Type: flight.DescriptorCMD,
                Cmd:  []byte(query),
        }
        return &amp;flight.FlightInfo{
                Schema:           flight.SerializeSchema(schema, s.allocator),
                FlightDescriptor: desc,
                Endpoint: []*flight.FlightEndpoint{{
                        Ticket: &amp;flight.Ticket{Ticket: desc.Cmd},
                }},
                TotalRecords: -1,
                TotalBytes:   -1,
        }
}</span>

// Adapter implementations for different interface requirements

// serviceLoggerAdapter adapts zerolog.Logger to services.Logger
type serviceLoggerAdapter struct {
        logger zerolog.Logger
}

func (l *serviceLoggerAdapter) Debug(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        event := l.logger.Debug()
        for i := 0; i &lt; len(keysAndValues); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(keysAndValues) </span><span class="cov0" title="0">{
                        key := fmt.Sprintf("%v", keysAndValues[i])
                        value := keysAndValues[i+1]
                        event = event.Interface(key, value)
                }</span>
        }
        <span class="cov0" title="0">event.Msg(msg)</span>
}

func (l *serviceLoggerAdapter) Info(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        event := l.logger.Info()
        for i := 0; i &lt; len(keysAndValues); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(keysAndValues) </span><span class="cov0" title="0">{
                        key := fmt.Sprintf("%v", keysAndValues[i])
                        value := keysAndValues[i+1]
                        event = event.Interface(key, value)
                }</span>
        }
        <span class="cov0" title="0">event.Msg(msg)</span>
}

func (l *serviceLoggerAdapter) Warn(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        event := l.logger.Warn()
        for i := 0; i &lt; len(keysAndValues); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(keysAndValues) </span><span class="cov0" title="0">{
                        key := fmt.Sprintf("%v", keysAndValues[i])
                        value := keysAndValues[i+1]
                        event = event.Interface(key, value)
                }</span>
        }
        <span class="cov0" title="0">event.Msg(msg)</span>
}

func (l *serviceLoggerAdapter) Error(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        event := l.logger.Error()
        for i := 0; i &lt; len(keysAndValues); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(keysAndValues) </span><span class="cov0" title="0">{
                        key := fmt.Sprintf("%v", keysAndValues[i])
                        value := keysAndValues[i+1]
                        event = event.Interface(key, value)
                }</span>
        }
        <span class="cov0" title="0">event.Msg(msg)</span>
}

// serviceMetricsAdapter adapts metrics.Collector to services.MetricsCollector
type serviceMetricsAdapter struct {
        collector metrics.Collector
}

func (m *serviceMetricsAdapter) IncrementCounter(name string, labels ...string) <span class="cov0" title="0">{
        m.collector.IncrementCounter(name, labels...)
}</span>

func (m *serviceMetricsAdapter) RecordHistogram(name string, value float64, labels ...string) <span class="cov0" title="0">{
        m.collector.RecordHistogram(name, value, labels...)
}</span>

func (m *serviceMetricsAdapter) RecordGauge(name string, value float64, labels ...string) <span class="cov0" title="0">{
        m.collector.RecordGauge(name, value, labels...)
}</span>

func (m *serviceMetricsAdapter) StartTimer(name string) services.Timer <span class="cov0" title="0">{
        return &amp;serviceTimerAdapter{timer: m.collector.StartTimer(name)}
}</span>

// serviceTimerAdapter adapts metrics.Timer to services.Timer
type serviceTimerAdapter struct {
        timer metrics.Timer
}

func (t *serviceTimerAdapter) Stop() time.Duration <span class="cov0" title="0">{
        seconds := t.timer.Stop()
        return time.Duration(seconds * float64(time.Second))
}</span>

// handlerLoggerAdapter adapts zerolog.Logger to handlers.Logger
type handlerLoggerAdapter struct {
        logger zerolog.Logger
}

func (l *handlerLoggerAdapter) Debug(msg string, fields ...interface{}) <span class="cov0" title="0">{
        event := l.logger.Debug()
        for i := 0; i &lt; len(fields); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(fields) </span><span class="cov0" title="0">{
                        key := fmt.Sprintf("%v", fields[i])
                        value := fields[i+1]
                        event = event.Interface(key, value)
                }</span>
        }
        <span class="cov0" title="0">event.Msg(msg)</span>
}

func (l *handlerLoggerAdapter) Info(msg string, fields ...interface{}) <span class="cov0" title="0">{
        event := l.logger.Info()
        for i := 0; i &lt; len(fields); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(fields) </span><span class="cov0" title="0">{
                        key := fmt.Sprintf("%v", fields[i])
                        value := fields[i+1]
                        event = event.Interface(key, value)
                }</span>
        }
        <span class="cov0" title="0">event.Msg(msg)</span>
}

func (l *handlerLoggerAdapter) Warn(msg string, fields ...interface{}) <span class="cov0" title="0">{
        event := l.logger.Warn()
        for i := 0; i &lt; len(fields); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(fields) </span><span class="cov0" title="0">{
                        key := fmt.Sprintf("%v", fields[i])
                        value := fields[i+1]
                        event = event.Interface(key, value)
                }</span>
        }
        <span class="cov0" title="0">event.Msg(msg)</span>
}

func (l *handlerLoggerAdapter) Error(msg string, fields ...interface{}) <span class="cov0" title="0">{
        event := l.logger.Error()
        for i := 0; i &lt; len(fields); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(fields) </span><span class="cov0" title="0">{
                        key := fmt.Sprintf("%v", fields[i])
                        value := fields[i+1]
                        event = event.Interface(key, value)
                }</span>
        }
        <span class="cov0" title="0">event.Msg(msg)</span>
}

// handlerMetricsAdapter adapts metrics.Collector to handlers.MetricsCollector
type handlerMetricsAdapter struct {
        collector metrics.Collector
}

func (m *handlerMetricsAdapter) IncrementCounter(name string, labels ...string) <span class="cov0" title="0">{
        m.collector.IncrementCounter(name, labels...)
}</span>

func (m *handlerMetricsAdapter) RecordHistogram(name string, value float64, labels ...string) <span class="cov0" title="0">{
        m.collector.RecordHistogram(name, value, labels...)
}</span>

func (m *handlerMetricsAdapter) RecordGauge(name string, value float64, labels ...string) <span class="cov0" title="0">{
        m.collector.RecordGauge(name, value, labels...)
}</span>

func (m *handlerMetricsAdapter) StartTimer(name string) handlers.Timer <span class="cov0" title="0">{
        return &amp;handlerTimerAdapter{timer: m.collector.StartTimer(name)}
}</span>

// handlerTimerAdapter adapts metrics.Timer to handlers.Timer
type handlerTimerAdapter struct {
        timer metrics.Timer
}

func (t *handlerTimerAdapter) Stop() <span class="cov0" title="0">{
        t.timer.Stop()
}</span>

// middlewareMetricsAdapter adapts metrics.Collector to middleware.MetricsCollector
type middlewareMetricsAdapter struct {
        collector metrics.Collector
}

func (m *middlewareMetricsAdapter) IncrementCounter(name string, labels ...string) <span class="cov0" title="0">{
        m.collector.IncrementCounter(name, labels...)
}</span>

func (m *middlewareMetricsAdapter) RecordHistogram(name string, value float64, labels ...string) <span class="cov0" title="0">{
        m.collector.RecordHistogram(name, value, labels...)
}</span>

func (m *middlewareMetricsAdapter) RecordGauge(name string, value float64, labels ...string) <span class="cov0" title="0">{
        m.collector.RecordGauge(name, value, labels...)
}</span>

func (m *middlewareMetricsAdapter) StartTimer(name string) middleware.Timer <span class="cov0" title="0">{
        return &amp;middlewareTimerAdapter{timer: m.collector.StartTimer(name)}
}</span>

// middlewareTimerAdapter adapts metrics.Timer to middleware.Timer
type middlewareTimerAdapter struct {
        timer metrics.Timer
}

func (t *middlewareTimerAdapter) Stop() float64 <span class="cov0" title="0">{
        return t.timer.Stop()
}</span>

func runBenchmark(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Parse command flags
        queryFlag, _ := cmd.Flags().GetString("query")
        allQueries, _ := cmd.Flags().GetBool("all")
        scaleFactor, _ := cmd.Flags().GetFloat64("scale")
        format, _ := cmd.Flags().GetString("format")
        output, _ := cmd.Flags().GetString("output")
        database, _ := cmd.Flags().GetString("database")
        logLevel, _ := cmd.Flags().GetString("log-level")
        iterations, _ := cmd.Flags().GetInt("iterations")
        analyze, _ := cmd.Flags().GetBool("analyze")
        timeout, _ := cmd.Flags().GetDuration("timeout")

        // Setup logging
        logger := setupLogging(logLevel)

        // Determine which queries to run
        var queries []string
        var err error

        if allQueries </span><span class="cov0" title="0">{
                queries = benchmark.GetAllQueries()
        }</span> else<span class="cov0" title="0"> if queryFlag != "" </span><span class="cov0" title="0">{
                queries, err = benchmark.ParseQueries(queryFlag)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid queries: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("must specify either --query or --all")
        }</span>

        // Create benchmark configuration
        <span class="cov0" title="0">config := benchmark.BenchmarkConfig{
                Queries:     queries,
                ScaleFactor: scaleFactor,
                Iterations:  iterations,
                Timeout:     timeout,
                Analyze:     analyze,
                Database:    database,
        }

        // Create benchmark runner
        runner, err := benchmark.NewRunner(database, logger)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create benchmark runner: %w", err)
        }</span>
        <span class="cov0" title="0">defer runner.Close()

        // Run benchmark
        ctx := context.Background()
        result, err := runner.Run(ctx, config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("benchmark failed: %w", err)
        }</span>

        // Determine output destination
        <span class="cov0" title="0">var writer io.Writer = os.Stdout
        if output != "" </span><span class="cov0" title="0">{
                file, err := os.Create(output)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create output file: %w", err)
                }</span>
                <span class="cov0" title="0">defer file.Close()
                writer = file</span>
        }

        // Output results
        <span class="cov0" title="0">if err := benchmark.OutputResult(result, format, writer); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to output results: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info().
                Int("queries", len(result.Results)).
                Dur("total_time", result.TotalTime).
                Msg("Benchmark completed successfully")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package middleware provides gRPC middleware for the Flight SQL server.
package middleware

import (
        "context"
        "crypto/rand"
        "crypto/subtle"
        "encoding/base64"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "strings"
        "sync"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/rs/zerolog"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"

        "github.com/TFMV/porter/cmd/server/config"
)

// OAuth2Token represents an OAuth2 token with additional metadata
type OAuth2Token struct {
        AccessToken  string    `json:"access_token"`
        TokenType    string    `json:"token_type"`
        RefreshToken string    `json:"refresh_token,omitempty"`
        ExpiresAt    time.Time `json:"expires_at"`
        Scope        string    `json:"scope,omitempty"`
        UserID       string    `json:"user_id,omitempty"`
}

// TokenStore manages OAuth2 tokens
type TokenStore struct {
        mu                sync.RWMutex
        accessTokens      map[string]*OAuth2Token
        refreshTokens     map[string]*OAuth2Token
        authorizationCode map[string]authorizationCode
}

type authorizationCode struct {
        code        string
        clientID    string
        redirectURI string
        scope       string
        expiresAt   time.Time
        userID      string
}

// AuthMiddleware provides authentication middleware.
type AuthMiddleware struct {
        config        config.AuthConfig
        logger        zerolog.Logger
        HSKey         []byte
        RSKey         interface{}
        Iss           string
        Aud           string
        tokenStore    *TokenStore
        sessionTokens map[string]string
        mu            sync.RWMutex
}

// NewAuthMiddleware creates a new authentication middleware.
func NewAuthMiddleware(cfg config.AuthConfig, logger zerolog.Logger) *AuthMiddleware <span class="cov10" title="15">{
        m := &amp;AuthMiddleware{
                config: cfg,
                logger: logger,
                tokenStore: &amp;TokenStore{
                        accessTokens:      make(map[string]*OAuth2Token),
                        refreshTokens:     make(map[string]*OAuth2Token),
                        authorizationCode: make(map[string]authorizationCode),
                },
                sessionTokens: make(map[string]string),
        }

        // Initialize JWT-related fields if JWT auth is enabled
        if cfg.Type == "jwt" </span><span class="cov3" title="2">{
                if cfg.JWTAuth.Secret != "" </span><span class="cov3" title="2">{
                        m.HSKey = []byte(cfg.JWTAuth.Secret)
                }</span>
                <span class="cov3" title="2">m.Iss = cfg.JWTAuth.Issuer
                m.Aud = cfg.JWTAuth.Audience</span>
        }

        <span class="cov10" title="15">return m</span>
}

// UnaryInterceptor returns a unary server interceptor for authentication.
func (m *AuthMiddleware) UnaryInterceptor() grpc.UnaryServerInterceptor <span class="cov3" title="2">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov3" title="2">{
                // Skip auth for health checks
                if strings.Contains(info.FullMethod, "grpc.health") </span><span class="cov1" title="1">{
                        return handler(ctx, req)
                }</span>

                <span class="cov1" title="1">authCtx, err := m.authenticate(ctx)
                if err != nil </span><span class="cov1" title="1">{
                        m.logger.Warn().Err(err).Str("method", info.FullMethod).Msg("Authentication failed")
                        return nil, err
                }</span>

                <span class="cov0" title="0">return handler(authCtx, req)</span>
        }
}

// StreamInterceptor returns a stream server interceptor for authentication.
func (m *AuthMiddleware) StreamInterceptor() grpc.StreamServerInterceptor <span class="cov3" title="2">{
        return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov3" title="2">{
                // Skip auth for health checks
                if strings.Contains(info.FullMethod, "grpc.health") </span><span class="cov1" title="1">{
                        return handler(srv, ss)
                }</span>

                <span class="cov1" title="1">authCtx, err := m.authenticate(ss.Context())
                if err != nil </span><span class="cov1" title="1">{
                        m.logger.Warn().Err(err).Str("method", info.FullMethod).Msg("Authentication failed")
                        return err
                }</span>

                // Wrap the stream with authenticated context
                <span class="cov0" title="0">wrappedStream := &amp;authServerStream{
                        ServerStream: ss,
                        ctx:          authCtx,
                }

                return handler(srv, wrappedStream)</span>
        }
}

// authenticate performs authentication based on configured type.
func (m *AuthMiddleware) authenticate(ctx context.Context) (context.Context, error) <span class="cov3" title="2">{
        if !m.config.Enabled </span><span class="cov0" title="0">{
                return ctx, nil
        }</span>

        <span class="cov3" title="2">switch m.config.Type </span>{
        case "basic":<span class="cov3" title="2">
                return m.authenticateBasic(ctx)</span>
        case "bearer":<span class="cov0" title="0">
                return m.authenticateBearer(ctx)</span>
        case "jwt":<span class="cov0" title="0">
                return m.authenticateJWT(ctx)</span>
        case "oauth2":<span class="cov0" title="0">
                return m.authenticateOAuth2(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, status.Errorf(codes.Internal, "unsupported auth type: %s", m.config.Type)</span>
        }
}

// authenticateBasic performs basic authentication.
func (m *AuthMiddleware) authenticateBasic(ctx context.Context) (context.Context, error) <span class="cov7" title="7">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov4" title="3">{
                return nil, status.Error(codes.Unauthenticated, "missing metadata")
        }</span>

        <span class="cov5" title="4">authHeaders := md.Get("authorization")
        if len(authHeaders) == 0 </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Unauthenticated, "missing authorization header")
        }</span>

        <span class="cov4" title="3">authHeader := authHeaders[0]
        if !strings.HasPrefix(authHeader, "Basic ") </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Unauthenticated, "invalid authorization header")
        }</span>

        // Decode credentials
        <span class="cov3" title="2">encoded := strings.TrimPrefix(authHeader, "Basic ")
        decoded, err := base64.StdEncoding.DecodeString(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unauthenticated, "invalid credentials encoding")
        }</span>

        <span class="cov3" title="2">parts := strings.SplitN(string(decoded), ":", 2)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unauthenticated, "invalid credentials format")
        }</span>

        <span class="cov3" title="2">username := parts[0]
        password := parts[1]

        // Validate credentials
        userInfo, ok := m.config.BasicAuth.Users[username]
        if !ok </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unauthenticated, "invalid credentials")
        }</span>

        // Constant time comparison to prevent timing attacks
        <span class="cov3" title="2">if subtle.ConstantTimeCompare([]byte(password), []byte(userInfo.Password)) != 1 </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Unauthenticated, "invalid credentials")
        }</span>

        // Add user info to context
        <span class="cov1" title="1">ctx = context.WithValue(ctx, contextKeyUser, username)
        ctx = context.WithValue(ctx, contextKeyRoles, userInfo.Roles)

        return ctx, nil</span>
}

// authenticateBearer performs bearer token authentication.
func (m *AuthMiddleware) authenticateBearer(ctx context.Context) (context.Context, error) <span class="cov5" title="4">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Unauthenticated, "missing metadata")
        }</span>

        <span class="cov4" title="3">authHeaders := md.Get("authorization")
        if len(authHeaders) == 0 </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Unauthenticated, "missing authorization header")
        }</span>

        <span class="cov3" title="2">authHeader := authHeaders[0]
        if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unauthenticated, "invalid authorization header")
        }</span>

        <span class="cov3" title="2">token := strings.TrimPrefix(authHeader, "Bearer ")

        // Validate token against configured tokens or session tokens
        username, ok := m.config.BearerAuth.Tokens[token]
        if !ok </span><span class="cov1" title="1">{
                m.mu.RLock()
                username, ok = m.sessionTokens[token]
                m.mu.RUnlock()
                if !ok </span><span class="cov1" title="1">{
                        return nil, status.Error(codes.Unauthenticated, "invalid token")
                }</span>
        }

        // Add user info to context
        <span class="cov1" title="1">ctx = context.WithValue(ctx, contextKeyUser, username)

        return ctx, nil</span>
}

// authenticateJWT performs JWT authentication.
func (m *AuthMiddleware) authenticateJWT(ctx context.Context) (context.Context, error) <span class="cov8" title="9">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov1" title="1">{
                return ctx, status.Error(codes.Unauthenticated, "missing metadata")
        }</span>

        <span class="cov7" title="8">authHeaders := md.Get("authorization")
        if len(authHeaders) == 0 </span><span class="cov1" title="1">{
                return ctx, status.Error(codes.Unauthenticated, "no authorization header")
        }</span>

        // We only inspect the first header; multiple are unusual for gRPC.
        <span class="cov7" title="7">raw := strings.TrimSpace(authHeaders[0])
        const bearer = "bearer "
        if len(raw) &lt; len(bearer) || !strings.EqualFold(raw[:len(bearer)], bearer) </span><span class="cov0" title="0">{
                return ctx, status.Error(codes.Unauthenticated, "authorization header is not Bearer")
        }</span>
        <span class="cov7" title="7">tokenString := strings.TrimSpace(raw[len(bearer):])
        if tokenString == "" </span><span class="cov0" title="0">{
                return ctx, status.Error(codes.Unauthenticated, "empty bearer token")
        }</span>

        // Custom key‚Äëfunc that selects the proper key based on signing method.
        <span class="cov7" title="7">keyFunc := func(t *jwt.Token) (any, error) </span><span class="cov6" title="6">{
                switch t.Method.(type) </span>{
                case *jwt.SigningMethodHMAC:<span class="cov5" title="4">
                        if len(m.HSKey) == 0 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected HMAC token")
                        }</span>
                        <span class="cov5" title="4">return m.HSKey, nil</span>
                case *jwt.SigningMethodRSA, *jwt.SigningMethodECDSA:<span class="cov3" title="2">
                        if m.RSKey == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected asymmetric‚Äëkey token")
                        }</span>
                        <span class="cov3" title="2">return m.RSKey, nil</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("unsupported signing algorithm %s", t.Method.Alg())</span>
                }
        }

        <span class="cov7" title="7">claims := jwt.MapClaims{}
        token, err := jwt.ParseWithClaims(tokenString, claims, keyFunc,
                jwt.WithValidMethods([]string{
                        jwt.SigningMethodHS256.Alg(),
                        jwt.SigningMethodHS384.Alg(),
                        jwt.SigningMethodHS512.Alg(),
                        jwt.SigningMethodRS256.Alg(),
                        jwt.SigningMethodRS384.Alg(),
                        jwt.SigningMethodRS512.Alg(),
                        jwt.SigningMethodES256.Alg(),
                        jwt.SigningMethodES384.Alg(),
                        jwt.SigningMethodES512.Alg(),
                }))
        if err != nil || !token.Valid </span><span class="cov3" title="2">{
                return ctx, status.Error(codes.Unauthenticated, "invalid JWT: "+err.Error())
        }</span>

        // ---- additional claim checks ------------------------------------------------
        <span class="cov6" title="5">if iss := m.Iss; iss != "" </span><span class="cov6" title="5">{
                if iclaim, _ := claims["iss"].(string); iclaim != iss </span><span class="cov1" title="1">{
                        return ctx, status.Error(codes.Unauthenticated, "issuer mismatch")
                }</span>
        }
        <span class="cov5" title="4">if aud := m.Aud; aud != "" </span><span class="cov5" title="4">{
                switch v := claims["aud"].(type) </span>{
                case string:<span class="cov5" title="4">
                        if v != aud </span><span class="cov1" title="1">{
                                return ctx, status.Error(codes.Unauthenticated, "audience mismatch")
                        }</span>
                case []any:<span class="cov0" title="0">
                        found := false
                        for _, a := range v </span><span class="cov0" title="0">{
                                if s, ok := a.(string); ok &amp;&amp; s == aud </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                return ctx, status.Error(codes.Unauthenticated, "audience mismatch")
                        }</span>
                }
        }
        // Expiry is validated automatically by jwt.ParseWithClaims, but we ensure
        // the claim exists so Missing exp causes rejection.
        <span class="cov4" title="3">if _, ok := claims["exp"]; !ok </span><span class="cov0" title="0">{
                return ctx, status.Error(codes.Unauthenticated, "missing exp claim")
        }</span>
        <span class="cov4" title="3">exp, ok := claims["exp"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return ctx, status.Error(codes.Unauthenticated, "invalid exp claim type")
        }</span>
        <span class="cov4" title="3">if time.Unix(int64(exp), 0).Before(time.Now()) </span><span class="cov0" title="0">{
                return ctx, status.Error(codes.Unauthenticated, "token expired")
        }</span>

        // Subject becomes the logical user identity.
        <span class="cov4" title="3">sub, _ := claims["sub"].(string)
        return context.WithValue(ctx, ctxUserKey{}, sub), nil</span>
}

// authenticateOAuth2 performs OAuth2 authentication
func (m *AuthMiddleware) authenticateOAuth2(ctx context.Context) (context.Context, error) <span class="cov0" title="0">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unauthenticated, "missing metadata")
        }</span>

        <span class="cov0" title="0">authHeaders := md.Get("authorization")
        if len(authHeaders) == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unauthenticated, "missing authorization header")
        }</span>

        <span class="cov0" title="0">authHeader := authHeaders[0]
        if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unauthenticated, "invalid authorization header")
        }</span>

        <span class="cov0" title="0">token := strings.TrimPrefix(authHeader, "Bearer ")

        // Validate access token
        m.tokenStore.mu.RLock()
        tokenInfo, exists := m.tokenStore.accessTokens[token]
        m.tokenStore.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unauthenticated, "invalid token")
        }</span>

        <span class="cov0" title="0">if time.Now().After(tokenInfo.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unauthenticated, "token expired")
        }</span>

        // Add user info to context
        <span class="cov0" title="0">ctx = context.WithValue(ctx, contextKeyUser, tokenInfo.UserID)
        return ctx, nil</span>
}

// HandleOAuth2Authorize handles the OAuth2 authorization endpoint
func (m *AuthMiddleware) HandleOAuth2Authorize(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">clientID := r.URL.Query().Get("client_id")
        redirectURI := r.URL.Query().Get("redirect_uri")
        scope := r.URL.Query().Get("scope")
        responseType := r.URL.Query().Get("response_type")

        if clientID != m.config.OAuth2Auth.ClientID </span><span class="cov0" title="0">{
                http.Error(w, "Invalid client ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if responseType != "code" </span><span class="cov0" title="0">{
                http.Error(w, "Unsupported response type", http.StatusBadRequest)
                return
        }</span>

        // Validate redirect URI against allowed list
        <span class="cov0" title="0">if err := m.validateRedirectURI(redirectURI); err != nil </span><span class="cov0" title="0">{
                m.logger.Warn().Err(err).Str("redirect_uri", redirectURI).Msg("Invalid redirect URI")
                http.Error(w, "Invalid redirect URI", http.StatusBadRequest)
                return
        }</span>

        // Generate authorization code
        <span class="cov0" title="0">code := generateRandomString(32)
        expiresAt := time.Now().Add(10 * time.Minute)

        authCode := authorizationCode{
                code:        code,
                clientID:    clientID,
                redirectURI: redirectURI,
                scope:       scope,
                expiresAt:   expiresAt,
                userID:      "user123", // In a real implementation, this would come from user authentication
        }

        m.tokenStore.mu.Lock()
        m.tokenStore.authorizationCode[code] = authCode
        m.tokenStore.mu.Unlock()

        // Redirect back to client with authorization code
        redirectURL := fmt.Sprintf("%s?code=%s", redirectURI, code)
        http.Redirect(w, r, redirectURL, http.StatusFound)</span>
}

// HandleOAuth2Token handles the OAuth2 token endpoint
func (m *AuthMiddleware) HandleOAuth2Token(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">grantType := r.FormValue("grant_type")

        switch grantType </span>{
        case "authorization_code":<span class="cov0" title="0">
                m.handleAuthorizationCodeGrant(w, r)</span>
        case "refresh_token":<span class="cov0" title="0">
                m.handleRefreshTokenGrant(w, r)</span>
        case "client_credentials":<span class="cov0" title="0">
                m.handleClientCredentialsGrant(w, r)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Unsupported grant type", http.StatusBadRequest)</span>
        }
}

func (m *AuthMiddleware) handleAuthorizationCodeGrant(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        code := r.FormValue("code")
        clientID := r.FormValue("client_id")
        clientSecret := r.FormValue("client_secret")
        redirectURI := r.FormValue("redirect_uri")

        // Validate client credentials
        if clientID != m.config.OAuth2Auth.ClientID || clientSecret != m.config.OAuth2Auth.ClientSecret </span><span class="cov0" title="0">{
                http.Error(w, "Invalid client credentials", http.StatusUnauthorized)
                return
        }</span>

        // Validate authorization code
        <span class="cov0" title="0">m.tokenStore.mu.Lock()
        authCode, exists := m.tokenStore.authorizationCode[code]
        delete(m.tokenStore.authorizationCode, code) // Remove used code
        m.tokenStore.mu.Unlock()

        if !exists || time.Now().After(authCode.expiresAt) || authCode.redirectURI != redirectURI </span><span class="cov0" title="0">{
                http.Error(w, "Invalid authorization code", http.StatusBadRequest)
                return
        }</span>

        // Generate tokens
        <span class="cov0" title="0">token := m.generateOAuth2Token(authCode.userID, authCode.scope)
        m.tokenStore.mu.Lock()
        m.tokenStore.accessTokens[token.AccessToken] = token
        if token.RefreshToken != "" </span><span class="cov0" title="0">{
                m.tokenStore.refreshTokens[token.RefreshToken] = token
        }</span>
        <span class="cov0" title="0">m.tokenStore.mu.Unlock()

        // Return token response
        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(token); err != nil </span><span class="cov0" title="0">{
                m.logger.Error().Err(err).Msg("Failed to encode token response")
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

func (m *AuthMiddleware) handleRefreshTokenGrant(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        refreshToken := r.FormValue("refresh_token")
        clientID := r.FormValue("client_id")
        clientSecret := r.FormValue("client_secret")

        // Validate client credentials
        if clientID != m.config.OAuth2Auth.ClientID || clientSecret != m.config.OAuth2Auth.ClientSecret </span><span class="cov0" title="0">{
                http.Error(w, "Invalid client credentials", http.StatusUnauthorized)
                return
        }</span>

        // Validate refresh token
        <span class="cov0" title="0">m.tokenStore.mu.Lock()
        oldToken, exists := m.tokenStore.refreshTokens[refreshToken]
        delete(m.tokenStore.refreshTokens, refreshToken)        // Remove used refresh token
        delete(m.tokenStore.accessTokens, oldToken.AccessToken) // Remove old access token
        m.tokenStore.mu.Unlock()

        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Invalid refresh token", http.StatusBadRequest)
                return
        }</span>

        // Generate new tokens
        <span class="cov0" title="0">token := m.generateOAuth2Token(oldToken.UserID, oldToken.Scope)
        m.tokenStore.mu.Lock()
        m.tokenStore.accessTokens[token.AccessToken] = token
        if token.RefreshToken != "" </span><span class="cov0" title="0">{
                m.tokenStore.refreshTokens[token.RefreshToken] = token
        }</span>
        <span class="cov0" title="0">m.tokenStore.mu.Unlock()

        // Return token response
        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(token); err != nil </span><span class="cov0" title="0">{
                m.logger.Error().Err(err).Msg("Failed to encode token response")
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

func (m *AuthMiddleware) handleClientCredentialsGrant(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        clientID := r.FormValue("client_id")
        clientSecret := r.FormValue("client_secret")
        scope := r.FormValue("scope")

        // Validate client credentials
        if clientID != m.config.OAuth2Auth.ClientID || clientSecret != m.config.OAuth2Auth.ClientSecret </span><span class="cov0" title="0">{
                http.Error(w, "Invalid client credentials", http.StatusUnauthorized)
                return
        }</span>

        // Generate token without refresh token
        <span class="cov0" title="0">token := m.generateOAuth2Token(clientID, scope)
        token.RefreshToken = "" // Client credentials grant doesn't use refresh tokens

        m.tokenStore.mu.Lock()
        m.tokenStore.accessTokens[token.AccessToken] = token
        m.tokenStore.mu.Unlock()

        // Return token response
        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(token); err != nil </span><span class="cov0" title="0">{
                m.logger.Error().Err(err).Msg("Failed to encode token response")
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

func (m *AuthMiddleware) generateOAuth2Token(userID, scope string) *OAuth2Token <span class="cov0" title="0">{
        token := &amp;OAuth2Token{
                AccessToken:  generateRandomString(32),
                TokenType:    "Bearer",
                RefreshToken: generateRandomString(32),
                ExpiresAt:    time.Now().Add(m.config.OAuth2Auth.AccessTokenTTL),
                Scope:        scope,
                UserID:       userID,
        }
        return token
}</span>

func generateRandomString(length int) string <span class="cov0" title="0">{
        b := make([]byte, length)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(b)</span>
}

// validateRedirectURI validates that the provided redirect URI is in the allowed list
func (m *AuthMiddleware) validateRedirectURI(redirectURI string) error <span class="cov7" title="7">{
        if redirectURI == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("redirect URI is required")
        }</span>

        // Parse the redirect URI to validate it's a proper URL
        <span class="cov6" title="6">parsedURI, err := url.ParseRequestURI(redirectURI)
        if err != nil </span><span class="cov3" title="2">{
                return fmt.Errorf("invalid redirect URI format: %w", err)
        }</span>

        // Check if the scheme is http or https
        <span class="cov5" title="4">if parsedURI.Scheme != "http" &amp;&amp; parsedURI.Scheme != "https" </span><span class="cov1" title="1">{
                return fmt.Errorf("redirect URI must use http or https scheme")
        }</span>

        // Check for a non-empty host
        <span class="cov4" title="3">if parsedURI.Host == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("redirect URI must have a valid host")
        }</span>

        // Check if the redirect URI is in the allowed list
        <span class="cov4" title="3">for _, allowedURI := range m.config.OAuth2Auth.AllowedRedirectURIs </span><span class="cov5" title="4">{
                if redirectURI == allowedURI </span><span class="cov3" title="2">{
                        return nil
                }</span>
        }

        <span class="cov1" title="1">return fmt.Errorf("redirect URI not in allowed list")</span>
}

// ----- Handshake helpers ----------------------------------------------------

// ValidateHandshakePayload validates the handshake payload and returns the
// authenticated user identity.
func (m *AuthMiddleware) ValidateHandshakePayload(payload []byte) (string, error) <span class="cov0" title="0">{
        if !m.config.Enabled </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">switch m.config.Type </span>{
        case "basic":<span class="cov0" title="0">
                decoded, err := base64.StdEncoding.DecodeString(string(payload))
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid credentials encoding")
                }</span>
                <span class="cov0" title="0">parts := strings.SplitN(string(decoded), ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid credentials format")
                }</span>
                <span class="cov0" title="0">user := parts[0]
                pass := parts[1]
                info, ok := m.config.BasicAuth.Users[user]
                if !ok || subtle.ConstantTimeCompare([]byte(pass), []byte(info.Password)) != 1 </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid credentials")
                }</span>
                <span class="cov0" title="0">return user, nil</span>
        case "bearer":<span class="cov0" title="0">
                user, ok := m.config.BearerAuth.Tokens[string(payload)]
                if !ok </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid token")
                }</span>
                <span class="cov0" title="0">return user, nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("handshake not supported for %s", m.config.Type)</span>
        }
}

// CreateSessionToken stores a new session token for the given user.
func (m *AuthMiddleware) CreateSessionToken(user string) string <span class="cov0" title="0">{
        token := generateRandomString(32)
        m.mu.Lock()
        m.sessionTokens[token] = user
        m.mu.Unlock()
        return token
}</span>

// Context keys for authentication
type contextKey string

const (
        contextKeyUser  contextKey = "user"
        contextKeyRoles contextKey = "roles"
)

// GetUser extracts the authenticated user from context.
func GetUser(ctx context.Context) (string, bool) <span class="cov3" title="2">{
        user, ok := ctx.Value(contextKeyUser).(string)
        return user, ok
}</span>

// GetRoles extracts the user's roles from context.
func GetRoles(ctx context.Context) ([]string, bool) <span class="cov1" title="1">{
        roles, ok := ctx.Value(contextKeyRoles).([]string)
        return roles, ok
}</span>

// authServerStream wraps a ServerStream with authenticated context.
type authServerStream struct {
        grpc.ServerStream
        ctx context.Context
}

func (s *authServerStream) Context() context.Context <span class="cov0" title="0">{
        return s.ctx
}</span>

// ctxUserKey is the context key under which the authenticated user ( sub  claim)
// is stored after successful JWT verification.
type ctxUserKey struct{}

// AuthenticatedUser returns the user‚Äêid (JWT "sub") previously placed in the
// context by the authentication middleware, or "" if absent.
func AuthenticatedUser(ctx context.Context) string <span class="cov4" title="3">{
        if v, ok := ctx.Value(ctxUserKey{}).(string); ok </span><span class="cov4" title="3">{
                return v
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "context"
        "time"

        "github.com/rs/zerolog"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// LoggingMiddleware provides request logging middleware.
type LoggingMiddleware struct {
        logger zerolog.Logger
}

// NewLoggingMiddleware creates a new logging middleware.
func NewLoggingMiddleware(logger zerolog.Logger) *LoggingMiddleware <span class="cov0" title="0">{
        return &amp;LoggingMiddleware{
                logger: logger,
        }
}</span>

// UnaryInterceptor returns a unary server interceptor for logging.
func (m *LoggingMiddleware) UnaryInterceptor() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                start := time.Now()

                // Get user from context if available
                user, _ := GetUser(ctx)

                // Call handler
                resp, err := handler(ctx, req)

                // Log request
                duration := time.Since(start)
                code := codes.OK
                if err != nil </span><span class="cov0" title="0">{
                        code = status.Code(err)
                }</span>

                <span class="cov0" title="0">event := m.logger.Info()
                if err != nil &amp;&amp; code != codes.Canceled </span><span class="cov0" title="0">{
                        event = m.logger.Error().Err(err)
                }</span>

                <span class="cov0" title="0">event.
                        Str("method", info.FullMethod).
                        Str("user", user).
                        Dur("duration", duration).
                        Str("code", code.String()).
                        Msg("Unary request")

                return resp, err</span>
        }
}

// StreamInterceptor returns a stream server interceptor for logging.
func (m *LoggingMiddleware) StreamInterceptor() grpc.StreamServerInterceptor <span class="cov0" title="0">{
        return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{
                start := time.Now()

                // Get user from context if available
                user, _ := GetUser(ss.Context())

                // Wrap stream to track messages
                wrappedStream := &amp;loggingServerStream{
                        ServerStream: ss,
                        method:       info.FullMethod,
                        logger:       m.logger,
                }

                // Call handler
                err := handler(srv, wrappedStream)

                // Log request
                duration := time.Since(start)
                code := codes.OK
                if err != nil </span><span class="cov0" title="0">{
                        code = status.Code(err)
                }</span>

                <span class="cov0" title="0">event := m.logger.Info()
                if err != nil &amp;&amp; code != codes.Canceled </span><span class="cov0" title="0">{
                        event = m.logger.Error().Err(err)
                }</span>

                <span class="cov0" title="0">event.
                        Str("method", info.FullMethod).
                        Str("user", user).
                        Dur("duration", duration).
                        Str("code", code.String()).
                        Int("messages_sent", wrappedStream.messagesSent).
                        Int("messages_received", wrappedStream.messagesReceived).
                        Msg("Stream request")

                return err</span>
        }
}

// loggingServerStream wraps a ServerStream to track message counts.
type loggingServerStream struct {
        grpc.ServerStream
        method           string
        logger           zerolog.Logger
        messagesSent     int
        messagesReceived int
}

func (s *loggingServerStream) SendMsg(m interface{}) error <span class="cov0" title="0">{
        err := s.ServerStream.SendMsg(m)
        if err == nil </span><span class="cov0" title="0">{
                s.messagesSent++
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (s *loggingServerStream) RecvMsg(m interface{}) error <span class="cov0" title="0">{
        err := s.ServerStream.RecvMsg(m)
        if err == nil </span><span class="cov0" title="0">{
                s.messagesReceived++
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// MetricsCollector defines the interface for collecting metrics.
type MetricsCollector interface {
        IncrementCounter(name string, labels ...string)
        RecordHistogram(name string, value float64, labels ...string)
        RecordGauge(name string, value float64, labels ...string)
        StartTimer(name string) Timer
}

// Timer represents a timing measurement.
type Timer interface {
        Stop() float64
}

// MetricsMiddleware provides metrics collection middleware.
type MetricsMiddleware struct {
        collector MetricsCollector
}

// NewMetricsMiddleware creates a new metrics middleware.
func NewMetricsMiddleware(collector MetricsCollector) *MetricsMiddleware <span class="cov0" title="0">{
        return &amp;MetricsMiddleware{
                collector: collector,
        }
}</span>

// UnaryInterceptor returns a unary server interceptor for metrics.
func (m *MetricsMiddleware) UnaryInterceptor() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                timer := m.collector.StartTimer("grpc_request_duration")
                defer func() </span><span class="cov0" title="0">{
                        duration := timer.Stop()
                        m.collector.RecordHistogram("grpc_request_duration_seconds", duration, "method", info.FullMethod, "type", "unary")
                }</span>()

                // Increment request counter
                <span class="cov0" title="0">m.collector.IncrementCounter("grpc_requests_total", "method", info.FullMethod, "type", "unary")

                // Call handler
                resp, err := handler(ctx, req)

                // Record response status
                code := codes.OK
                if err != nil </span><span class="cov0" title="0">{
                        code = status.Code(err)
                }</span>
                <span class="cov0" title="0">m.collector.IncrementCounter("grpc_responses_total", "method", info.FullMethod, "type", "unary", "code", code.String())

                return resp, err</span>
        }
}

// StreamInterceptor returns a stream server interceptor for metrics.
func (m *MetricsMiddleware) StreamInterceptor() grpc.StreamServerInterceptor <span class="cov0" title="0">{
        return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{
                timer := m.collector.StartTimer("grpc_stream_duration")
                defer func() </span><span class="cov0" title="0">{
                        duration := timer.Stop()
                        m.collector.RecordHistogram("grpc_stream_duration_seconds", duration, "method", info.FullMethod)
                }</span>()

                // Increment stream counter
                <span class="cov0" title="0">m.collector.IncrementCounter("grpc_streams_total", "method", info.FullMethod)

                // Wrap stream to track messages
                wrappedStream := &amp;metricsServerStream{
                        ServerStream: ss,
                        collector:    m.collector,
                        method:       info.FullMethod,
                }

                // Call handler
                err := handler(srv, wrappedStream)

                // Record stream status
                code := codes.OK
                if err != nil </span><span class="cov0" title="0">{
                        code = status.Code(err)
                }</span>
                <span class="cov0" title="0">m.collector.IncrementCounter("grpc_stream_status_total", "method", info.FullMethod, "code", code.String())

                return err</span>
        }
}

// metricsServerStream wraps a ServerStream to track message metrics.
type metricsServerStream struct {
        grpc.ServerStream
        collector MetricsCollector
        method    string
}

func (s *metricsServerStream) SendMsg(m interface{}) error <span class="cov0" title="0">{
        timer := s.collector.StartTimer("grpc_stream_send_duration")
        err := s.ServerStream.SendMsg(m)
        duration := timer.Stop()

        s.collector.RecordHistogram("grpc_stream_send_duration_seconds", duration, "method", s.method)
        s.collector.IncrementCounter("grpc_stream_messages_sent_total", "method", s.method)

        if err != nil </span><span class="cov0" title="0">{
                s.collector.IncrementCounter("grpc_stream_send_errors_total", "method", s.method)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (s *metricsServerStream) RecvMsg(m interface{}) error <span class="cov0" title="0">{
        timer := s.collector.StartTimer("grpc_stream_recv_duration")
        err := s.ServerStream.RecvMsg(m)
        duration := timer.Stop()

        s.collector.RecordHistogram("grpc_stream_recv_duration_seconds", duration, "method", s.method)
        s.collector.IncrementCounter("grpc_stream_messages_received_total", "method", s.method)

        if err != nil </span><span class="cov0" title="0">{
                s.collector.IncrementCounter("grpc_stream_recv_errors_total", "method", s.method)
        }</span>

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "context"
        "fmt"
        "os"
        "runtime/debug"

        "github.com/rs/zerolog"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// RecoveryMiddleware provides panic recovery middleware.
type RecoveryMiddleware struct {
        logger zerolog.Logger
}

// NewRecoveryMiddleware creates a new recovery middleware.
func NewRecoveryMiddleware(logger zerolog.Logger) *RecoveryMiddleware <span class="cov0" title="0">{
        return &amp;RecoveryMiddleware{
                logger: logger,
        }
}</span>

// UnaryInterceptor returns a unary server interceptor for panic recovery.
func (m *RecoveryMiddleware) UnaryInterceptor() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                m.handlePanic(r, info.FullMethod)
                                err = status.Errorf(codes.Internal, "internal server error")
                        }</span>
                }()

                <span class="cov0" title="0">return handler(ctx, req)</span>
        }
}

// StreamInterceptor returns a stream server interceptor for panic recovery.
func (m *RecoveryMiddleware) StreamInterceptor() grpc.StreamServerInterceptor <span class="cov0" title="0">{
        return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) (err error) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                m.handlePanic(r, info.FullMethod)
                                err = status.Errorf(codes.Internal, "internal server error")
                        }</span>
                }()

                <span class="cov0" title="0">return handler(srv, ss)</span>
        }
}

// handlePanic logs panic information.
func (m *RecoveryMiddleware) handlePanic(r interface{}, method string) <span class="cov0" title="0">{
        stack := debug.Stack()

        m.logger.Error().
                Str("method", method).
                Interface("panic", r).
                Str("stack", string(stack)).
                Msg("Panic recovered")

        // Also print to stderr for debugging
        fmt.Fprintf(stderr, "PANIC in %s: %v\n%s\n", method, r, stack)
}</span>

// stderr is used for panic output
var stderr = os.Stderr
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "strings"

        "github.com/TFMV/porter/bench"
        "github.com/apache/arrow-go/v18/arrow/flight/flightsql"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

func main() <span class="cov0" title="0">{
        client, err := flightsql.NewClient("localhost:32010", nil, nil, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer client.Close()

        // Test basic connectivity
        fmt.Println("Testing basic Flight SQL connectivity...")

        // Try a simple query
        info, err := client.Execute(context.Background(), "SELECT 1 as test")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Simple query failed: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Query executed successfully, endpoints: %d\n", len(info.Endpoint))

        // Try to read results
        for i, endpoint := range info.Endpoint </span><span class="cov0" title="0">{
                fmt.Printf("Reading from endpoint %d...\n", i)
                reader, err := client.DoGet(context.Background(), endpoint.Ticket)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("DoGet failed: %v", err)
                        continue</span>
                }

                <span class="cov0" title="0">rowCount := 0
                for reader.Next() </span><span class="cov0" title="0">{
                        record := reader.Record()
                        rowCount += int(record.NumRows())
                        record.Release()
                }</span>
                <span class="cov0" title="0">reader.Release()
                fmt.Printf("Endpoint %d returned %d rows\n", i, rowCount)</span>
        }

        // Try SHOW TABLES
        <span class="cov0" title="0">fmt.Println("\nTesting SHOW TABLES...")
        info, err = client.Execute(context.Background(), "SHOW TABLES")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("SHOW TABLES failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("SHOW TABLES executed successfully, endpoints: %d\n", len(info.Endpoint))

                for _, endpoint := range info.Endpoint </span><span class="cov0" title="0">{
                        reader, err := client.DoGet(context.Background(), endpoint.Ticket)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("DoGet failed for SHOW TABLES: %v", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">for reader.Next() </span><span class="cov0" title="0">{
                                record := reader.Record()
                                fmt.Printf("Tables found: %d\n", record.NumRows())
                                record.Release()
                        }</span>
                        <span class="cov0" title="0">reader.Release()</span>
                }
        }

        // Run Flight SQL Throughput Benchmark
        <span class="cov0" title="0">fmt.Println("\n" + strings.Repeat("=", 60))
        fmt.Println("üöÄ PORTER FLIGHT SQL THROUGHPUT BENCHMARK")
        fmt.Println(strings.Repeat("=", 60))

        serverAddr := "localhost:32010"
        parquetDir := "" // Not used since we have absolute paths now

        fmt.Printf("Server: %s\n", serverAddr)
        fmt.Printf("Protocol: Flight SQL over gRPC\n")
        fmt.Printf("Testing large parquet datasets for throughput...\n\n")

        if err := bench.RunFlightThroughputBenchmarks(serverAddr, parquetDir); err != nil </span><span class="cov0" title="0">{
                log.Printf("‚ùå Flight throughput benchmark failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("\n‚úÖ Flight SQL throughput benchmark completed successfully!")
                fmt.Println("üéØ Porter demonstrates excellent gRPC streaming performance")
                fmt.Println("üìä Ready for production analytical workloads")
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package benchmark provides TPC-H benchmarking capabilities for Porter.
package benchmark

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/array"
        "github.com/apache/arrow-go/v18/arrow/ipc"
        "github.com/apache/arrow-go/v18/arrow/memory"
        "github.com/rs/zerolog"

        _ "github.com/marcboeker/go-duckdb/v2"
)

// BenchmarkConfig holds configuration for TPC-H benchmarks.
type BenchmarkConfig struct {
        Queries     []string      `json:"queries"`
        ScaleFactor float64       `json:"scale_factor"`
        Iterations  int           `json:"iterations"`
        Timeout     time.Duration `json:"timeout"`
        Analyze     bool          `json:"analyze"`
        Database    string        `json:"database"`
}

// QueryResult represents the result of a single query execution.
type QueryResult struct {
        Query         string        `json:"query"`
        Iteration     int           `json:"iteration"`
        ExecutionTime time.Duration `json:"execution_time_ns"`
        RowCount      int64         `json:"row_count"`
        Error         string        `json:"error,omitempty"`
        QueryPlan     string        `json:"query_plan,omitempty"`
}

// BenchmarkResult represents the complete benchmark results.
type BenchmarkResult struct {
        Config      BenchmarkConfig `json:"config"`
        Results     []QueryResult   `json:"results"`
        TotalTime   time.Duration   `json:"total_time_ns"`
        StartTime   time.Time       `json:"start_time"`
        EndTime     time.Time       `json:"end_time"`
        Environment Environment     `json:"environment"`
}

// Environment captures system information for benchmark results.
type Environment struct {
        DuckDBVersion string `json:"duckdb_version"`
        GoVersion     string `json:"go_version"`
        OS            string `json:"os"`
        Arch          string `json:"arch"`
}

// TPC-H query definitions
var tpchQueries = map[string]string{
        "q1": `
                SELECT
                        l_returnflag,
                        l_linestatus,
                        sum(l_quantity) as sum_qty,
                        sum(l_extendedprice) as sum_base_price,
                        sum(l_extendedprice * (1 - l_discount)) as sum_disc_price,
                        sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,
                        avg(l_quantity) as avg_qty,
                        avg(l_extendedprice) as avg_price,
                        avg(l_discount) as avg_disc,
                        count(*) as count_order
                FROM lineitem
                WHERE l_shipdate &lt;= date '1998-12-01' - interval '90' day
                GROUP BY l_returnflag, l_linestatus
                ORDER BY l_returnflag, l_linestatus`,

        "q2": `
                SELECT
                        s_acctbal,
                        s_name,
                        n_name,
                        p_partkey,
                        p_mfgr,
                        s_address,
                        s_phone,
                        s_comment
                FROM part, supplier, partsupp, nation, region
                WHERE p_partkey = ps_partkey
                        AND s_suppkey = ps_suppkey
                        AND p_size = 15
                        AND p_type like '%BRASS'
                        AND s_nationkey = n_nationkey
                        AND n_regionkey = r_regionkey
                        AND r_name = 'EUROPE'
                        AND ps_supplycost = (
                                SELECT min(ps_supplycost)
                                FROM partsupp, supplier, nation, region
                                WHERE p_partkey = ps_partkey
                                        AND s_suppkey = ps_suppkey
                                        AND s_nationkey = n_nationkey
                                        AND n_regionkey = r_regionkey
                                        AND r_name = 'EUROPE')
                ORDER BY s_acctbal desc, n_name, s_name, p_partkey
                LIMIT 100`,

        "q3": `
                SELECT
                        l_orderkey,
                        sum(l_extendedprice * (1 - l_discount)) as revenue,
                        o_orderdate,
                        o_shippriority
                FROM customer, orders, lineitem
                WHERE c_mktsegment = 'BUILDING'
                        AND c_custkey = o_custkey
                        AND l_orderkey = o_orderkey
                        AND o_orderdate &lt; date '1995-03-15'
                        AND l_shipdate &gt; date '1995-03-15'
                GROUP BY l_orderkey, o_orderdate, o_shippriority
                ORDER BY revenue desc, o_orderdate
                LIMIT 10`,

        "q4": `
                SELECT
                        o_orderpriority,
                        count(*) as order_count
                FROM orders
                WHERE o_orderdate &gt;= date '1993-07-01'
                        AND o_orderdate &lt; date '1993-07-01' + interval '3' month
                        AND exists (
                                SELECT *
                                FROM lineitem
                                WHERE l_orderkey = o_orderkey
                                        AND l_commitdate &lt; l_receiptdate)
                GROUP BY o_orderpriority
                ORDER BY o_orderpriority`,

        "q5": `
                SELECT
                        n_name,
                        sum(l_extendedprice * (1 - l_discount)) as revenue
                FROM customer, orders, lineitem, supplier, nation, region
                WHERE c_custkey = o_custkey
                        AND l_orderkey = o_orderkey
                        AND l_suppkey = s_suppkey
                        AND c_nationkey = s_nationkey
                        AND s_nationkey = n_nationkey
                        AND n_regionkey = r_regionkey
                        AND r_name = 'ASIA'
                        AND o_orderdate &gt;= date '1994-01-01'
                        AND o_orderdate &lt; date '1994-01-01' + interval '1' year
                GROUP BY n_name
                ORDER BY revenue desc`,

        "q6": `
                SELECT
                        sum(l_extendedprice * l_discount) as revenue
                FROM lineitem
                WHERE l_shipdate &gt;= date '1994-01-01'
                        AND l_shipdate &lt; date '1994-01-01' + interval '1' year
                        AND l_discount between 0.06 - 0.01 AND 0.06 + 0.01
                        AND l_quantity &lt; 24`,

        "q7": `
                SELECT
                        supp_nation,
                        cust_nation,
                        l_year,
                        sum(volume) as revenue
                FROM (
                        SELECT
                                n1.n_name as supp_nation,
                                n2.n_name as cust_nation,
                                extract(year from l_shipdate) as l_year,
                                l_extendedprice * (1 - l_discount) as volume
                        FROM supplier, lineitem, orders, customer, nation n1, nation n2
                        WHERE s_suppkey = l_suppkey
                                AND o_orderkey = l_orderkey
                                AND c_custkey = o_custkey
                                AND s_nationkey = n1.n_nationkey
                                AND c_nationkey = n2.n_nationkey
                                AND ((n1.n_name = 'FRANCE' AND n2.n_name = 'GERMANY')
                                        OR (n1.n_name = 'GERMANY' AND n2.n_name = 'FRANCE'))
                                AND l_shipdate between date '1995-01-01' AND date '1996-12-31'
                ) as shipping
                GROUP BY supp_nation, cust_nation, l_year
                ORDER BY supp_nation, cust_nation, l_year`,

        "q8": `
                SELECT
                        o_year,
                        sum(case when nation = 'BRAZIL' then volume else 0 end) / sum(volume) as mkt_share
                FROM (
                        SELECT
                                extract(year from o_orderdate) as o_year,
                                l_extendedprice * (1 - l_discount) as volume,
                                n2.n_name as nation
                        FROM part, supplier, lineitem, orders, customer, nation n1, nation n2, region
                        WHERE p_partkey = l_partkey
                                AND s_suppkey = l_suppkey
                                AND l_orderkey = o_orderkey
                                AND o_custkey = c_custkey
                                AND c_nationkey = n1.n_nationkey
                                AND n1.n_regionkey = r_regionkey
                                AND r_name = 'AMERICA'
                                AND s_nationkey = n2.n_nationkey
                                AND o_orderdate between date '1995-01-01' AND date '1996-12-31'
                                AND p_type = 'ECONOMY ANODIZED STEEL'
                ) as all_nations
                GROUP BY o_year
                ORDER BY o_year`,

        "q9": `
                SELECT
                        nation,
                        o_year,
                        sum(amount) as sum_profit
                FROM (
                        SELECT
                                n_name as nation,
                                extract(year from o_orderdate) as o_year,
                                l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount
                        FROM part, supplier, lineitem, partsupp, orders, nation
                        WHERE s_suppkey = l_suppkey
                                AND ps_suppkey = l_suppkey
                                AND ps_partkey = l_partkey
                                AND p_partkey = l_partkey
                                AND o_orderkey = l_orderkey
                                AND s_nationkey = n_nationkey
                                AND p_name like '%green%'
                ) as profit
                GROUP BY nation, o_year
                ORDER BY nation, o_year desc`,

        "q10": `
                SELECT
                        c_custkey,
                        c_name,
                        sum(l_extendedprice * (1 - l_discount)) as revenue,
                        c_acctbal,
                        n_name,
                        c_address,
                        c_phone,
                        c_comment
                FROM customer, orders, lineitem, nation
                WHERE c_custkey = o_custkey
                        AND l_orderkey = o_orderkey
                        AND o_orderdate &gt;= date '1993-10-01'
                        AND o_orderdate &lt; date '1993-10-01' + interval '3' month
                        AND l_returnflag = 'R'
                        AND c_nationkey = n_nationkey
                GROUP BY c_custkey, c_name, c_acctbal, c_phone, n_name, c_address, c_comment
                ORDER BY revenue desc
                LIMIT 20`,
}

// Runner executes TPC-H benchmarks.
type Runner struct {
        db        *sql.DB
        allocator memory.Allocator
        logger    zerolog.Logger
}

// NewRunner creates a new benchmark runner.
func NewRunner(dbPath string, logger zerolog.Logger) (*Runner, error) <span class="cov0" title="0">{
        db, err := sql.Open("duckdb", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Test connection
        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Runner{
                db:        db,
                allocator: memory.NewGoAllocator(),
                logger:    logger.With().Str("component", "benchmark").Logger(),
        }, nil</span>
}

// Close closes the database connection.
func (r *Runner) Close() error <span class="cov0" title="0">{
        return r.db.Close()
}</span>

// Run executes the benchmark with the given configuration.
func (r *Runner) Run(ctx context.Context, config BenchmarkConfig) (*BenchmarkResult, error) <span class="cov0" title="0">{
        startTime := time.Now()

        r.logger.Info().
                Strs("queries", config.Queries).
                Float64("scale", config.ScaleFactor).
                Int("iterations", config.Iterations).
                Msg("Starting TPC-H benchmark")

        // Initialize TPC-H data
        if err := r.initializeTPCH(ctx, config.ScaleFactor); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize TPC-H data: %w", err)
        }</span>

        <span class="cov0" title="0">var results []QueryResult

        for _, queryName := range config.Queries </span><span class="cov0" title="0">{
                query, exists := tpchQueries[queryName]
                if !exists </span><span class="cov0" title="0">{
                        r.logger.Warn().Str("query", queryName).Msg("Unknown query, skipping")
                        continue</span>
                }

                <span class="cov0" title="0">for iteration := 1; iteration &lt;= config.Iterations; iteration++ </span><span class="cov0" title="0">{
                        result := r.executeQuery(ctx, queryName, query, iteration, config)
                        results = append(results, result)

                        r.logger.Info().
                                Str("query", queryName).
                                Int("iteration", iteration).
                                Dur("time", result.ExecutionTime).
                                Int64("rows", result.RowCount).
                                Str("error", result.Error).
                                Msg("Query completed")
                }</span>
        }

        <span class="cov0" title="0">endTime := time.Now()

        env, err := r.getEnvironment(ctx)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Warn().Err(err).Msg("Failed to get environment info")
        }</span>

        <span class="cov0" title="0">return &amp;BenchmarkResult{
                Config:      config,
                Results:     results,
                TotalTime:   endTime.Sub(startTime),
                StartTime:   startTime,
                EndTime:     endTime,
                Environment: env,
        }, nil</span>
}

// initializeTPCH sets up the TPC-H schema and data using DuckDB's built-in module.
func (r *Runner) initializeTPCH(ctx context.Context, scaleFactor float64) error <span class="cov0" title="0">{
        r.logger.Info().Float64("scale", scaleFactor).Msg("Initializing TPC-H data")

        // Install and load the TPC-H extension
        queries := []string{
                "INSTALL tpch",
                "LOAD tpch",
                fmt.Sprintf("CALL dbgen(sf=%g)", scaleFactor),
        }

        for _, query := range queries </span><span class="cov0" title="0">{
                if _, err := r.db.ExecContext(ctx, query); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute '%s': %w", query, err)
                }</span>
        }

        <span class="cov0" title="0">r.logger.Info().Float64("scale", scaleFactor).Msg("TPC-H data initialized")
        return nil</span>
}

// executeQuery runs a single query and measures its performance.
func (r *Runner) executeQuery(ctx context.Context, queryName, query string, iteration int, config BenchmarkConfig) QueryResult <span class="cov0" title="0">{
        result := QueryResult{
                Query:     queryName,
                Iteration: iteration,
        }

        // Add timeout to context
        queryCtx, cancel := context.WithTimeout(ctx, config.Timeout)
        defer cancel()

        start := time.Now()

        // Get query plan if requested
        if config.Analyze </span><span class="cov0" title="0">{
                planQuery := "EXPLAIN " + query
                rows, err := r.db.QueryContext(queryCtx, planQuery)
                if err != nil </span><span class="cov0" title="0">{
                        result.QueryPlan = fmt.Sprintf("Error getting plan: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        plan, err := r.readPlan(rows)
                        rows.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                result.QueryPlan = fmt.Sprintf("Error reading plan: %v", err)
                        }</span> else<span class="cov0" title="0"> {
                                result.QueryPlan = plan
                        }</span>
                }
        }

        // Execute the actual query
        <span class="cov0" title="0">rows, err := r.db.QueryContext(queryCtx, query)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = err.Error()
                result.ExecutionTime = time.Since(start)
                return result
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Count rows
        var rowCount int64
        for rows.Next() </span><span class="cov0" title="0">{
                rowCount++
        }</span>

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                result.Error = err.Error()
        }</span>

        <span class="cov0" title="0">result.ExecutionTime = time.Since(start)
        result.RowCount = rowCount

        return result</span>
}

// readPlan reads the query plan from EXPLAIN output.
func (r *Runner) readPlan(rows *sql.Rows) (string, error) <span class="cov0" title="0">{
        var plan strings.Builder
        for rows.Next() </span><span class="cov0" title="0">{
                var line string
                if err := rows.Scan(&amp;line); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">plan.WriteString(line)
                plan.WriteString("\n")</span>
        }
        <span class="cov0" title="0">return plan.String(), rows.Err()</span>
}

// getEnvironment captures system and database information.
func (r *Runner) getEnvironment(ctx context.Context) (Environment, error) <span class="cov0" title="0">{
        env := Environment{
                GoVersion: "go1.24", // This would be runtime.Version() in real code
                OS:        "darwin", // This would be runtime.GOOS in real code
                Arch:      "arm64",  // This would be runtime.GOARCH in real code
        }

        // Get DuckDB version
        row := r.db.QueryRowContext(ctx, "SELECT version()")
        if err := row.Scan(&amp;env.DuckDBVersion); err != nil </span><span class="cov0" title="0">{
                return env, fmt.Errorf("failed to get DuckDB version: %w", err)
        }</span>

        <span class="cov0" title="0">return env, nil</span>
}

// GetAvailableQueries returns the list of available TPC-H queries.
func GetAvailableQueries() []string <span class="cov0" title="0">{
        queries := make([]string, 0, len(tpchQueries))
        for name := range tpchQueries </span><span class="cov0" title="0">{
                queries = append(queries, name)
        }</span>
        <span class="cov0" title="0">return queries</span>
}

// ParseQueries parses a comma-separated list of query names.
func ParseQueries(queryStr string) ([]string, error) <span class="cov0" title="0">{
        if queryStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no queries specified")
        }</span>

        <span class="cov0" title="0">queries := strings.Split(queryStr, ",")
        for i, q := range queries </span><span class="cov0" title="0">{
                queries[i] = strings.TrimSpace(q)
                if _, exists := tpchQueries[queries[i]]; !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unknown query: %s", queries[i])
                }</span>
        }

        <span class="cov0" title="0">return queries, nil</span>
}

// GetAllQueries returns all available TPC-H query names.
func GetAllQueries() []string <span class="cov0" title="0">{
        return []string{"q1", "q2", "q3", "q4", "q5", "q6", "q7", "q8", "q9", "q10"} // Add more as needed
}</span>

// OutputResult writes the benchmark result in the specified format.
func OutputResult(result *BenchmarkResult, format string, writer io.Writer) error <span class="cov0" title="0">{
        switch strings.ToLower(format) </span>{
        case "json":<span class="cov0" title="0">
                encoder := json.NewEncoder(writer)
                encoder.SetIndent("", "  ")
                return encoder.Encode(result)</span>

        case "table":<span class="cov0" title="0">
                return outputTable(result, writer)</span>

        case "arrow":<span class="cov0" title="0">
                return outputArrow(result, writer)</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported format: %s", format)</span>
        }
}

// outputTable writes results in human-readable table format.
func outputTable(result *BenchmarkResult, writer io.Writer) error <span class="cov0" title="0">{
        fmt.Fprintf(writer, "TPC-H Benchmark Results\n")
        fmt.Fprintf(writer, "=======================\n\n")
        fmt.Fprintf(writer, "Configuration:\n")
        fmt.Fprintf(writer, "  Scale Factor: %.2f\n", result.Config.ScaleFactor)
        fmt.Fprintf(writer, "  Iterations: %d\n", result.Config.Iterations)
        fmt.Fprintf(writer, "  Total Time: %v\n", result.TotalTime)
        fmt.Fprintf(writer, "  Started: %s\n", result.StartTime.Format(time.RFC3339))
        fmt.Fprintf(writer, "\n")

        fmt.Fprintf(writer, "Environment:\n")
        fmt.Fprintf(writer, "  DuckDB Version: %s\n", result.Environment.DuckDBVersion)
        fmt.Fprintf(writer, "  Go Version: %s\n", result.Environment.GoVersion)
        fmt.Fprintf(writer, "  OS/Arch: %s/%s\n", result.Environment.OS, result.Environment.Arch)
        fmt.Fprintf(writer, "\n")

        fmt.Fprintf(writer, "Results:\n")
        fmt.Fprintf(writer, "%-6s %-4s %-12s %-8s %s\n", "Query", "Iter", "Time", "Rows", "Status")
        fmt.Fprintf(writer, "%-6s %-4s %-12s %-8s %s\n", "-----", "----", "----", "----", "------")

        for _, r := range result.Results </span><span class="cov0" title="0">{
                status := "OK"
                if r.Error != "" </span><span class="cov0" title="0">{
                        status = "ERROR"
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(writer, "%-6s %-4d %-12s %-8d %s\n",
                        r.Query, r.Iteration, r.ExecutionTime, r.RowCount, status)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// outputArrow writes results in Apache Arrow format.
func outputArrow(result *BenchmarkResult, writer io.Writer) error <span class="cov0" title="0">{
        // Create Arrow schema for benchmark results
        fields := []arrow.Field{
                {Name: "query", Type: arrow.BinaryTypes.String},
                {Name: "iteration", Type: arrow.PrimitiveTypes.Int32},
                {Name: "execution_time_ns", Type: arrow.PrimitiveTypes.Int64},
                {Name: "row_count", Type: arrow.PrimitiveTypes.Int64},
                {Name: "error", Type: arrow.BinaryTypes.String},
        }

        schema := arrow.NewSchema(fields, nil)
        allocator := memory.NewGoAllocator()

        // Build record
        builder := array.NewRecordBuilder(allocator, schema)
        defer builder.Release()

        for _, r := range result.Results </span><span class="cov0" title="0">{
                builder.Field(0).(*array.StringBuilder).Append(r.Query)
                builder.Field(1).(*array.Int32Builder).Append(int32(r.Iteration))
                builder.Field(2).(*array.Int64Builder).Append(int64(r.ExecutionTime))
                builder.Field(3).(*array.Int64Builder).Append(r.RowCount)
                builder.Field(4).(*array.StringBuilder).Append(r.Error)
        }</span>

        <span class="cov0" title="0">record := builder.NewRecord()
        defer record.Release()

        // Write Arrow IPC stream
        w := ipc.NewWriter(writer, ipc.WithSchema(schema))
        defer w.Close()

        return w.Write(record)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cache

import (
        "bytes"
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "reflect"
        "sort"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/memory"
        "github.com/apache/arrow-go/v18/arrow/scalar"
)

// Cache defines the interface for caching Arrow record batches
type Cache interface {
        // Get retrieves a record batch from the cache
        Get(ctx context.Context, key string) (arrow.Record, error)
        // Put stores a record batch in the cache
        Put(ctx context.Context, key string, record arrow.Record) error
        // Delete removes a record batch from the cache
        Delete(ctx context.Context, key string) error
        // Clear removes all entries from the cache
        Clear(ctx context.Context) error
        // Close releases any resources held by the cache
        Close() error
}

// CacheEntry represents a single cache entry with metadata
type CacheEntry struct {
        Record    arrow.Record
        CreatedAt time.Time
        LastUsed  time.Time
        Size      int64
}

// MemoryCache implements Cache interface using in-memory storage
type MemoryCache struct {
        mu       sync.RWMutex
        entries  map[string]*CacheEntry
        maxSize  int64
        currSize int64
        alloc    memory.Allocator
}

// NewMemoryCache creates a new memory cache with the specified maximum size
func NewMemoryCache(maxSize int64, alloc memory.Allocator) *MemoryCache <span class="cov5" title="5">{
        return &amp;MemoryCache{
                entries: make(map[string]*CacheEntry),
                maxSize: maxSize,
                alloc:   alloc,
        }
}</span>

// Get retrieves a record batch from the cache
func (c *MemoryCache) Get(ctx context.Context, key string) (arrow.Record, error) <span class="cov6" title="9">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if entry, ok := c.entries[key]; ok </span><span class="cov3" title="3">{
                entry.LastUsed = time.Now()
                entry.Record.Retain()
                return entry.Record, nil
        }</span>
        <span class="cov5" title="6">return nil, nil</span>
}

// Put stores a record batch in the cache
func (c *MemoryCache) Put(ctx context.Context, key string, record arrow.Record) error <span class="cov5" title="7">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Calculate size of the record
        size := int64(0)
        for i := int64(0); i &lt; int64(record.NumCols()); i++ </span><span class="cov7" title="14">{
                col := record.Column(int(i))
                data := col.Data()

                // Add size of each buffer
                for _, buf := range data.Buffers() </span><span class="cov10" title="35">{
                        if buf != nil </span><span class="cov10" title="35">{
                                size += int64(buf.Len())
                        }</span>
                }

                // Add size of any child data
                <span class="cov7" title="14">for _, child := range data.Children() </span><span class="cov0" title="0">{
                        for _, buf := range child.Buffers() </span><span class="cov0" title="0">{
                                if buf != nil </span><span class="cov0" title="0">{
                                        size += int64(buf.Len())
                                }</span>
                        }
                }
        }

        // Add size of schema
        <span class="cov5" title="7">size += int64(record.NumCols() * 32) // Rough estimate for schema overhead

        // If the record is too large for the cache, don't store it
        if size &gt; c.maxSize </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Check if we need to evict entries to make space
        <span class="cov5" title="6">for c.currSize+size &gt; c.maxSize </span><span class="cov1" title="1">{
                if len(c.entries) == 0 </span><span class="cov0" title="0">{
                        // If we can't make space, don't store the record
                        return nil
                }</span>
                <span class="cov1" title="1">c.evictOldest()</span>
        }

        // Create new entry
        <span class="cov5" title="6">record.Retain()
        entry := &amp;CacheEntry{
                Record:    record,
                CreatedAt: time.Now(),
                LastUsed:  time.Now(),
                Size:      size,
        }

        // Remove old entry if it exists
        if oldEntry, ok := c.entries[key]; ok </span><span class="cov0" title="0">{
                oldEntry.Record.Release()
                c.currSize -= oldEntry.Size
                delete(c.entries, key)
        }</span>

        <span class="cov5" title="6">c.entries[key] = entry
        c.currSize += size
        return nil</span>
}

// Delete removes a record batch from the cache
func (c *MemoryCache) Delete(ctx context.Context, key string) error <span class="cov1" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if entry, ok := c.entries[key]; ok </span><span class="cov1" title="1">{
                entry.Record.Release()
                c.currSize -= entry.Size
                delete(c.entries, key)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Clear removes all entries from the cache
func (c *MemoryCache) Clear(ctx context.Context) error <span class="cov5" title="6">{
        c.mu.Lock()
        defer c.mu.Unlock()

        for _, entry := range c.entries </span><span class="cov4" title="4">{
                entry.Record.Release()
        }</span>
        <span class="cov5" title="6">c.entries = make(map[string]*CacheEntry)
        c.currSize = 0
        return nil</span>
}

// Close releases any resources held by the cache
func (c *MemoryCache) Close() error <span class="cov5" title="5">{
        return c.Clear(context.Background())
}</span>

// evictOldest removes the least recently used entry from the cache
func (c *MemoryCache) evictOldest() <span class="cov1" title="1">{
        for c.currSize &gt; 0 </span><span class="cov1" title="1">{
                var oldestKey string
                var oldestTime time.Time

                for key, entry := range c.entries </span><span class="cov1" title="1">{
                        if oldestKey == "" || entry.LastUsed.Before(oldestTime) </span><span class="cov1" title="1">{
                                oldestKey = key
                                oldestTime = entry.LastUsed
                        }</span>
                }

                <span class="cov1" title="1">if oldestKey != "" </span><span class="cov1" title="1">{
                        c.currSize -= c.entries[oldestKey].Size
                        c.entries[oldestKey].Record.Release()
                        delete(c.entries, oldestKey)
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }
}

// renderValue converts an arbitrary parameter value into a canonical string.
func RenderValue(v any) string <span class="cov5" title="6">{
        switch t := v.(type) </span>{
        case nil:<span class="cov0" title="0">
                return "null"</span>

        // ‚îÄ‚îÄ primitives ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        case bool:<span class="cov0" title="0">
                if t </span><span class="cov0" title="0">{
                        return "true"
                }</span>
                <span class="cov0" title="0">return "false"</span>
        case int, int8, int16, int32, int64:<span class="cov3" title="3">
                return strconv.FormatInt(reflect.ValueOf(t).Int(), 10)</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return strconv.FormatUint(reflect.ValueOf(t).Uint(), 10)</span>
        case float32:<span class="cov0" title="0">
                return strconv.FormatFloat(float64(t), 'g', -1, 32)</span>
        case float64:<span class="cov0" title="0">
                return strconv.FormatFloat(t, 'g', -1, 64)</span>
        case string:<span class="cov3" title="3">
                return Escape(t)</span>

        case time.Time:<span class="cov0" title="0">
                return t.UTC().Format(time.RFC3339Nano)</span>

        case []byte:<span class="cov0" title="0">
                return "0x" + hex.EncodeToString(t)</span>

        // ‚îÄ‚îÄ Arrow scalar values ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        case scalar.Scalar:<span class="cov0" title="0">
                return Escape(t.String())</span>

        // ‚îÄ‚îÄ slices / arrays (deterministic order) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        case []any:<span class="cov0" title="0">
                var parts []string
                for _, elem := range t </span><span class="cov0" title="0">{
                        parts = append(parts, RenderValue(elem))
                }</span>
                <span class="cov0" title="0">return "[" + strings.Join(parts, ",") + "]"</span>
        default:<span class="cov0" title="0">
                rv := reflect.ValueOf(v)

                // Handle slices &amp; arrays of specific element types
                if rv.Kind() == reflect.Slice || rv.Kind() == reflect.Array </span><span class="cov0" title="0">{
                        var parts []string
                        for i := 0; i &lt; rv.Len(); i++ </span><span class="cov0" title="0">{
                                parts = append(parts, RenderValue(rv.Index(i).Interface()))
                        }</span>
                        <span class="cov0" title="0">return "[" + strings.Join(parts, ",") + "]"</span>
                }

                // Handle maps with sorted keys
                <span class="cov0" title="0">if rv.Kind() == reflect.Map </span><span class="cov0" title="0">{
                        keys := rv.MapKeys()
                        sort.Slice(keys, func(i, j int) bool </span><span class="cov0" title="0">{
                                return keys[i].String() &lt; keys[j].String()
                        }</span>)
                        <span class="cov0" title="0">var buf bytes.Buffer
                        buf.WriteByte('{')
                        for i, k := range keys </span><span class="cov0" title="0">{
                                if i &gt; 0 </span><span class="cov0" title="0">{
                                        buf.WriteByte(',')
                                }</span>
                                <span class="cov0" title="0">buf.WriteString(RenderValue(k.Interface()))
                                buf.WriteByte(':')
                                buf.WriteString(RenderValue(rv.MapIndex(k).Interface()))</span>
                        }
                        <span class="cov0" title="0">buf.WriteByte('}')
                        return buf.String()</span>
                }

                // Handle structs via JSON to get deterministic field ordering
                <span class="cov0" title="0">if rv.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                        // `json.Marshal` orders struct fields alphabetically by tag/name.
                        b, _ := json.Marshal(v)
                        return Escape(string(b))
                }</span>

                // Fallback: Go‚Äësyntax representation (deterministic for scalars)
                <span class="cov0" title="0">return Escape(fmt.Sprintf("%#v", v))</span>
        }
}

// escape ensures separator characters don't leak into the output.
func Escape(s string) string <span class="cov6" title="9">{
        replacer := strings.NewReplacer(
                "\\", `\\`,
                "|", `\|`,
                "=", `\=`,
                ",", `\,`,
                "{", `\{`,
                "}", `\}`,
                "[", `\[`,
                "]", `\]`,
        )
        return replacer.Replace(s)
}</span>

// CacheKeyGenerator defines the interface for generating cache keys
type CacheKeyGenerator interface {
        GenerateKey(query string, params map[string]interface{}) string
}

// DefaultCacheKeyGenerator implements CacheKeyGenerator
type DefaultCacheKeyGenerator struct{}

// TODO:GenerateKey creates a deterministic cache‚Äëkey based on the SQL text
// (with whitespace normalised) and a stable, ordered serialisation of
// the parameter map.
//
// The resulting key is a hex‚Äëencoded SHA‚Äë256 digest, keeping it short
// and collision‚Äëresistant while hiding potentially sensitive values.
func (g *DefaultCacheKeyGenerator) GenerateKey(query string, params map[string]interface{}) string <span class="cov4" title="4">{
        // Normalise all whitespace in the query to a single space so semantically
        // identical queries hash to the same key.
        normalized := strings.Join(strings.Fields(query), " ")

        var buf bytes.Buffer
        buf.WriteString(normalized)

        // Serialise parameters in stable order so maps with different key
        // ordering generate the same cache key.
        if len(params) &gt; 0 </span><span class="cov3" title="3">{
                buf.WriteByte('|')

                keys := make([]string, 0, len(params))
                for k := range params </span><span class="cov5" title="6">{
                        keys = append(keys, k)
                }</span>
                <span class="cov3" title="3">sort.Strings(keys)

                for i, k := range keys </span><span class="cov5" title="6">{
                        if i &gt; 0 </span><span class="cov3" title="3">{
                                buf.WriteByte(',')
                        }</span>
                        <span class="cov5" title="6">buf.WriteString(Escape(k))
                        buf.WriteByte('=')
                        buf.WriteString(RenderValue(params[k]))</span>
                }
        }

        <span class="cov4" title="4">sum := sha256.Sum256(buf.Bytes())
        return hex.EncodeToString(sum[:])</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package cache

import (
        "time"

        "github.com/apache/arrow-go/v18/arrow/memory"
)

// Config holds the configuration for the cache
type Config struct {
        // MaxSize is the maximum size of the cache in bytes
        MaxSize int64
        // TTL is the time-to-live for cache entries
        TTL time.Duration
        // Allocator is the memory allocator to use
        Allocator memory.Allocator
        // EnableStats enables cache statistics collection
        EnableStats bool
}

// DefaultConfig returns a default cache configuration
func DefaultConfig() *Config <span class="cov10" title="6">{
        return &amp;Config{
                MaxSize:     100 * 1024 * 1024, // 100MB
                TTL:         5 * time.Minute,
                Allocator:   memory.DefaultAllocator,
                EnableStats: true,
        }
}</span>

// WithMaxSize sets the maximum size of the cache
func (c *Config) WithMaxSize(size int64) *Config <span class="cov4" title="2">{
        c.MaxSize = size
        return c
}</span>

// WithTTL sets the time-to-live for cache entries
func (c *Config) WithTTL(ttl time.Duration) *Config <span class="cov4" title="2">{
        c.TTL = ttl
        return c
}</span>

// WithAllocator sets the memory allocator
func (c *Config) WithAllocator(alloc memory.Allocator) *Config <span class="cov4" title="2">{
        c.Allocator = alloc
        return c
}</span>

// WithStats enables or disables cache statistics
func (c *Config) WithStats(enable bool) *Config <span class="cov6" title="3">{
        c.EnableStats = enable
        return c
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package cache

import (
        "sync"
        "sync/atomic"
        "time"
)

// Stats holds cache statistics
type Stats struct {
        Hits        uint64
        Misses      uint64
        Evictions   uint64
        Size        int64
        LastUpdated time.Time
}

// StatsCollector collects and reports cache statistics
type StatsCollector struct {
        stats Stats
        mu    sync.RWMutex // Protects LastUpdated
}

// NewStatsCollector creates a new statistics collector
func NewStatsCollector() *StatsCollector <span class="cov7" title="8">{
        return &amp;StatsCollector{
                stats: Stats{
                        LastUpdated: time.Now(),
                },
        }
}</span>

// RecordHit records a cache hit
func (c *StatsCollector) RecordHit() <span class="cov10" title="18">{
        atomic.AddUint64(&amp;c.stats.Hits, 1)
        c.mu.Lock()
        c.stats.LastUpdated = time.Now()
        c.mu.Unlock()
}</span>

// RecordMiss records a cache miss
func (c *StatsCollector) RecordMiss() <span class="cov9" title="17">{
        atomic.AddUint64(&amp;c.stats.Misses, 1)
        c.mu.Lock()
        c.stats.LastUpdated = time.Now()
        c.mu.Unlock()
}</span>

// RecordEviction records a cache eviction
func (c *StatsCollector) RecordEviction() <span class="cov8" title="12">{
        atomic.AddUint64(&amp;c.stats.Evictions, 1)
        c.mu.Lock()
        c.stats.LastUpdated = time.Now()
        c.mu.Unlock()
}</span>

// UpdateSize updates the current cache size
func (c *StatsCollector) UpdateSize(size int64) <span class="cov8" title="13">{
        atomic.StoreInt64(&amp;c.stats.Size, size)
        c.mu.Lock()
        c.stats.LastUpdated = time.Now()
        c.mu.Unlock()
}</span>

// GetStats returns the current cache statistics
func (c *StatsCollector) GetStats() Stats <span class="cov7" title="7">{
        c.mu.RLock()
        lastUpdated := c.stats.LastUpdated
        c.mu.RUnlock()

        return Stats{
                Hits:        atomic.LoadUint64(&amp;c.stats.Hits),
                Misses:      atomic.LoadUint64(&amp;c.stats.Misses),
                Evictions:   atomic.LoadUint64(&amp;c.stats.Evictions),
                Size:        atomic.LoadInt64(&amp;c.stats.Size),
                LastUpdated: lastUpdated,
        }
}</span>

// HitRate returns the cache hit rate
func (c *StatsCollector) HitRate() float64 <span class="cov5" title="4">{
        hits := atomic.LoadUint64(&amp;c.stats.Hits)
        misses := atomic.LoadUint64(&amp;c.stats.Misses)
        total := hits + misses
        if total == 0 </span><span class="cov1" title="1">{
                return 0
        }</span>
        <span class="cov4" title="3">return float64(hits) / float64(total)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package errors provides standardized error types for the Flight SQL server.
package errors

import (
        "errors"
        "fmt"
)

// Error codes matching gRPC/Flight SQL conventions
const (
        CodeInvalidRequest     = "INVALID_REQUEST"
        CodeNotFound           = "NOT_FOUND"
        CodeAlreadyExists      = "ALREADY_EXISTS"
        CodeTransactionFailed  = "TRANSACTION_FAILED"
        CodeQueryFailed        = "QUERY_FAILED"
        CodeStatementFailed    = "STATEMENT_FAILED"
        CodeConnectionFailed   = "CONNECTION_FAILED"
        CodeMetadataFailed     = "METADATA_FAILED"
        CodeInternal           = "INTERNAL_ERROR"
        CodeUnavailable        = "UNAVAILABLE"
        CodeDeadlineExceeded   = "DEADLINE_EXCEEDED"
        CodeCanceled           = "CANCELED"
        CodeFailedPrecondition = "FAILED_PRECONDITION"
        CodeAborted            = "ABORTED"
        CodeResourceExhausted  = "RESOURCE_EXHAUSTED"
        CodeUnimplemented      = "UNIMPLEMENTED"
        CodeUnauthorized       = "UNAUTHORIZED"
        CodePermissionDenied   = "PERMISSION_DENIED"
)

// FlightError represents a Flight SQL error with code, message, and optional details.
type FlightError struct {
        Code    string                 `json:"code"`
        Message string                 `json:"message"`
        Details map[string]interface{} `json:"details,omitempty"`
        Cause   error                  `json:"-"`
}

// Error implements the error interface.
func (e *FlightError) Error() string <span class="cov5" title="2">{
        if e.Cause != nil </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s: %s (caused by: %v)", e.Code, e.Message, e.Cause)
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%s: %s", e.Code, e.Message)</span>
}

// Unwrap returns the underlying error.
func (e *FlightError) Unwrap() error <span class="cov1" title="1">{
        return e.Cause
}</span>

// Is implements error comparison.
func (e *FlightError) Is(target error) bool <span class="cov10" title="4">{
        t, ok := target.(*FlightError)
        if !ok </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov8" title="3">return e.Code == t.Code</span>
}

// WithDetails adds details to the error.
func (e *FlightError) WithDetails(details map[string]interface{}) *FlightError <span class="cov1" title="1">{
        e.Details = details
        return e
}</span>

// WithDetail adds a single detail to the error.
func (e *FlightError) WithDetail(key string, value interface{}) *FlightError <span class="cov5" title="2">{
        if e.Details == nil </span><span class="cov1" title="1">{
                e.Details = make(map[string]interface{})
        }</span>
        <span class="cov5" title="2">e.Details[key] = value
        return e</span>
}

// Common errors
var (
        ErrInvalidQuery        = &amp;FlightError{Code: CodeInvalidRequest, Message: "invalid query"}
        ErrTransactionNotFound = &amp;FlightError{Code: CodeNotFound, Message: "transaction not found"}
        ErrStatementNotFound   = &amp;FlightError{Code: CodeNotFound, Message: "prepared statement not found"}
        ErrTableNotFound       = &amp;FlightError{Code: CodeNotFound, Message: "table not found"}
        ErrSchemaNotFound      = &amp;FlightError{Code: CodeNotFound, Message: "schema not found"}
        ErrCatalogNotFound     = &amp;FlightError{Code: CodeNotFound, Message: "catalog not found"}
        ErrInvalidTransaction  = &amp;FlightError{Code: CodeInvalidRequest, Message: "invalid transaction"}
        ErrTransactionActive   = &amp;FlightError{Code: CodeAlreadyExists, Message: "transaction already active"}
        ErrConnectionFailed    = &amp;FlightError{Code: CodeUnavailable, Message: "database connection failed"}
        ErrQueryTimeout        = &amp;FlightError{Code: CodeDeadlineExceeded, Message: "query execution timeout"}
        ErrResourceExhausted   = &amp;FlightError{Code: CodeResourceExhausted, Message: "resource limit exceeded"}
        ErrNotImplemented      = &amp;FlightError{Code: CodeUnimplemented, Message: "feature not implemented"}
)

// New creates a new FlightError with the given code and message.
func New(code, message string) *FlightError <span class="cov5" title="2">{
        return &amp;FlightError{
                Code:    code,
                Message: message,
        }
}</span>

// Wrap wraps an error with a FlightError.
func Wrap(err error, code, message string) *FlightError <span class="cov5" title="2">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">return &amp;FlightError{
                Code:    code,
                Message: message,
                Cause:   err,
        }</span>
}

// Wrapf wraps an error with a formatted message.
func Wrapf(err error, code, format string, args ...interface{}) *FlightError <span class="cov5" title="2">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">return &amp;FlightError{
                Code:    code,
                Message: fmt.Sprintf(format, args...),
                Cause:   err,
        }</span>
}

// IsNotFound checks if an error is a not found error.
func IsNotFound(err error) bool <span class="cov8" title="3">{
        var flightErr *FlightError
        if errors.As(err, &amp;flightErr) </span><span class="cov5" title="2">{
                return flightErr.Code == CodeNotFound
        }</span>
        <span class="cov1" title="1">return false</span>
}

// IsInvalidRequest checks if an error is an invalid request error.
func IsInvalidRequest(err error) bool <span class="cov8" title="3">{
        var flightErr *FlightError
        if errors.As(err, &amp;flightErr) </span><span class="cov5" title="2">{
                return flightErr.Code == CodeInvalidRequest
        }</span>
        <span class="cov1" title="1">return false</span>
}

// IsInternal checks if an error is an internal error.
func IsInternal(err error) bool <span class="cov8" title="3">{
        var flightErr *FlightError
        if errors.As(err, &amp;flightErr) </span><span class="cov5" title="2">{
                return flightErr.Code == CodeInternal
        }</span>
        <span class="cov1" title="1">return false</span>
}

// GetCode extracts the error code from an error.
func GetCode(err error) string <span class="cov5" title="2">{
        var flightErr *FlightError
        if errors.As(err, &amp;flightErr) </span><span class="cov1" title="1">{
                return flightErr.Code
        }</span>
        <span class="cov1" title="1">return CodeInternal</span>
}

// GetMessage extracts the error message from an error.
func GetMessage(err error) string <span class="cov5" title="2">{
        var flightErr *FlightError
        if errors.As(err, &amp;flightErr) </span><span class="cov1" title="1">{
                return flightErr.Message
        }</span>
        <span class="cov1" title="1">return err.Error()</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package handlers contains Flight SQL protocol handlers.
package handlers

import (
        "context"
        "fmt"
        "io"
        "regexp"
        "strings"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/array"
        "github.com/apache/arrow-go/v18/arrow/flight"
        "github.com/apache/arrow-go/v18/arrow/memory"
        "github.com/rs/zerolog"

        "github.com/TFMV/porter/pkg/infrastructure/converter"
        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/services"
)

// MetadataHandler handles metadata-related operations.
type metadataHandler struct {
        metadataService services.MetadataService
        allocator       memory.Allocator
        logger          Logger
        metrics         MetricsCollector
}

// NewMetadataHandler creates a new metadata handler.
func NewMetadataHandler(
        metadataService services.MetadataService,
        allocator memory.Allocator,
        logger Logger,
        metrics MetricsCollector,
) MetadataHandler <span class="cov0" title="0">{
        return &amp;metadataHandler{
                metadataService: metadataService,
                allocator:       allocator,
                logger:          logger,
                metrics:         metrics,
        }
}</span>

// GetCatalogs returns available catalogs.
func (h *metadataHandler) GetCatalogs(ctx context.Context) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_get_catalogs")
        defer timer.Stop()

        h.logger.Debug("Getting catalogs")

        catalogs, err := h.metadataService.GetCatalogs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_metadata_errors", "operation", "get_catalogs")
                return nil, nil, fmt.Errorf("failed to get catalogs: %w", err)
        }</span>

        // Create Arrow schema for catalogs
        <span class="cov0" title="0">schema := models.GetCatalogsSchema()

        // Create stream for results
        chunks := make(chan flight.StreamChunk, 1)

        go func() </span><span class="cov0" title="0">{
                defer close(chunks)

                builder := array.NewRecordBuilder(h.allocator, schema)
                defer builder.Release()

                // Build records from catalogs
                for _, catalog := range catalogs </span><span class="cov0" title="0">{
                        builder.Field(0).(*array.StringBuilder).Append(catalog.Name)
                }</span>

                <span class="cov0" title="0">record := builder.NewRecord()
                chunks &lt;- flight.StreamChunk{Data: record}

                h.logger.Info("Catalogs retrieved", "count", len(catalogs))
                h.metrics.RecordHistogram("handler_catalogs_count", float64(len(catalogs)))</span>
        }()

        <span class="cov0" title="0">return schema, chunks, nil</span>
}

// GetSchemas returns schemas matching the filter.
func (h *metadataHandler) GetSchemas(ctx context.Context, catalog *string, schemaPattern *string) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_get_schemas")
        defer timer.Stop()

        h.logger.Debug("Getting schemas", "catalog", catalog, "pattern", schemaPattern)

        // Convert pointers to values for service call
        var catalogValue, patternValue string
        if catalog != nil </span><span class="cov0" title="0">{
                catalogValue = *catalog
        }</span>
        <span class="cov0" title="0">if schemaPattern != nil </span><span class="cov0" title="0">{
                patternValue = *schemaPattern
        }</span>

        <span class="cov0" title="0">schemas, err := h.metadataService.GetSchemas(ctx, catalogValue, patternValue)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_metadata_errors", "operation", "get_schemas")
                return nil, nil, fmt.Errorf("failed to get schemas: %w", err)
        }</span>

        // Create Arrow schema for schemas
        <span class="cov0" title="0">schema := models.GetDBSchemasSchema()

        // Create stream for results
        chunks := make(chan flight.StreamChunk, 1)

        go func() </span><span class="cov0" title="0">{
                defer close(chunks)

                builder := array.NewRecordBuilder(h.allocator, schema)
                defer builder.Release()

                // Build records from schemas
                for _, s := range schemas </span><span class="cov0" title="0">{
                        // catalog_name
                        if s.CatalogName != "" </span><span class="cov0" title="0">{
                                builder.Field(0).(*array.StringBuilder).Append(s.CatalogName)
                        }</span> else<span class="cov0" title="0"> {
                                builder.Field(0).AppendNull()
                        }</span>
                        // db_schema_name
                        <span class="cov0" title="0">builder.Field(1).(*array.StringBuilder).Append(s.Name)</span>
                }

                <span class="cov0" title="0">record := builder.NewRecord()
                chunks &lt;- flight.StreamChunk{Data: record}

                h.logger.Info("Schemas retrieved", "count", len(schemas))
                h.metrics.RecordHistogram("handler_schemas_count", float64(len(schemas)))</span>
        }()

        <span class="cov0" title="0">return schema, chunks, nil</span>
}

// GetTables returns tables matching the filter.
func (h *metadataHandler) GetTables(ctx context.Context, catalog *string, schemaPattern *string, tablePattern *string, tableTypes []string, includeSchema bool) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_get_tables")
        defer timer.Stop()

        h.logger.Debug("Getting tables",
                "catalog", catalog,
                "schema_pattern", schemaPattern,
                "table_pattern", tablePattern,
                "table_types", tableTypes,
                "include_schema", includeSchema)

        opts := models.GetTablesOptions{
                Catalog:                catalog,
                SchemaFilterPattern:    schemaPattern,
                TableNameFilterPattern: tablePattern,
                TableTypes:             tableTypes,
                IncludeSchema:          includeSchema,
        }

        tables, err := h.metadataService.GetTables(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_metadata_errors", "operation", "get_tables")
                return nil, nil, fmt.Errorf("failed to get tables: %w", err)
        }</span>

        // Create Arrow schema for tables
        <span class="cov0" title="0">schema := models.GetTablesSchema(includeSchema)

        // Create stream for results
        chunks := make(chan flight.StreamChunk, 1)

        go func() </span><span class="cov0" title="0">{
                defer close(chunks)

                builder := array.NewRecordBuilder(h.allocator, schema)
                defer builder.Release()

                // Build records from tables
                for _, table := range tables </span><span class="cov0" title="0">{
                        fieldIdx := 0

                        // catalog_name
                        if table.CatalogName != "" </span><span class="cov0" title="0">{
                                builder.Field(fieldIdx).(*array.StringBuilder).Append(table.CatalogName)
                        }</span> else<span class="cov0" title="0"> {
                                builder.Field(fieldIdx).AppendNull()
                        }</span>
                        <span class="cov0" title="0">fieldIdx++

                        // db_schema_name
                        builder.Field(fieldIdx).(*array.StringBuilder).Append(table.SchemaName)
                        fieldIdx++

                        // table_name
                        builder.Field(fieldIdx).(*array.StringBuilder).Append(table.Name)
                        fieldIdx++

                        // table_type
                        builder.Field(fieldIdx).(*array.StringBuilder).Append(table.Type)
                        fieldIdx++

                        // table_schema (if requested)
                        if includeSchema </span><span class="cov0" title="0">{
                                ref := models.TableRef{
                                        Catalog:  &amp;table.CatalogName,
                                        DBSchema: &amp;table.SchemaName,
                                        Table:    table.Name,
                                }
                                tblSchema, err := h.metadataService.GetTableSchema(ctx, ref)
                                if err != nil || tblSchema == nil </span><span class="cov0" title="0">{
                                        builder.Field(fieldIdx).(*array.BinaryBuilder).AppendNull()
                                }</span> else<span class="cov0" title="0"> {
                                        serialized := flight.SerializeSchema(tblSchema, h.allocator)
                                        builder.Field(fieldIdx).(*array.BinaryBuilder).Append(serialized)
                                }</span>
                        }
                }

                <span class="cov0" title="0">record := builder.NewRecord()
                chunks &lt;- flight.StreamChunk{Data: record}

                h.logger.Info("Tables retrieved", "count", len(tables))
                h.metrics.RecordHistogram("handler_tables_count", float64(len(tables)))</span>
        }()

        <span class="cov0" title="0">return schema, chunks, nil</span>
}

// GetColumns returns columns matching the provided patterns.
func (h *metadataHandler) GetColumns(ctx context.Context, catalog *string, schemaPattern *string, tablePattern *string, columnPattern *string) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_get_columns")
        defer timer.Stop()

        h.logger.Debug("Getting columns",
                "catalog", catalog,
                "schema_pattern", schemaPattern,
                "table_pattern", tablePattern,
                "column_pattern", columnPattern,
        )

        // ‚îÄ‚îÄ resolve tables ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        var tables []models.TableRef
        if tablePattern == nil || *tablePattern == "" || strings.ContainsAny(*tablePattern, "%_") </span><span class="cov0" title="0">{
                opts := models.GetTablesOptions{
                        Catalog:                catalog,
                        SchemaFilterPattern:    schemaPattern,
                        TableNameFilterPattern: tablePattern,
                        IncludeSchema:          false,
                }
                tbls, err := h.metadataService.GetTables(ctx, opts)
                if err != nil </span><span class="cov0" title="0">{
                        h.metrics.IncrementCounter("handler_metadata_errors", "operation", "get_columns")
                        return nil, nil, fmt.Errorf("failed to resolve tables: %w", err)
                }</span>
                <span class="cov0" title="0">for _, t := range tbls </span><span class="cov0" title="0">{
                        c := t.CatalogName
                        s := t.SchemaName
                        ref := models.TableRef{Catalog: &amp;c, DBSchema: &amp;s, Table: t.Name}
                        tables = append(tables, ref)
                }</span>
        } else<span class="cov0" title="0"> {
                tables = append(tables, models.TableRef{Catalog: catalog, DBSchema: schemaPattern, Table: *tablePattern})
        }</span>

        // ‚îÄ‚îÄ gather columns ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        <span class="cov0" title="0">var cols []models.Column
        for _, ref := range tables </span><span class="cov0" title="0">{
                c, err := h.metadataService.GetColumns(ctx, ref)
                if err != nil </span><span class="cov0" title="0">{
                        h.metrics.IncrementCounter("handler_metadata_errors", "operation", "get_columns")
                        return nil, nil, fmt.Errorf("failed to get columns: %w", err)
                }</span>
                <span class="cov0" title="0">cols = append(cols, c...)</span>
        }

        // ‚îÄ‚îÄ filter column names ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        <span class="cov0" title="0">if columnPattern != nil &amp;&amp; *columnPattern != "" &amp;&amp; *columnPattern != "%" </span><span class="cov0" title="0">{
                pat := regexp.QuoteMeta(*columnPattern)
                pat = strings.ReplaceAll(pat, "\\%", ".*")
                pat = strings.ReplaceAll(pat, "\\_", ".")
                re := regexp.MustCompile("^" + pat + "$")
                filtered := cols[:0]
                for _, c := range cols </span><span class="cov0" title="0">{
                        if re.MatchString(c.Name) </span><span class="cov0" title="0">{
                                filtered = append(filtered, c)
                        }</span>
                }
                <span class="cov0" title="0">cols = filtered</span>
        }

        <span class="cov0" title="0">schema := models.GetColumnsSchema()
        conv := converter.New(zerolog.New(io.Discard))
        ch := make(chan flight.StreamChunk, 1)

        go func() </span><span class="cov0" title="0">{
                defer close(ch)

                b := array.NewRecordBuilder(h.allocator, schema)
                defer b.Release()

                for _, col := range cols </span><span class="cov0" title="0">{
                        if col.CatalogName != "" </span><span class="cov0" title="0">{
                                b.Field(0).(*array.StringBuilder).Append(col.CatalogName)
                        }</span> else<span class="cov0" title="0"> {
                                b.Field(0).AppendNull()
                        }</span>
                        <span class="cov0" title="0">if col.SchemaName != "" </span><span class="cov0" title="0">{
                                b.Field(1).(*array.StringBuilder).Append(col.SchemaName)
                        }</span> else<span class="cov0" title="0"> {
                                b.Field(1).AppendNull()
                        }</span>
                        <span class="cov0" title="0">b.Field(2).(*array.StringBuilder).Append(col.TableName)
                        b.Field(3).(*array.StringBuilder).Append(col.Name)

                        sqlType := conv.GetSQLType(col.DataType)
                        b.Field(4).(*array.Int32Builder).Append(sqlType)
                        b.Field(5).(*array.StringBuilder).Append(col.DataType)

                        if col.CharMaxLength.Valid </span><span class="cov0" title="0">{
                                b.Field(6).(*array.Int32Builder).Append(int32(col.CharMaxLength.Int64))
                                b.Field(13).(*array.Int32Builder).Append(int32(col.CharMaxLength.Int64))
                        }</span> else<span class="cov0" title="0"> if col.NumericPrecision.Valid </span><span class="cov0" title="0">{
                                b.Field(6).(*array.Int32Builder).Append(int32(col.NumericPrecision.Int64))
                                b.Field(13).AppendNull()
                        }</span> else<span class="cov0" title="0"> {
                                b.Field(6).AppendNull()
                                b.Field(13).AppendNull()
                        }</span>

                        <span class="cov0" title="0">if col.NumericScale.Valid </span><span class="cov0" title="0">{
                                b.Field(7).(*array.Int32Builder).Append(int32(col.NumericScale.Int64))
                        }</span> else<span class="cov0" title="0"> {
                                b.Field(7).AppendNull()
                        }</span>

                        <span class="cov0" title="0">if strings.Contains(strings.ToLower(col.DataType), "int") || strings.Contains(strings.ToLower(col.DataType), "decimal") || strings.Contains(strings.ToLower(col.DataType), "numeric") </span><span class="cov0" title="0">{
                                b.Field(8).(*array.Int32Builder).Append(10)
                        }</span> else<span class="cov0" title="0"> if strings.Contains(strings.ToLower(col.DataType), "float") || strings.Contains(strings.ToLower(col.DataType), "double") || strings.Contains(strings.ToLower(col.DataType), "real") </span><span class="cov0" title="0">{
                                b.Field(8).(*array.Int32Builder).Append(2)
                        }</span> else<span class="cov0" title="0"> {
                                b.Field(8).AppendNull()
                        }</span>

                        <span class="cov0" title="0">if col.IsNullable </span><span class="cov0" title="0">{
                                b.Field(9).(*array.Int32Builder).Append(1)
                        }</span> else<span class="cov0" title="0"> {
                                b.Field(9).(*array.Int32Builder).Append(0)
                        }</span>

                        <span class="cov0" title="0">b.Field(10).AppendNull() // remarks

                        if col.DefaultValue.Valid </span><span class="cov0" title="0">{
                                b.Field(11).(*array.StringBuilder).Append(col.DefaultValue.String)
                        }</span> else<span class="cov0" title="0"> {
                                b.Field(11).AppendNull()
                        }</span>

                        <span class="cov0" title="0">b.Field(12).(*array.Int32Builder).Append(sqlType)

                        b.Field(14).(*array.Int32Builder).Append(int32(col.OrdinalPosition))

                        if col.IsNullable </span><span class="cov0" title="0">{
                                b.Field(15).(*array.StringBuilder).Append("YES")
                        }</span> else<span class="cov0" title="0"> {
                                b.Field(15).(*array.StringBuilder).Append("NO")
                        }</span>

                        <span class="cov0" title="0">b.Field(16).(*array.BooleanBuilder).Append(false) // TODO autoincrement
                        b.Field(17).(*array.BooleanBuilder).Append(false)</span> // TODO generated column
                }

                <span class="cov0" title="0">rec := b.NewRecord()
                ch &lt;- flight.StreamChunk{Data: rec}

                h.logger.Info("Columns retrieved", "count", len(cols))
                h.metrics.RecordHistogram("handler_columns_count", float64(len(cols)))</span>
        }()

        <span class="cov0" title="0">return schema, ch, nil</span>
}

// GetTableTypes returns available table types.
func (h *metadataHandler) GetTableTypes(ctx context.Context) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_get_table_types")
        defer timer.Stop()

        h.logger.Debug("Getting table types")

        tableTypes, err := h.metadataService.GetTableTypes(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_metadata_errors", "operation", "get_table_types")
                return nil, nil, fmt.Errorf("failed to get table types: %w", err)
        }</span>

        // Create Arrow schema for table types
        <span class="cov0" title="0">schema := models.GetTableTypesSchema()

        // Create stream for results
        chunks := make(chan flight.StreamChunk, 1)

        go func() </span><span class="cov0" title="0">{
                defer close(chunks)

                builder := array.NewRecordBuilder(h.allocator, schema)
                defer builder.Release()

                // Build records from table types
                for _, tableType := range tableTypes </span><span class="cov0" title="0">{
                        builder.Field(0).(*array.StringBuilder).Append(tableType)
                }</span>

                <span class="cov0" title="0">record := builder.NewRecord()
                chunks &lt;- flight.StreamChunk{Data: record}

                h.logger.Info("Table types retrieved", "count", len(tableTypes))
                h.metrics.RecordHistogram("handler_table_types_count", float64(len(tableTypes)))</span>
        }()

        <span class="cov0" title="0">return schema, chunks, nil</span>
}

// GetPrimaryKeys returns primary keys for a table.
func (h *metadataHandler) GetPrimaryKeys(ctx context.Context, catalog *string, schema *string, table string) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_get_primary_keys")
        defer timer.Stop()

        h.logger.Debug("Getting primary keys",
                "catalog", catalog,
                "schema", schema,
                "table", table)

        tableRef := models.TableRef{
                Catalog:  catalog,
                DBSchema: schema,
                Table:    table,
        }

        keys, err := h.metadataService.GetPrimaryKeys(ctx, tableRef)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_metadata_errors", "operation", "get_primary_keys")
                return nil, nil, fmt.Errorf("failed to get primary keys: %w", err)
        }</span>

        // Create Arrow schema for primary keys
        <span class="cov0" title="0">arrowSchema := models.GetPrimaryKeysSchema()

        // Create stream for results
        chunks := make(chan flight.StreamChunk, 1)

        go func() </span><span class="cov0" title="0">{
                defer close(chunks)

                builder := array.NewRecordBuilder(h.allocator, arrowSchema)
                defer builder.Release()

                // Build records from keys
                for _, key := range keys </span><span class="cov0" title="0">{
                        // catalog_name
                        if key.CatalogName != "" </span><span class="cov0" title="0">{
                                builder.Field(0).(*array.StringBuilder).Append(key.CatalogName)
                        }</span> else<span class="cov0" title="0"> {
                                builder.Field(0).AppendNull()
                        }</span>

                        // db_schema_name
                        <span class="cov0" title="0">builder.Field(1).(*array.StringBuilder).Append(key.SchemaName)

                        // table_name
                        builder.Field(2).(*array.StringBuilder).Append(key.TableName)

                        // column_name
                        builder.Field(3).(*array.StringBuilder).Append(key.ColumnName)

                        // key_sequence
                        builder.Field(4).(*array.Int32Builder).Append(key.KeySequence)

                        // key_name
                        if key.KeyName != "" </span><span class="cov0" title="0">{
                                builder.Field(5).(*array.StringBuilder).Append(key.KeyName)
                        }</span> else<span class="cov0" title="0"> {
                                builder.Field(5).AppendNull()
                        }</span>
                }

                <span class="cov0" title="0">record := builder.NewRecord()
                chunks &lt;- flight.StreamChunk{Data: record}

                h.logger.Info("Primary keys retrieved", "count", len(keys))
                h.metrics.RecordHistogram("handler_primary_keys_count", float64(len(keys)))</span>
        }()

        <span class="cov0" title="0">return arrowSchema, chunks, nil</span>
}

// GetImportedKeys returns imported foreign keys for a table.
func (h *metadataHandler) GetImportedKeys(ctx context.Context, catalog *string, schema *string, table string) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_get_imported_keys")
        defer timer.Stop()

        h.logger.Debug("Getting imported keys",
                "catalog", catalog,
                "schema", schema,
                "table", table)

        tableRef := models.TableRef{
                Catalog:  catalog,
                DBSchema: schema,
                Table:    table,
        }

        keys, err := h.metadataService.GetImportedKeys(ctx, tableRef)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_metadata_errors", "operation", "get_imported_keys")
                return nil, nil, fmt.Errorf("failed to get imported keys: %w", err)
        }</span>

        // Create Arrow schema for foreign keys
        <span class="cov0" title="0">arrowSchema := models.GetImportedKeysSchema()

        // Create stream for results
        chunks := make(chan flight.StreamChunk, 1)

        go func() </span><span class="cov0" title="0">{
                defer close(chunks)

                record := h.createForeignKeyRecord(arrowSchema, keys)
                chunks &lt;- flight.StreamChunk{Data: record}

                h.logger.Info("Imported keys retrieved", "count", len(keys))
                h.metrics.RecordHistogram("handler_imported_keys_count", float64(len(keys)))
        }</span>()

        <span class="cov0" title="0">return arrowSchema, chunks, nil</span>
}

// GetExportedKeys returns exported foreign keys for a table.
func (h *metadataHandler) GetExportedKeys(ctx context.Context, catalog *string, schema *string, table string) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_get_exported_keys")
        defer timer.Stop()

        h.logger.Debug("Getting exported keys",
                "catalog", catalog,
                "schema", schema,
                "table", table)

        tableRef := models.TableRef{
                Catalog:  catalog,
                DBSchema: schema,
                Table:    table,
        }

        keys, err := h.metadataService.GetExportedKeys(ctx, tableRef)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_metadata_errors", "operation", "get_exported_keys")
                return nil, nil, fmt.Errorf("failed to get exported keys: %w", err)
        }</span>

        // Create Arrow schema for foreign keys
        <span class="cov0" title="0">arrowSchema := models.GetExportedKeysSchema()

        // Create stream for results
        chunks := make(chan flight.StreamChunk, 1)

        go func() </span><span class="cov0" title="0">{
                defer close(chunks)

                record := h.createForeignKeyRecord(arrowSchema, keys)
                chunks &lt;- flight.StreamChunk{Data: record}

                h.logger.Info("Exported keys retrieved", "count", len(keys))
                h.metrics.RecordHistogram("handler_exported_keys_count", float64(len(keys)))
        }</span>()

        <span class="cov0" title="0">return arrowSchema, chunks, nil</span>
}

// GetCrossReference returns foreign key relationships between two tables.
func (h *metadataHandler) GetCrossReference(
        ctx context.Context,
        pkCatalog *string, pkSchema *string, pkTable string,
        fkCatalog *string, fkSchema *string, fkTable string,
) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_get_cross_reference")
        defer timer.Stop()

        h.logger.Debug("Getting cross reference",
                "pk_catalog", pkCatalog,
                "pk_schema", pkSchema,
                "pk_table", pkTable,
                "fk_catalog", fkCatalog,
                "fk_schema", fkSchema,
                "fk_table", fkTable,
        )

        ref := models.CrossTableRef{
                PKRef: models.TableRef{Catalog: pkCatalog, DBSchema: pkSchema, Table: pkTable},
                FKRef: models.TableRef{Catalog: fkCatalog, DBSchema: fkSchema, Table: fkTable},
        }

        keys, err := h.metadataService.GetCrossReference(ctx, ref)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_metadata_errors", "operation", "get_cross_reference")
                return nil, nil, fmt.Errorf("failed to get cross reference: %w", err)
        }</span>

        <span class="cov0" title="0">schema := models.GetForeignKeysSchema()
        ch := make(chan flight.StreamChunk, 1)

        go func() </span><span class="cov0" title="0">{
                defer close(ch)
                rec := h.createForeignKeyRecord(schema, keys)
                ch &lt;- flight.StreamChunk{Data: rec}

                h.logger.Info("Cross reference retrieved", "count", len(keys))
                h.metrics.RecordHistogram("handler_cross_reference_count", float64(len(keys)))
        }</span>()

        <span class="cov0" title="0">return schema, ch, nil</span>
}

// GetXdbcTypeInfo returns XDBC type information.
func (h *metadataHandler) GetXdbcTypeInfo(ctx context.Context, dataType *int32) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_get_xdbc_type_info")
        defer timer.Stop()

        h.logger.Debug("Getting XDBC type info", "data_type", dataType)

        typeInfoList, err := h.metadataService.GetTypeInfo(ctx, dataType)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_metadata_errors", "operation", "get_xdbc_type_info")
                return nil, nil, fmt.Errorf("failed to get XDBC type info: %w", err)
        }</span>

        // Create Arrow schema for type info
        <span class="cov0" title="0">schema := models.GetXdbcTypeInfoSchema()

        // Create stream for results
        chunks := make(chan flight.StreamChunk, 1)

        go func() </span><span class="cov0" title="0">{
                defer close(chunks)

                typeInfoResult := &amp;models.XdbcTypeInfoResult{Types: typeInfoList}
                record := typeInfoResult.ToArrowRecord(h.allocator)
                chunks &lt;- flight.StreamChunk{Data: record}

                h.logger.Info("XDBC type info retrieved")
                h.metrics.IncrementCounter("handler_xdbc_type_info_retrieved")
        }</span>()

        <span class="cov0" title="0">return schema, chunks, nil</span>
}

// GetSqlInfo returns SQL information.
func (h *metadataHandler) GetSqlInfo(ctx context.Context, info []uint32) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_get_sql_info")
        defer timer.Stop()

        h.logger.Debug("Getting SQL info", "info_count", len(info))

        values, err := h.metadataService.GetSQLInfo(ctx, info)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_metadata_errors", "operation", "get_sql_info")
                return nil, nil, fmt.Errorf("failed to get SQL info: %w", err)
        }</span>

        <span class="cov0" title="0">schema := models.GetSqlInfoSchema()
        ch := make(chan flight.StreamChunk, 1)

        go func() </span><span class="cov0" title="0">{
                defer close(ch)

                result := &amp;models.SqlInfoResult{Info: values}
                rec := result.ToArrowRecord(h.allocator)
                ch &lt;- flight.StreamChunk{Data: rec}

                h.logger.Info("SQL info retrieved", "count", len(values))
                h.metrics.IncrementCounter("handler_sql_info_retrieved")
        }</span>()

        <span class="cov0" title="0">return schema, ch, nil</span>
}

// createForeignKeyRecord creates an Arrow record from foreign keys.
func (h *metadataHandler) createForeignKeyRecord(schema *arrow.Schema, keys []models.ForeignKey) arrow.Record <span class="cov0" title="0">{
        builder := array.NewRecordBuilder(h.allocator, schema)
        defer builder.Release()

        for _, key := range keys </span><span class="cov0" title="0">{
                // pk_catalog_name
                if key.PKCatalogName != "" </span><span class="cov0" title="0">{
                        builder.Field(0).(*array.StringBuilder).Append(key.PKCatalogName)
                }</span> else<span class="cov0" title="0"> {
                        builder.Field(0).AppendNull()
                }</span>

                // pk_db_schema_name
                <span class="cov0" title="0">builder.Field(1).(*array.StringBuilder).Append(key.PKSchemaName)

                // pk_table_name
                builder.Field(2).(*array.StringBuilder).Append(key.PKTableName)

                // pk_column_name
                builder.Field(3).(*array.StringBuilder).Append(key.PKColumnName)

                // fk_catalog_name
                if key.FKCatalogName != "" </span><span class="cov0" title="0">{
                        builder.Field(4).(*array.StringBuilder).Append(key.FKCatalogName)
                }</span> else<span class="cov0" title="0"> {
                        builder.Field(4).AppendNull()
                }</span>

                // fk_db_schema_name
                <span class="cov0" title="0">builder.Field(5).(*array.StringBuilder).Append(key.FKSchemaName)

                // fk_table_name
                builder.Field(6).(*array.StringBuilder).Append(key.FKTableName)

                // fk_column_name
                builder.Field(7).(*array.StringBuilder).Append(key.FKColumnName)

                // key_sequence
                builder.Field(8).(*array.Int32Builder).Append(key.KeySequence)

                // fk_key_name
                if key.FKKeyName != "" </span><span class="cov0" title="0">{
                        builder.Field(9).(*array.StringBuilder).Append(key.FKKeyName)
                }</span> else<span class="cov0" title="0"> {
                        builder.Field(9).AppendNull()
                }</span>

                // pk_key_name
                <span class="cov0" title="0">if key.PKKeyName != "" </span><span class="cov0" title="0">{
                        builder.Field(10).(*array.StringBuilder).Append(key.PKKeyName)
                }</span> else<span class="cov0" title="0"> {
                        builder.Field(10).AppendNull()
                }</span>

                // update_rule
                <span class="cov0" title="0">builder.Field(11).(*array.Uint8Builder).Append(uint8(key.UpdateRule))

                // delete_rule
                builder.Field(12).(*array.Uint8Builder).Append(uint8(key.DeleteRule))</span>
        }

        <span class="cov0" title="0">return builder.NewRecord()</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package handlers contains Flight SQL protocol handlers.
package handlers

import (
        "context"
        "fmt"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/array"
        "github.com/apache/arrow-go/v18/arrow/flight"
        "github.com/apache/arrow-go/v18/arrow/memory"

        "github.com/TFMV/porter/pkg/services"
)

// preparedStatementHandler implements PreparedStatementHandler interface.
type preparedStatementHandler struct {
        preparedStatementService services.PreparedStatementService
        queryService             services.QueryService
        allocator                memory.Allocator
        logger                   Logger
        metrics                  MetricsCollector
}

// NewPreparedStatementHandler creates a new prepared statement handler.
func NewPreparedStatementHandler(
        preparedStatementService services.PreparedStatementService,
        queryService services.QueryService,
        allocator memory.Allocator,
        logger Logger,
        metrics MetricsCollector,
) PreparedStatementHandler <span class="cov0" title="0">{
        return &amp;preparedStatementHandler{
                preparedStatementService: preparedStatementService,
                queryService:             queryService,
                allocator:                allocator,
                logger:                   logger,
                metrics:                  metrics,
        }
}</span>

// Create creates a new prepared statement.
func (h *preparedStatementHandler) Create(ctx context.Context, query string, transactionID string) (string, *arrow.Schema, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_prepared_statement_create")
        defer timer.Stop()

        h.logger.Debug("Creating prepared statement",
                "query", truncateQuery(query),
                "transaction_id", transactionID)

        // Create prepared statement
        stmt, err := h.preparedStatementService.Create(ctx, query, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_create_errors")
                h.logger.Error("Failed to create prepared statement", "error", err)
                return "", nil, fmt.Errorf("failed to create prepared statement: %w", err)
        }</span>

        <span class="cov0" title="0">h.logger.Info("Prepared statement created",
                "handle", stmt.Handle,
                "has_parameters", stmt.ParameterSchema != nil)
        h.metrics.IncrementCounter("handler_prepared_statements_created")

        return stmt.Handle, stmt.ResultSetSchema, nil</span>
}

// Close closes a prepared statement.
func (h *preparedStatementHandler) Close(ctx context.Context, handle string) error <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_prepared_statement_close")
        defer timer.Stop()

        h.logger.Debug("Closing prepared statement", "handle", handle)

        if handle == "" </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_invalid_handle")
                return fmt.Errorf("invalid prepared statement handle")
        }</span>

        // Close prepared statement
        <span class="cov0" title="0">if err := h.preparedStatementService.Close(ctx, handle); err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_close_errors")
                h.logger.Error("Failed to close prepared statement", "error", err, "handle", handle)
                return fmt.Errorf("failed to close prepared statement: %w", err)
        }</span>

        <span class="cov0" title="0">h.logger.Info("Prepared statement closed", "handle", handle)
        h.metrics.IncrementCounter("handler_prepared_statements_closed")

        return nil</span>
}

// ExecuteQuery executes a prepared query statement.
func (h *preparedStatementHandler) ExecuteQuery(ctx context.Context, handle string, params arrow.Record) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_prepared_statement_execute_query")
        defer timer.Stop()

        h.logger.Debug("Executing prepared query", "handle", handle)

        if handle == "" </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_invalid_handle")
                return nil, nil, fmt.Errorf("invalid prepared statement handle")
        }</span>

        // Convert Arrow record to parameter values
        <span class="cov0" title="0">paramValues, err := h.extractParameters(params)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_parameter_errors")
                return nil, nil, fmt.Errorf("failed to extract parameters: %w", err)
        }</span>

        // Execute query
        <span class="cov0" title="0">result, err := h.preparedStatementService.ExecuteQuery(ctx, handle, paramValues)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_query_errors")
                h.logger.Error("Failed to execute prepared query", "error", err, "handle", handle)
                return nil, nil, fmt.Errorf("failed to execute prepared query: %w", err)
        }</span>

        // Get schema from result
        <span class="cov0" title="0">schema := result.Schema
        if schema == nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_empty_schema")
                return nil, nil, fmt.Errorf("prepared query returned no schema")
        }</span>

        // Create stream for results
        <span class="cov0" title="0">chunks := make(chan flight.StreamChunk, 16)

        // Start streaming results in background
        go func() </span><span class="cov0" title="0">{
                defer close(chunks)

                recordCount := 0
                for record := range result.Records </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                h.logger.Warn("Prepared query streaming cancelled", "records_sent", recordCount)
                                record.Release()
                                return</span>
                        case chunks &lt;- flight.StreamChunk{Data: record}:<span class="cov0" title="0">
                                recordCount++</span>
                        }
                }

                <span class="cov0" title="0">h.logger.Info("Prepared query streaming completed",
                        "handle", handle,
                        "records_sent", recordCount,
                        "total_rows", result.TotalRows,
                        "execution_time", result.ExecutionTime)

                h.metrics.RecordHistogram("handler_prepared_query_records", float64(recordCount))
                h.metrics.RecordHistogram("handler_prepared_query_duration", result.ExecutionTime.Seconds())</span>
        }()

        <span class="cov0" title="0">return schema, chunks, nil</span>
}

// ExecuteUpdate executes a prepared update statement.
func (h *preparedStatementHandler) ExecuteUpdate(ctx context.Context, handle string, params arrow.Record) (int64, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_prepared_statement_execute_update")
        defer timer.Stop()

        h.logger.Debug("Executing prepared update", "handle", handle)

        if handle == "" </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_invalid_handle")
                return 0, fmt.Errorf("invalid prepared statement handle")
        }</span>

        // Convert Arrow record to parameter values
        <span class="cov0" title="0">paramValues, err := h.extractParameters(params)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_parameter_errors")
                return 0, fmt.Errorf("failed to extract parameters: %w", err)
        }</span>

        // Execute update
        <span class="cov0" title="0">result, err := h.preparedStatementService.ExecuteUpdate(ctx, handle, paramValues)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_update_errors")
                h.logger.Error("Failed to execute prepared update", "error", err, "handle", handle)
                return 0, fmt.Errorf("failed to execute prepared update: %w", err)
        }</span>

        <span class="cov0" title="0">h.logger.Info("Prepared update executed successfully",
                "handle", handle,
                "rows_affected", result.RowsAffected,
                "execution_time", result.ExecutionTime)

        h.metrics.RecordHistogram("handler_prepared_update_rows", float64(result.RowsAffected))
        h.metrics.RecordHistogram("handler_prepared_update_duration", result.ExecutionTime.Seconds())

        return result.RowsAffected, nil</span>
}

// GetSchema returns the schema for a prepared statement.
func (h *preparedStatementHandler) GetSchema(ctx context.Context, handle string) (*arrow.Schema, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_prepared_statement_get_schema")
        defer timer.Stop()

        h.logger.Debug("Getting prepared statement schema", "handle", handle)

        if handle == "" </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_invalid_handle")
                return nil, fmt.Errorf("invalid prepared statement handle")
        }</span>

        // Get prepared statement
        <span class="cov0" title="0">stmt, err := h.preparedStatementService.Get(ctx, handle)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_get_errors")
                h.logger.Error("Failed to get prepared statement", "error", err, "handle", handle)
                return nil, fmt.Errorf("failed to get prepared statement: %w", err)
        }</span>

        <span class="cov0" title="0">if stmt.ResultSetSchema == nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_no_schema")
                return nil, fmt.Errorf("prepared statement has no schema")
        }</span>

        <span class="cov0" title="0">h.logger.Info("Retrieved prepared statement schema", "handle", handle)

        return stmt.ResultSetSchema, nil</span>
}

// GetParameterSchema returns the parameter schema for a prepared statement.
func (h *preparedStatementHandler) GetParameterSchema(ctx context.Context, handle string) (*arrow.Schema, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_prepared_statement_get_parameter_schema")
        defer timer.Stop()

        h.logger.Debug("Getting prepared statement parameter schema", "handle", handle)

        if handle == "" </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_invalid_handle")
                return nil, fmt.Errorf("invalid prepared statement handle")
        }</span>

        // Get prepared statement
        <span class="cov0" title="0">stmt, err := h.preparedStatementService.Get(ctx, handle)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_get_errors")
                h.logger.Error("Failed to get prepared statement", "error", err, "handle", handle)
                return nil, fmt.Errorf("failed to get prepared statement: %w", err)
        }</span>

        // Return parameter schema (may be nil if no parameters)
        <span class="cov0" title="0">if stmt.ParameterSchema == nil </span><span class="cov0" title="0">{
                h.logger.Info("Prepared statement has no parameters", "handle", handle)
                // Return empty schema for statements without parameters
                return arrow.NewSchema([]arrow.Field{}, nil), nil
        }</span>

        <span class="cov0" title="0">h.logger.Info("Retrieved prepared statement parameter schema",
                "handle", handle,
                "num_params", len(stmt.ParameterSchema.Fields()))

        return stmt.ParameterSchema, nil</span>
}

// SetParameters sets/binds parameters for a prepared statement.
func (h *preparedStatementHandler) SetParameters(ctx context.Context, handle string, params arrow.Record) error <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_prepared_statement_set_parameters")
        defer timer.Stop()

        h.logger.Debug("Setting parameters for prepared statement", "handle", handle)

        if handle == "" </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_invalid_handle")
                return fmt.Errorf("invalid prepared statement handle")
        }</span>

        // Convert Arrow record to parameter values
        <span class="cov0" title="0">paramValues, err := h.extractParameters(params)
        if err != nil </span><span class="cov0" title="0">{
                // params record is released by extractParameters if it creates it, or by caller if passed in.
                // Here, params is passed in, so the caller (DoPutPreparedStatementQuery) should release it.
                h.metrics.IncrementCounter("handler_prepared_statement_parameter_errors")
                return fmt.Errorf("failed to extract parameters: %w", err)
        }</span>

        // Call service to set parameters
        <span class="cov0" title="0">if err := h.preparedStatementService.SetParameters(ctx, handle, paramValues); err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_prepared_statement_set_parameters_errors")
                h.logger.Error("Failed to set parameters for prepared statement", "error", err, "handle", handle)
                return fmt.Errorf("failed to set parameters for prepared statement: %w", err)
        }</span>

        <span class="cov0" title="0">h.logger.Info("Parameters set for prepared statement", "handle", handle)
        h.metrics.IncrementCounter("handler_prepared_statement_parameters_set")

        return nil</span>
}

// extractParameters extracts parameter values from an Arrow record.
func (h *preparedStatementHandler) extractParameters(params arrow.Record) ([][]interface{}, error) <span class="cov0" title="0">{
        if params == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">defer params.Release()

        numRows := params.NumRows()
        numCols := params.NumCols()

        // Create result slice
        result := make([][]interface{}, numRows)
        for i := range result </span><span class="cov0" title="0">{
                result[i] = make([]interface{}, numCols)
        }</span>

        // Extract values from each column
        <span class="cov0" title="0">for colIdx := int64(0); colIdx &lt; numCols; colIdx++ </span><span class="cov0" title="0">{
                col := params.Column(int(colIdx))

                for rowIdx := int64(0); rowIdx &lt; numRows; rowIdx++ </span><span class="cov0" title="0">{
                        if col.IsNull(int(rowIdx)) </span><span class="cov0" title="0">{
                                result[rowIdx][colIdx] = nil
                                continue</span>
                        }

                        // Extract value based on column type
                        <span class="cov0" title="0">value, err := h.extractValue(col, int(rowIdx))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to extract value at row %d, col %d: %w", rowIdx, colIdx, err)
                        }</span>
                        <span class="cov0" title="0">result[rowIdx][colIdx] = value</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// extractValue extracts a single value from an Arrow array.
func (h *preparedStatementHandler) extractValue(arr arrow.Array, idx int) (interface{}, error) <span class="cov0" title="0">{
        switch a := arr.(type) </span>{
        case *array.Boolean:<span class="cov0" title="0">
                return a.Value(idx), nil</span>
        case *array.Int8:<span class="cov0" title="0">
                return a.Value(idx), nil</span>
        case *array.Int16:<span class="cov0" title="0">
                return a.Value(idx), nil</span>
        case *array.Int32:<span class="cov0" title="0">
                return a.Value(idx), nil</span>
        case *array.Int64:<span class="cov0" title="0">
                return a.Value(idx), nil</span>
        case *array.Uint8:<span class="cov0" title="0">
                return a.Value(idx), nil</span>
        case *array.Uint16:<span class="cov0" title="0">
                return a.Value(idx), nil</span>
        case *array.Uint32:<span class="cov0" title="0">
                return a.Value(idx), nil</span>
        case *array.Uint64:<span class="cov0" title="0">
                return a.Value(idx), nil</span>
        case *array.Float32:<span class="cov0" title="0">
                return a.Value(idx), nil</span>
        case *array.Float64:<span class="cov0" title="0">
                return a.Value(idx), nil</span>
        case *array.String:<span class="cov0" title="0">
                return a.Value(idx), nil</span>
        case *array.Binary:<span class="cov0" title="0">
                return a.Value(idx), nil</span>
        case *array.Timestamp:<span class="cov0" title="0">
                return a.Value(idx).ToTime(a.DataType().(*arrow.TimestampType).Unit), nil</span>
        case *array.Date32:<span class="cov0" title="0">
                return a.Value(idx).ToTime(), nil</span>
        case *array.Date64:<span class="cov0" title="0">
                return a.Value(idx).ToTime(), nil</span>
        case *array.Time32:<span class="cov0" title="0">
                return a.Value(idx), nil</span>
        case *array.Time64:<span class="cov0" title="0">
                return a.Value(idx), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported array type: %T", arr)</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package handlers contains Flight SQL protocol handlers.
package handlers

import (
        "context"
        stdErrors "errors" // Standard library errors aliased
        "fmt"
        "runtime"
        "time"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/array"
        "github.com/apache/arrow-go/v18/arrow/flight"
        "github.com/apache/arrow-go/v18/arrow/memory"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/known/anypb"

        flightErrors "github.com/TFMV/porter/pkg/errors"
        "github.com/TFMV/porter/pkg/infrastructure/pool"
        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/services"
        flightpb "github.com/apache/arrow-go/v18/arrow/flight/gen/flight"
)

// queryHandler implements QueryHandler interface.
type queryHandler struct {
        queryService services.QueryService
        allocator    memory.Allocator
        logger       Logger
        metrics      MetricsCollector
        recordPool   *pool.FastRecordPool
        schemaCache  *pool.SchemaCache
}

// NewQueryHandler creates a new query handler.
func NewQueryHandler(
        queryService services.QueryService,
        allocator memory.Allocator,
        logger Logger,
        metrics MetricsCollector,
) QueryHandler <span class="cov0" title="0">{
        return &amp;queryHandler{
                queryService: queryService,
                allocator:    allocator,
                logger:       logger,
                metrics:      metrics,
                recordPool:   pool.NewFastRecordPool(allocator),
                schemaCache:  pool.NewSchemaCache(100), // Cache up to 100 schemas
        }
}</span>

// ExecuteStatement executes a SQL statement and returns results.
func (h *queryHandler) ExecuteStatement(ctx context.Context, query string, transactionID string) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_execute_statement")
        defer timer.Stop()

        h.logger.Debug("Executing statement",
                "query", truncateQuery(query),
                "transaction_id", transactionID)

        // Create query request
        req := &amp;models.QueryRequest{
                Query:         query,
                TransactionID: transactionID,
        }

        // Execute query
        result, err := h.queryService.ExecuteQuery(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_query_errors")
                h.logger.Error("Failed to execute query", "error", err)
                return nil, nil, h.mapServiceError(err)
        }</span>

        // Get Arrow schema from result
        <span class="cov0" title="0">schema := result.Schema
        if schema == nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_empty_schema")
                return nil, nil, flightErrors.New(flightErrors.CodeInternal, "query returned no schema")
        }</span>

        // Try to get schema from cache
        <span class="cov0" title="0">if cached, ok := h.schemaCache.Get(schema); ok </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_schema_cache_hit")
                schema = cached
        }</span> else<span class="cov0" title="0"> {
                h.metrics.IncrementCounter("handler_schema_cache_miss")
                h.schemaCache.Put(schema)
        }</span>

        // Create buffered channel for results
        <span class="cov0" title="0">chunks := make(chan flight.StreamChunk, 16)

        // Start streaming results in background
        go func() </span><span class="cov0" title="0">{
                defer close(chunks)

                recordCount := 0
                for record := range result.Records </span><span class="cov0" title="0">{
                        if record == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                h.logger.Warn("Query streaming cancelled", "records_sent", recordCount)
                                record.Release()
                                return</span>
                        case chunks &lt;- flight.StreamChunk{Data: record}:<span class="cov0" title="0">
                                recordCount++</span>
                        }
                }

                <span class="cov0" title="0">h.logger.Info("Query streaming completed",
                        "records_sent", recordCount,
                        "total_rows", result.TotalRows,
                        "execution_time", result.ExecutionTime)

                h.metrics.RecordHistogram("handler_query_records", float64(recordCount))
                h.metrics.RecordHistogram("handler_query_duration", result.ExecutionTime.Seconds())</span>
        }()

        <span class="cov0" title="0">return schema, chunks, nil</span>
}

// ExecuteUpdate executes a SQL update and returns affected rows.
func (h *queryHandler) ExecuteUpdate(ctx context.Context, query string, transactionID string) (int64, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_execute_update")
        defer timer.Stop()

        h.logger.Debug("Executing update",
                "query", truncateQuery(query),
                "transaction_id", transactionID)

        // Create update request
        req := &amp;models.UpdateRequest{
                Statement:     query,
                TransactionID: transactionID,
        }

        // Execute update
        result, err := h.queryService.ExecuteUpdate(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_update_errors")
                h.logger.Error("Failed to execute update", "error", err)
                return 0, h.mapServiceError(err)
        }</span>

        <span class="cov0" title="0">h.logger.Info("Update executed successfully",
                "rows_affected", result.RowsAffected,
                "execution_time", result.ExecutionTime)

        h.metrics.RecordHistogram("handler_update_rows", float64(result.RowsAffected))
        h.metrics.RecordHistogram("handler_update_duration", result.ExecutionTime.Seconds())

        return result.RowsAffected, nil</span>
}

// GetFlightInfo returns flight information for a statement.
func (h *queryHandler) GetFlightInfo(ctx context.Context, query string) (*flightpb.FlightInfo, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_get_flight_info")
        defer timer.Stop()

        h.logger.Debug("Getting flight info", "query", truncateQuery(query))
        h.logger.Info("GetFlightInfo called with query", "query", query)

        if err := h.queryService.ValidateQuery(ctx, query); err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_validation_errors")
                h.logger.Error("Query validation failed", "error", err, "query", query)
                return nil, h.mapServiceError(err)
        }</span>

        // Execute a dummy query to get the schema
        <span class="cov0" title="0">req := &amp;models.QueryRequest{
                Query:   query,
                MaxRows: 0, // We only need the schema
        }
        result, err := h.queryService.ExecuteQuery(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get schema", "error", err, "query", query)
                h.metrics.IncrementCounter("handler_internal_errors")
                return nil, h.mapServiceError(err)
        }</span>

        // Get Arrow schema from result
        <span class="cov0" title="0">schema := result.Schema
        if schema == nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_internal_errors")
                return nil, h.mapServiceError(flightErrors.New(flightErrors.CodeInternal, "schema is nil"))
        }</span>

        // Try to get schema from cache
        <span class="cov0" title="0">if cached, ok := h.schemaCache.Get(schema); ok </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_schema_cache_hit")
                schema = cached
        }</span> else<span class="cov0" title="0"> {
                h.metrics.IncrementCounter("handler_schema_cache_miss")
                h.schemaCache.Put(schema)
        }</span>

        // Build descriptor and ticket following Flight SQL specification
        <span class="cov0" title="0">cmd := &amp;flightpb.CommandStatementQuery{Query: query}

        // Marshal the command into Any protobuf for the descriptor
        var cmdAny anypb.Any
        if err := cmdAny.MarshalFrom(cmd); err != nil </span><span class="cov0" title="0">{
                return nil, h.mapServiceError(err)
        }</span>

        // Serialize the Any protobuf as command bytes
        <span class="cov0" title="0">cmdBytes, err := proto.Marshal(&amp;cmdAny)
        if err != nil </span><span class="cov0" title="0">{
                return nil, h.mapServiceError(err)
        }</span>

        // For the ticket, we need to create a TicketStatementQuery with the query as the statement handle
        // The statement handle should contain the original query, not the protobuf command
        <span class="cov0" title="0">ticketStmt := &amp;flightpb.TicketStatementQuery{StatementHandle: []byte(query)}

        // Marshal the ticket statement into Any protobuf
        var ticketAny anypb.Any
        if err := ticketAny.MarshalFrom(ticketStmt); err != nil </span><span class="cov0" title="0">{
                return nil, h.mapServiceError(err)
        }</span>

        // Serialize the ticket Any protobuf
        <span class="cov0" title="0">ticketBytes, err := proto.Marshal(&amp;ticketAny)
        if err != nil </span><span class="cov0" title="0">{
                return nil, h.mapServiceError(err)
        }</span>

        // Create ticket with the properly formatted ticket bytes
        <span class="cov0" title="0">ticket := &amp;flightpb.Ticket{Ticket: ticketBytes}

        return &amp;flightpb.FlightInfo{
                Schema: flight.SerializeSchema(schema, h.allocator),
                FlightDescriptor: &amp;flightpb.FlightDescriptor{
                        Type: flightpb.FlightDescriptor_CMD,
                        Cmd:  cmdBytes,
                },
                Endpoint: []*flightpb.FlightEndpoint{{
                        Ticket: ticket,
                }},
                TotalRecords: -1,
                TotalBytes:   -1,
        }, nil</span>
}

// mapServiceError maps service errors to appropriate Flight errors.
func (h *queryHandler) mapServiceError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check if it's a FlightError
        <span class="cov0" title="0">var flightErr *flightErrors.FlightError
        if stdErrors.As(err, &amp;flightErr) </span><span class="cov0" title="0">{ // Use aliased standard errors for As
                // Return a new error with just the message content from the FlightError.
                // This avoids the gRPC layer trying to serialize FlightError.Details into a proto.Any
                // if the client isn't equipped to handle custom proto detail types.
                // The specific error code is implicitly mapped by gRPC status codes if this handler
                // is called from a gRPC context that translates errors to statuses.
                switch flightErr.Code </span>{
                case flightErrors.CodeInvalidRequest:<span class="cov0" title="0">
                        return fmt.Errorf("invalid argument: %s", flightErr.Message)</span>
                case flightErrors.CodeNotFound:<span class="cov0" title="0">
                        return fmt.Errorf("not found: %s", flightErr.Message)</span>
                case flightErrors.CodeAlreadyExists:<span class="cov0" title="0">
                        return fmt.Errorf("already exists: %s", flightErr.Message)</span>
                case flightErrors.CodeUnauthorized:<span class="cov0" title="0">
                        return fmt.Errorf("unauthenticated: %s", flightErr.Message)</span>
                case flightErrors.CodePermissionDenied:<span class="cov0" title="0">
                        return fmt.Errorf("permission denied: %s", flightErr.Message)</span>
                case flightErrors.CodeDeadlineExceeded:<span class="cov0" title="0">
                        return fmt.Errorf("deadline exceeded: %s", flightErr.Message)</span>
                case flightErrors.CodeCanceled:<span class="cov0" title="0">
                        return fmt.Errorf("canceled: %s", flightErr.Message)</span>
                case flightErrors.CodeResourceExhausted:<span class="cov0" title="0">
                        return fmt.Errorf("resource exhausted: %s", flightErr.Message)</span>
                case flightErrors.CodeInternal:<span class="cov0" title="0">
                        return fmt.Errorf("internal error: %s", flightErr.Message)</span>
                case flightErrors.CodeUnavailable:<span class="cov0" title="0">
                        return fmt.Errorf("unavailable: %s", flightErr.Message)</span>
                case flightErrors.CodeUnimplemented:<span class="cov0" title="0">
                        return fmt.Errorf("unimplemented: %s", flightErr.Message)</span>
                default:<span class="cov0" title="0">
                        // For unknown FlightError codes, still return a generic message.
                        return fmt.Errorf("unknown error: %s", flightErr.Message)</span>
                }
        }

        // For non-FlightError types, return a generic internal error message, including the original error text.
        <span class="cov0" title="0">return fmt.Errorf("internal error: %w", err)</span>
}

// truncateQuery truncates long queries for logging.
func truncateQuery(query string) string <span class="cov0" title="0">{
        const maxLen = 100
        if len(query) &lt;= maxLen </span><span class="cov0" title="0">{
                return query
        }</span>
        <span class="cov0" title="0">return query[:maxLen] + "..."</span>
}

// ExecuteQueryAndStream executes a query and returns its schema and a channel of StreamChunks.
func (h *queryHandler) ExecuteQueryAndStream(ctx context.Context, query string) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_execute_query_and_stream")
        defer timer.Stop()

        h.logger.Debug("Executing query for streaming", "query", truncateQuery(query))

        // Create query request
        req := &amp;models.QueryRequest{
                Query: query,
        }

        // Execute query
        queryResult, err := h.queryService.ExecuteQuery(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_query_errors")
                h.logger.Error("Failed to execute query", "error", err)
                return nil, nil, h.mapServiceError(err)
        }</span>

        // Get Arrow schema from result
        <span class="cov0" title="0">schema := queryResult.Schema
        if schema == nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_internal_errors")
                return nil, nil, h.mapServiceError(flightErrors.New(flightErrors.CodeInternal, "schema is nil"))
        }</span>

        // Try to get schema from cache
        <span class="cov0" title="0">if cached, ok := h.schemaCache.Get(schema); ok </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_schema_cache_hit")
                schema = cached
        }</span> else<span class="cov0" title="0"> {
                h.metrics.IncrementCounter("handler_schema_cache_miss")
                h.schemaCache.Put(schema)
        }</span>

        // Create output channel for stream chunks with adaptive buffer size
        <span class="cov0" title="0">outCh := make(chan flight.StreamChunk, 32) // Increased buffer for better throughput

        // Start goroutine to stream records
        go func() </span><span class="cov0" title="0">{
                defer close(outCh)

                var (
                        recordCount int
                        batchSize   int = 1024 // Start with reasonable batch size
                        lastGC      time.Time
                )

                // Get initial pooled record
                pooled := h.recordPool.Get(schema)
                if pooled == nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to get pooled record")
                        return
                }</span>
                <span class="cov0" title="0">defer pooled.Release()

                for record := range queryResult.Records </span><span class="cov0" title="0">{
                        if record == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Check memory pressure periodically
                        <span class="cov0" title="0">if time.Since(lastGC) &gt; 5*time.Second </span><span class="cov0" title="0">{
                                var m runtime.MemStats
                                runtime.ReadMemStats(&amp;m)

                                // Adjust batch size based on memory pressure
                                if m.HeapAlloc &gt; m.HeapSys*3/4 </span><span class="cov0" title="0">{ // Over 75% heap usage
                                        batchSize = max(1024, batchSize/2)
                                        runtime.GC() // Force GC to reclaim memory
                                }</span> else<span class="cov0" title="0"> if m.HeapAlloc &lt; m.HeapSys/2 </span><span class="cov0" title="0">{ // Under 50% heap usage
                                        batchSize = min(32768, batchSize*2)
                                }</span>
                                <span class="cov0" title="0">lastGC = time.Now()</span>
                        }

                        // Create a copy of the record using the pool
                        <span class="cov0" title="0">recordCopy := array.NewRecord(
                                schema,
                                record.Columns(),
                                record.NumRows(),
                        )

                        if recordCopy.NumRows() &gt; 0 </span><span class="cov0" title="0">{
                                select </span>{
                                case outCh &lt;- flight.StreamChunk{Data: recordCopy}:<span class="cov0" title="0">
                                        recordCount++
                                        h.metrics.RecordHistogram("handler_record_rows", float64(recordCopy.NumRows()))</span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        h.logger.Info("Context cancelled during chunk send",
                                                "error", ctx.Err(),
                                                "records_sent", recordCount)
                                        recordCopy.Release()
                                        return</span>
                                }
                        } else<span class="cov0" title="0"> {
                                recordCopy.Release()
                        }</span>

                        // Return the pooled record
                        <span class="cov0" title="0">h.recordPool.Put(pooled)
                        pooled = h.recordPool.Get(schema)
                        if pooled == nil </span><span class="cov0" title="0">{
                                h.logger.Error("Failed to get pooled record")
                                return
                        }</span>
                }

                <span class="cov0" title="0">h.logger.Info("Query streaming completed",
                        "records_sent", recordCount)
                h.metrics.RecordHistogram("handler_stream_records", float64(recordCount))

                // Get pool stats
                stats := h.recordPool.Stats()
                h.metrics.RecordHistogram("handler_pool_hits", float64(stats.Hits))
                h.metrics.RecordHistogram("handler_pool_misses", float64(stats.Misses))
                h.metrics.RecordHistogram("handler_pool_allocs", float64(stats.Allocs))</span>
        }()

        <span class="cov0" title="0">return schema, outCh, nil</span>
}

// Helper functions for min/max
func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// ExecuteFromTicket executes a query from a Flight ticket.
func (h *queryHandler) ExecuteFromTicket(ctx context.Context, ticket []byte) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_execute_from_ticket")
        defer timer.Stop()

        // Extract query from ticket
        query := string(ticket)
        if query == "" </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_empty_ticket")
                return nil, nil, flightErrors.New(flightErrors.CodeInvalidRequest, "empty ticket")
        }</span>

        <span class="cov0" title="0">h.logger.Debug("Executing query from ticket", "query", truncateQuery(query))

        // Execute the query
        return h.ExecuteStatement(ctx, query, "")</span>
}

// IsUpdateStatement returns true if the statement should return an update count.
func (h *queryHandler) IsUpdateStatement(query string) bool <span class="cov0" title="0">{
        return h.queryService.IsUpdateStatement(query)
}</span>

// IsQueryStatement returns true if the statement should return a result set.
func (h *queryHandler) IsQueryStatement(query string) bool <span class="cov0" title="0">{
        return h.queryService.IsQueryStatement(query)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package handlers contains Flight SQL protocol handlers.
package handlers

import (
        "context"
        "fmt"

        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/services"
)

// transactionHandler implements TransactionHandler interface.
type transactionHandler struct {
        transactionService services.TransactionService
        logger             Logger
        metrics            MetricsCollector
}

// NewTransactionHandler creates a new transaction handler.
func NewTransactionHandler(
        transactionService services.TransactionService,
        logger Logger,
        metrics MetricsCollector,
) TransactionHandler <span class="cov0" title="0">{
        return &amp;transactionHandler{
                transactionService: transactionService,
                logger:             logger,
                metrics:            metrics,
        }
}</span>

// Begin starts a new transaction.
func (h *transactionHandler) Begin(ctx context.Context, readOnly bool) (string, error) <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_transaction_begin")
        defer timer.Stop()

        h.logger.Debug("Beginning transaction", "read_only", readOnly)

        // Create transaction options
        opts := models.TransactionOptions{
                ReadOnly: readOnly,
                // Isolation level can be set from context or defaults
        }

        // Begin transaction
        txnID, err := h.transactionService.Begin(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_transaction_begin_errors")
                h.logger.Error("Failed to begin transaction", "error", err)
                return "", fmt.Errorf("failed to begin transaction: %w", err)
        }</span>

        <span class="cov0" title="0">h.logger.Info("Transaction started", "transaction_id", txnID)
        h.metrics.IncrementCounter("handler_transactions_started")

        return txnID, nil</span>
}

// Commit commits a transaction.
func (h *transactionHandler) Commit(ctx context.Context, transactionID string) error <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_transaction_commit")
        defer timer.Stop()

        h.logger.Debug("Committing transaction", "transaction_id", transactionID)

        if transactionID == "" </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_transaction_invalid_id")
                return fmt.Errorf("invalid transaction ID")
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err := h.transactionService.Commit(ctx, transactionID); err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_transaction_commit_errors")
                h.logger.Error("Failed to commit transaction", "error", err, "transaction_id", transactionID)
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">h.logger.Info("Transaction committed", "transaction_id", transactionID)
        h.metrics.IncrementCounter("handler_transactions_committed")

        return nil</span>
}

// Rollback rolls back a transaction.
func (h *transactionHandler) Rollback(ctx context.Context, transactionID string) error <span class="cov0" title="0">{
        timer := h.metrics.StartTimer("handler_transaction_rollback")
        defer timer.Stop()

        h.logger.Debug("Rolling back transaction", "transaction_id", transactionID)

        if transactionID == "" </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_transaction_invalid_id")
                return fmt.Errorf("invalid transaction ID")
        }</span>

        // Rollback transaction
        <span class="cov0" title="0">if err := h.transactionService.Rollback(ctx, transactionID); err != nil </span><span class="cov0" title="0">{
                h.metrics.IncrementCounter("handler_transaction_rollback_errors")
                h.logger.Error("Failed to rollback transaction", "error", err, "transaction_id", transactionID)
                return fmt.Errorf("failed to rollback transaction: %w", err)
        }</span>

        <span class="cov0" title="0">h.logger.Info("Transaction rolled back", "transaction_id", transactionID)
        h.metrics.IncrementCounter("handler_transactions_rolled_back")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package converter provides type conversion between DuckDB and Apache Arrow.
package converter

import (
        "database/sql"
        "reflect"
        "strconv"
        "sync/atomic"
        "time"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/array"
        "github.com/apache/arrow-go/v18/arrow/memory"
        "github.com/rs/zerolog"

        "github.com/TFMV/porter/pkg/errors"
)

const defaultBatchSize = 1024

// BatchReader reads SQL rows and converts them to Arrow record batches.
type BatchReader struct {
        refCount  atomic.Int64
        schema    *arrow.Schema
        rows      *sql.Rows
        record    arrow.Record
        builder   *array.RecordBuilder
        allocator memory.Allocator
        err       error
        rowDest   []interface{}
        logger    zerolog.Logger
        batchSize int
}

// NewBatchReader creates a new batch reader from SQL rows.
func NewBatchReader(allocator memory.Allocator, rows *sql.Rows, logger zerolog.Logger) (*BatchReader, error) <span class="cov0" title="0">{
        cols, err := rows.ColumnTypes()
        if err != nil </span><span class="cov0" title="0">{
                rows.Close()
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to get column types")
        }</span>

        <span class="cov0" title="0">tc := New(logger)
        fields := make([]arrow.Field, len(cols))
        rowDest := make([]interface{}, len(cols))

        for i, col := range cols </span><span class="cov0" title="0">{
                field, err := tc.GetArrowFieldFromColumn(col)
                if err != nil </span><span class="cov0" title="0">{
                        rows.Close()
                        return nil, errors.Wrapf(err, errors.CodeInternal, "failed to convert column %d", i)
                }</span>
                <span class="cov0" title="0">fields[i] = field

                // Create destination based on field type and nullability
                rowDest[i] = createScanDest(field)</span>
        }

        <span class="cov0" title="0">schema := arrow.NewSchema(fields, nil)

        r := &amp;BatchReader{
                schema:    schema,
                rows:      rows,
                builder:   array.NewRecordBuilder(allocator, schema),
                allocator: allocator,
                rowDest:   rowDest,
                logger:    logger,
                batchSize: defaultBatchSize,
        }

        // Initialize refCount to 1
        r.refCount.Store(1)

        return r, nil</span>
}

// NewBatchReaderWithSchema creates a new batch reader with a predefined schema.
func NewBatchReaderWithSchema(allocator memory.Allocator, schema *arrow.Schema, rows *sql.Rows, logger zerolog.Logger) (*BatchReader, error) <span class="cov0" title="0">{
        rowDest := make([]interface{}, schema.NumFields())

        for i, field := range schema.Fields() </span><span class="cov0" title="0">{
                rowDest[i] = createScanDest(field)
        }</span>

        <span class="cov0" title="0">r := &amp;BatchReader{
                schema:    schema,
                rows:      rows,
                builder:   array.NewRecordBuilder(allocator, schema),
                allocator: allocator,
                rowDest:   rowDest,
                logger:    logger,
                batchSize: defaultBatchSize,
        }

        // Initialize refCount to 1
        r.refCount.Store(1)

        return r, nil</span>
}

// SetBatchSize sets the number of rows to read per batch.
func (r *BatchReader) SetBatchSize(size int) <span class="cov0" title="0">{
        if size &gt; 0 </span><span class="cov0" title="0">{
                r.batchSize = size
        }</span>
}

// Schema returns the Arrow schema.
func (r *BatchReader) Schema() *arrow.Schema <span class="cov0" title="0">{
        return r.schema
}</span>

// Retain increases the reference count.
func (r *BatchReader) Retain() <span class="cov0" title="0">{
        r.refCount.Add(1)
}</span>

// Release decreases the reference count and cleans up when it reaches 0.
func (r *BatchReader) Release() <span class="cov0" title="0">{
        if r.refCount.Add(-1) == 0 </span><span class="cov0" title="0">{
                r.cleanup()
        }</span>
}

// cleanup releases all resources.
func (r *BatchReader) cleanup() <span class="cov0" title="0">{
        if r.rows != nil </span><span class="cov0" title="0">{
                r.rows.Close()
                r.rows = nil
        }</span>
        <span class="cov0" title="0">if r.builder != nil </span><span class="cov0" title="0">{
                r.builder.Release()
                r.builder = nil
        }</span>
        <span class="cov0" title="0">if r.record != nil </span><span class="cov0" title="0">{
                r.logger.Debug().
                        Int("record_num_cols_in_cleanup_before_nil", int(r.record.NumCols())).
                        Msg("BatchReader.cleanup: r.record is not nil, but will not be released here. Setting to nil.")
                r.record = nil // Ensure we don't hold a reference after cleanup.
        }</span>
}

// Record returns the current record batch.
func (r *BatchReader) Record() arrow.Record <span class="cov0" title="0">{
        if r.record == nil </span><span class="cov0" title="0">{
                r.logger.Debug().Msg("BatchReader.Record() called, r.record is nil")
                return nil
        }</span>

        // Return a NewSlice. This creates a new Record instance with its own
        // .columns metadata, sharing the underlying (ref-counted) array data.
        // This prevents the BatchReader's internal r.record.Release() in the next
        // r.Next() call from nilling out the columns of the record instance
        // that the consumer (ExecuteQueryStream) has.

        // Create the slice - this will automatically retain the columns
        <span class="cov0" title="0">newRecSlice := r.record.NewSlice(0, r.record.NumRows())

        r.logger.Debug().
                Int("slice_num_cols", int(newRecSlice.NumCols())).
                Int("slice_schema_fields", newRecSlice.Schema().NumFields()).
                Int64("slice_num_rows", newRecSlice.NumRows()).
                Msg("BatchReader.Record: State of newRecSlice before returning")

        return newRecSlice</span>
}

// Err returns any error that occurred during reading.
func (r *BatchReader) Err() error <span class="cov0" title="0">{
        return r.err
}</span>

// Next reads the next batch of rows.
func (r *BatchReader) Next() bool <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if r.record != nil </span><span class="cov0" title="0">{
                r.logger.Debug().
                        Int("internal_rec_num_cols_pre_release", int(r.record.NumCols())).
                        Int64("internal_rec_num_rows_pre_release", r.record.NumRows()).
                        Msg("BatchReader.Next: State of internal r.record before Release")
                r.record.Release()
                r.record = nil
        }</span>

        // DIAGNOSTIC: Release and create a new builder for each record batch (even if batch is 1 row)
        <span class="cov0" title="0">if r.builder != nil </span><span class="cov0" title="0">{
                r.builder.Release()
        }</span>
        <span class="cov0" title="0">r.builder = array.NewRecordBuilder(r.allocator, r.schema)
        // Ensure the new builder is retained if the BatchReader itself is retained.
        // No, builder itself doesn't have Retain/Release like a Record/Array.

        rowsProcessedInBatch := 0
        for i := 0; i &lt; r.batchSize; i++ </span><span class="cov0" title="0">{
                if !r.rows.Next() </span><span class="cov0" title="0">{
                        if i == 0 </span><span class="cov0" title="0">{ // No rows were read in this attempt to fill a batch
                                r.err = r.rows.Err()
                                if r.err == nil </span><span class="cov0" title="0">{ // No error, but no rows means end of result set
                                        r.logger.Debug().Msg("BatchReader.Next: No more rows in r.rows.Next(), end of data.")
                                        // r.cleanup() // No, cleanup is for when the whole reader is done.
                                }</span>
                                <span class="cov0" title="0">return false</span> // No rows in this batch, and no more rows available
                        }
                        <span class="cov0" title="0">break</span> // End of result set, but some rows were processed for this batch
                }

                <span class="cov0" title="0">if err := r.rows.Scan(r.rowDest...); err != nil </span><span class="cov0" title="0">{
                        r.err = errors.Wrap(err, errors.CodeQueryFailed, "failed to scan row")
                        return false
                }</span>

                <span class="cov0" title="0">for colIdx, val := range r.rowDest </span><span class="cov0" title="0">{
                        if err := r.appendValue(colIdx, val); err != nil </span><span class="cov0" title="0">{
                                r.err = errors.Wrapf(err, errors.CodeInternal, "failed to append value for column %d", colIdx)
                                return false
                        }</span>
                }
                <span class="cov0" title="0">rowsProcessedInBatch++</span>
        }

        <span class="cov0" title="0">if rowsProcessedInBatch &gt; 0 </span><span class="cov0" title="0">{
                r.record = r.builder.NewRecord()
                r.logger.Debug().
                        Int("rows_in_batch", rowsProcessedInBatch).
                        Int("record_num_cols_at_creation", int(r.record.NumCols())).
                        Int("record_schema_fields_at_creation", r.record.Schema().NumFields()).
                        Msg("Read batch and created record (with new builder each time - DIAGNOSTIC)")
        }</span> else<span class="cov0" title="0"> {
                // This case should be caught by r.rows.Next() returning false earlier if no rows were processed.
                // If we reach here, it implies batchSize might be 0 or an issue in loop logic.
                r.logger.Debug().Msg("BatchReader.Next: No rows processed in the current batch attempt.")
                return false // No rows were actually processed to form a record
        }</span>

        <span class="cov0" title="0">if err := r.rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.err = err
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// appendValue appends a scanned value to the appropriate builder.
func (r *BatchReader) appendValue(colIdx int, value interface{}) error <span class="cov0" title="0">{
        fb := r.builder.Field(colIdx)

        switch v := value.(type) </span>{
        case *bool:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.BooleanBuilder).Append(*v)
                }</span>
        case *sql.NullBool:<span class="cov0" title="0">
                if !v.Valid </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.BooleanBuilder).Append(v.Bool)
                }</span>

        case *int8:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.Int8Builder).Append(*v)
                }</span>
        case *uint8:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.Uint8Builder).Append(*v)
                }</span>
        case *sql.NullByte:<span class="cov0" title="0">
                if !v.Valid </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.Uint8Builder).Append(v.Byte)
                }</span>

        case *int16:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.Int16Builder).Append(*v)
                }</span>
        case *uint16:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.Uint16Builder).Append(*v)
                }</span>
        case *sql.NullInt16:<span class="cov0" title="0">
                if !v.Valid </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.Int16Builder).Append(v.Int16)
                }</span>

        case *int32:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.Int32Builder).Append(*v)
                }</span>
        case *uint32:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.Uint32Builder).Append(*v)
                }</span>
        case *sql.NullInt32:<span class="cov0" title="0">
                if !v.Valid </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.Int32Builder).Append(v.Int32)
                }</span>

        case *int64:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.Int64Builder).Append(*v)
                }</span>
        case *uint64:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.Uint64Builder).Append(*v)
                }</span>
        case *sql.NullInt64:<span class="cov0" title="0">
                if !v.Valid </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.Int64Builder).Append(v.Int64)
                }</span>

        case *float32:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.Float32Builder).Append(*v)
                }</span>
        case *float64:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.Float64Builder).Append(*v)
                }</span>
        case *sql.NullFloat64:<span class="cov0" title="0">
                if !v.Valid </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        switch b := fb.(type) </span>{
                        case *array.Float64Builder:<span class="cov0" title="0">
                                b.Append(v.Float64)</span>
                        case *array.Float32Builder:<span class="cov0" title="0">
                                b.Append(float32(v.Float64))</span>
                        default:<span class="cov0" title="0">
                                return errors.New(errors.CodeInternal, "unexpected builder type for float")</span>
                        }
                }

        case *string:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.StringBuilder).Append(*v)
                }</span>
        case *sql.NullString:<span class="cov0" title="0">
                if !v.Valid </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.StringBuilder).Append(v.String)
                }</span>

        case *[]byte:<span class="cov0" title="0">
                if v == nil || *v == nil </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        fb.(*array.BinaryBuilder).Append(*v)
                }</span>

        case *time.Time:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        if err := appendTimeValue(fb, *v); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case *sql.NullTime:<span class="cov0" title="0">
                if !v.Valid </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        if err := appendTimeValue(fb, v.Time); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        case *interface{}:<span class="cov0" title="0">
                // Handle dynamic types
                if v == nil || *v == nil </span><span class="cov0" title="0">{
                        fb.AppendNull()
                }</span> else<span class="cov0" title="0"> {
                        return appendDynamicValue(fb, *v)
                }</span>

        default:<span class="cov0" title="0">
                return errors.New(errors.CodeInternal, "unsupported scan type: "+reflect.TypeOf(value).String())</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// createScanDest creates an appropriate scan destination based on the Arrow field type.
func createScanDest(field arrow.Field) interface{} <span class="cov0" title="0">{
        switch field.Type.ID() </span>{
        case arrow.BOOL:<span class="cov0" title="0">
                if field.Nullable </span><span class="cov0" title="0">{
                        return &amp;sql.NullBool{}
                }</span>
                <span class="cov0" title="0">return new(bool)</span>

        case arrow.INT8:<span class="cov0" title="0">
                if field.Nullable </span><span class="cov0" title="0">{
                        return &amp;sql.NullByte{}
                }</span>
                <span class="cov0" title="0">return new(int8)</span>

        case arrow.UINT8:<span class="cov0" title="0">
                if field.Nullable </span><span class="cov0" title="0">{
                        return &amp;sql.NullByte{}
                }</span>
                <span class="cov0" title="0">return new(uint8)</span>

        case arrow.INT16:<span class="cov0" title="0">
                if field.Nullable </span><span class="cov0" title="0">{
                        return &amp;sql.NullInt16{}
                }</span>
                <span class="cov0" title="0">return new(int16)</span>

        case arrow.UINT16:<span class="cov0" title="0">
                if field.Nullable </span><span class="cov0" title="0">{
                        // No sql.NullUint16, use pointer
                        return new(*uint16)
                }</span>
                <span class="cov0" title="0">return new(uint16)</span>

        case arrow.INT32:<span class="cov0" title="0">
                if field.Nullable </span><span class="cov0" title="0">{
                        return &amp;sql.NullInt32{}
                }</span>
                <span class="cov0" title="0">return new(int32)</span>

        case arrow.UINT32:<span class="cov0" title="0">
                if field.Nullable </span><span class="cov0" title="0">{
                        // No sql.NullUint32, use pointer
                        return new(*uint32)
                }</span>
                <span class="cov0" title="0">return new(uint32)</span>

        case arrow.INT64:<span class="cov0" title="0">
                if field.Nullable </span><span class="cov0" title="0">{
                        return &amp;sql.NullInt64{}
                }</span>
                <span class="cov0" title="0">return new(int64)</span>

        case arrow.UINT64:<span class="cov0" title="0">
                if field.Nullable </span><span class="cov0" title="0">{
                        // No sql.NullUint64, use pointer
                        return new(*uint64)
                }</span>
                <span class="cov0" title="0">return new(uint64)</span>

        case arrow.FLOAT32:<span class="cov0" title="0">
                if field.Nullable </span><span class="cov0" title="0">{
                        return &amp;sql.NullFloat64{} // Will convert
                }</span>
                <span class="cov0" title="0">return new(float32)</span>

        case arrow.FLOAT64:<span class="cov0" title="0">
                if field.Nullable </span><span class="cov0" title="0">{
                        return &amp;sql.NullFloat64{}
                }</span>
                <span class="cov0" title="0">return new(float64)</span>

        case arrow.STRING:<span class="cov0" title="0">
                if field.Nullable </span><span class="cov0" title="0">{
                        return &amp;sql.NullString{}
                }</span>
                <span class="cov0" title="0">return new(string)</span>

        case arrow.BINARY:<span class="cov0" title="0">
                var b []byte
                return &amp;b</span>

        case arrow.DATE32, arrow.DATE64, arrow.TIME32, arrow.TIME64, arrow.TIMESTAMP:<span class="cov0" title="0">
                if field.Nullable </span><span class="cov0" title="0">{
                        return &amp;sql.NullTime{}
                }</span>
                <span class="cov0" title="0">return new(time.Time)</span>

        case arrow.DECIMAL, arrow.DECIMAL256:<span class="cov0" title="0">
                // Handle decimal as string for now
                if field.Nullable </span><span class="cov0" title="0">{
                        return &amp;sql.NullString{}
                }</span>
                <span class="cov0" title="0">return new(string)</span>

        default:<span class="cov0" title="0">
                // For unknown types, use interface{}
                return new(interface{})</span>
        }
}

// appendTimeValue appends a time value to the appropriate builder.
func appendTimeValue(fb array.Builder, t time.Time) error <span class="cov0" title="0">{
        switch b := fb.(type) </span>{
        case *array.Date32Builder:<span class="cov0" title="0">
                // Date32 is days since Unix epoch
                days := int32(t.Unix() / 86400)
                b.Append(arrow.Date32(days))</span>

        case *array.Date64Builder:<span class="cov0" title="0">
                // Date64 is milliseconds since Unix epoch
                b.Append(arrow.Date64(t.UnixMilli()))</span>

        case *array.Time32Builder:<span class="cov0" title="0">
                // Time32 seconds since midnight
                seconds := t.Hour()*3600 + t.Minute()*60 + t.Second()
                b.Append(arrow.Time32(seconds))</span>

        case *array.Time64Builder:<span class="cov0" title="0">
                // Time64 microseconds since midnight
                micros := int64(t.Hour())*3600000000 + int64(t.Minute())*60000000 +
                        int64(t.Second())*1000000 + int64(t.Nanosecond())/1000
                b.Append(arrow.Time64(micros))</span>

        case *array.TimestampBuilder:<span class="cov0" title="0">
                // Timestamp microseconds since Unix epoch
                b.Append(arrow.Timestamp(t.UnixMicro()))</span>

        default:<span class="cov0" title="0">
                return errors.New(errors.CodeInternal, "unexpected builder type for time value")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// appendDynamicValue appends a dynamically typed value.
func appendDynamicValue(fb array.Builder, value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                fb.AppendNull()
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case bool:<span class="cov0" title="0">
                fb.(*array.BooleanBuilder).Append(v)</span>
        case int64:<span class="cov0" title="0">
                fb.(*array.Int64Builder).Append(v)</span>
        case float64:<span class="cov0" title="0">
                fb.(*array.Float64Builder).Append(v)</span>
        case string:<span class="cov0" title="0">
                fb.(*array.StringBuilder).Append(v)</span>
        case []byte:<span class="cov0" title="0">
                fb.(*array.BinaryBuilder).Append(v)</span>
        case time.Time:<span class="cov0" title="0">
                return appendTimeValue(fb, v)</span>
        default:<span class="cov0" title="0">
                // Try to convert to string
                fb.(*array.StringBuilder).Append(toString(v))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// toString converts a value to string.
func toString(v interface{}) string <span class="cov0" title="0">{
        switch val := v.(type) </span>{
        case string:<span class="cov0" title="0">
                return val</span>
        case []byte:<span class="cov0" title="0">
                return string(val)</span>
        case int:<span class="cov0" title="0">
                return strconv.Itoa(val)</span>
        case int64:<span class="cov0" title="0">
                return strconv.FormatInt(val, 10)</span>
        case float64:<span class="cov0" title="0">
                return strconv.FormatFloat(val, 'f', -1, 64)</span>
        case bool:<span class="cov0" title="0">
                return strconv.FormatBool(val)</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package converter provides type conversion between DuckDB and Apache Arrow.
package converter

import (
        "database/sql"
        "fmt"
        "reflect"
        "regexp"
        "strconv"
        "strings"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/rs/zerolog"

        "github.com/TFMV/porter/pkg/errors"
)

// TypeConverter handles type conversions between DuckDB and Arrow.
type TypeConverter interface {
        // DuckDB to Arrow conversions
        DuckDBToArrowType(duckdbType string) (arrow.DataType, error)
        DuckDBToArrowValue(value interface{}, arrowType arrow.DataType) (interface{}, error)

        // Arrow to DuckDB conversions
        ArrowToDuckDBType(arrowType arrow.DataType) (string, error)
        ArrowToDuckDBValue(value interface{}, duckdbType string) (interface{}, error)

        // SQL type mappings
        GetSQLType(duckdbType string) int32
        GetArrowFieldFromColumn(col *sql.ColumnType) (arrow.Field, error)

        // Schema conversion
        ConvertToArrowSchema(cols []*sql.ColumnType) (*arrow.Schema, error)
}

type typeConverter struct {
        typeMap    map[string]arrow.DataType
        reverseMap map[arrow.Type]string
        sqlMap     map[string]int32
        logger     zerolog.Logger
}

// New creates a new type converter.
func New(logger zerolog.Logger) TypeConverter <span class="cov1" title="1">{
        tc := &amp;typeConverter{
                typeMap:    initializeTypeMap(),
                reverseMap: initializeReverseMap(),
                sqlMap:     initializeSQLMap(),
                logger:     logger,
        }

        return tc
}</span>

// ConvertDuckDBTypeToArrow converts a DuckDB type string to an Apache Arrow DataType.
func ConvertDuckDBTypeToArrow(duckdbType string) (arrow.DataType, error) <span class="cov3" title="2">{
        // Handle decimal or numeric types
        if strings.HasPrefix(duckdbType, "decimal") || strings.HasPrefix(duckdbType, "numeric") </span><span class="cov1" title="1">{
                // Default precision and scale
                precision := int32(38)
                scale := int32(4)

                // Regular expression to match decimal(p,s) or numeric(p,s)
                // Example: decimal(18,2) or numeric(10,3)
                re := regexp.MustCompile(`^(decimal|numeric)\((\d+),(\d+)\)$`)
                matches := re.FindStringSubmatch(strings.ToLower(duckdbType))

                if len(matches) == 4 </span><span class="cov1" title="1">{
                        // Parse precision
                        p, err := strconv.ParseInt(matches[2], 10, 32)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid precision in %s: %w", duckdbType, err)
                        }</span>
                        // Parse scale
                        <span class="cov1" title="1">s, err := strconv.ParseInt(matches[3], 10, 32)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid scale in %s: %w", duckdbType, err)
                        }</span>

                        // Validate precision and scale
                        <span class="cov1" title="1">if p &lt; 1 || p &gt; 38 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("precision %d out of range (1-38) for %s", p, duckdbType)
                        }</span>
                        <span class="cov1" title="1">if s &lt; 0 || s &gt; p </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("scale %d out of range (0-%d) for %s", s, p, duckdbType)
                        }</span>

                        <span class="cov1" title="1">precision = int32(p)
                        scale = int32(s)</span>
                } else<span class="cov0" title="0"> if len(matches) != 0 </span><span class="cov0" title="0">{
                        // If the format is invalid but starts with decimal/numeric
                        return nil, fmt.Errorf("invalid decimal/numeric format: %s", duckdbType)
                }</span>

                // Return Decimal128Type with parsed or default precision and scale
                <span class="cov1" title="1">return &amp;arrow.Decimal128Type{Precision: precision, Scale: scale}, nil</span>
        }

        // Handle other types (placeholder for additional type handling)
        <span class="cov1" title="1">return nil, fmt.Errorf("unsupported DuckDB type: %s", duckdbType)</span>
}

// ArrowToDuckDBType converts an Arrow type to a DuckDB type.
func (tc *typeConverter) ArrowToDuckDBType(arrowType arrow.DataType) (string, error) <span class="cov7" title="9">{
        if duckdbType, ok := tc.reverseMap[arrowType.ID()]; ok </span><span class="cov7" title="8">{
                return duckdbType, nil
        }</span>

        // Handle special cases
        <span class="cov1" title="1">switch arrowType.ID() </span>{
        case arrow.DECIMAL, arrow.DECIMAL256:<span class="cov1" title="1">
                decimalType := arrowType.(arrow.DecimalType)
                return fmt.Sprintf("DECIMAL(%d,%d)", decimalType.GetPrecision(), decimalType.GetScale()), nil</span>
        case arrow.FIXED_SIZE_BINARY:<span class="cov0" title="0">
                fixedType := arrowType.(*arrow.FixedSizeBinaryType)
                return fmt.Sprintf("BLOB(%d)", fixedType.ByteWidth), nil</span>
        case arrow.LIST:<span class="cov0" title="0">
                elemType, err := tc.ArrowToDuckDBType(arrowType.(*arrow.ListType).Elem())
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%s[]", elemType), nil</span>
        case arrow.STRUCT:<span class="cov0" title="0">
                // Handle struct types
                return "STRUCT", nil</span>
        default:<span class="cov0" title="0">
                return "", errors.New(errors.CodeInternal, fmt.Sprintf("unsupported Arrow type: %s", arrowType))</span>
        }
}

// GetSQLType returns the SQL type code for a DuckDB type.
func (tc *typeConverter) GetSQLType(duckdbType string) int32 <span class="cov10" title="17">{
        duckdbType = strings.ToLower(strings.TrimSpace(duckdbType))

        if sqlType, ok := tc.sqlMap[duckdbType]; ok </span><span class="cov9" title="16">{
                return sqlType
        }</span>

        // Default to VARCHAR for unknown types
        <span class="cov1" title="1">return int32(java_sql_Types_VARCHAR)</span>
}

// GetArrowFieldFromColumn converts a SQL column to an Arrow field.
func (tc *typeConverter) GetArrowFieldFromColumn(col *sql.ColumnType) (arrow.Field, error) <span class="cov0" title="0">{
        // Get Arrow type
        arrowType, err := tc.getArrowTypeFromColumnType(col)
        if err != nil </span><span class="cov0" title="0">{
                return arrow.Field{}, err
        }</span>

        // Build metadata
        <span class="cov0" title="0">metadata := tc.buildColumnMetadata(col)

        // Get nullability
        nullable, _ := col.Nullable()

        // Create field
        field := arrow.Field{
                Name:     col.Name(),
                Type:     arrowType,
                Nullable: nullable,
                Metadata: metadata,
        }

        return field, nil</span>
}

// ConvertToArrowSchema converts SQL column types to an Arrow schema.
func (tc *typeConverter) ConvertToArrowSchema(cols []*sql.ColumnType) (*arrow.Schema, error) <span class="cov0" title="0">{
        fields := make([]arrow.Field, len(cols))

        for i, col := range cols </span><span class="cov0" title="0">{
                field, err := tc.GetArrowFieldFromColumn(col)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, errors.CodeInternal, "failed to convert column %d", i)
                }</span>
                <span class="cov0" title="0">fields[i] = field</span>
        }

        <span class="cov0" title="0">return arrow.NewSchema(fields, nil), nil</span>
}

// getArrowTypeFromColumnType determines Arrow type from SQL column type.
func (tc *typeConverter) getArrowTypeFromColumnType(col *sql.ColumnType) (arrow.DataType, error) <span class="cov0" title="0">{
        // First try database type name
        dbType := col.DatabaseTypeName()
        if dbType != "" </span><span class="cov0" title="0">{
                return tc.DuckDBToArrowType(dbType)
        }</span>

        // Fall back to scan type
        <span class="cov0" title="0">scanType := col.ScanType()
        if scanType == nil </span><span class="cov0" title="0">{
                // Default to string if we can't determine type
                return arrow.BinaryTypes.String, nil
        }</span>

        // Map Go types to Arrow types
        <span class="cov0" title="0">switch scanType.Kind() </span>{
        case reflect.Bool:<span class="cov0" title="0">
                return arrow.FixedWidthTypes.Boolean, nil</span>
        case reflect.Int8:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Int8, nil</span>
        case reflect.Int16:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Int16, nil</span>
        case reflect.Int32:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Int32, nil</span>
        case reflect.Int, reflect.Int64:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Int64, nil</span>
        case reflect.Uint8:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Uint8, nil</span>
        case reflect.Uint16:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Uint16, nil</span>
        case reflect.Uint32:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Uint32, nil</span>
        case reflect.Uint, reflect.Uint64:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Uint64, nil</span>
        case reflect.Float32:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Float32, nil</span>
        case reflect.Float64:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Float64, nil</span>
        case reflect.String:<span class="cov0" title="0">
                return arrow.BinaryTypes.String, nil</span>
        case reflect.Slice:<span class="cov0" title="0">
                if scanType.Elem().Kind() == reflect.Uint8 </span><span class="cov0" title="0">{
                        return arrow.BinaryTypes.Binary, nil
                }</span>
                // Default to string for other slices
                <span class="cov0" title="0">return arrow.BinaryTypes.String, nil</span>
        default:<span class="cov0" title="0">
                // Default to string for unknown types
                return arrow.BinaryTypes.String, nil</span>
        }
}

// buildColumnMetadata builds Arrow metadata for a SQL column.
func (tc *typeConverter) buildColumnMetadata(col *sql.ColumnType) arrow.Metadata <span class="cov0" title="0">{
        keys := []string{}
        values := []string{}

        // Set database type name
        if dbType := col.DatabaseTypeName(); dbType != "" </span><span class="cov0" title="0">{
                keys = append(keys, "ARROW:FLIGHT:SQL:TYPE_NAME")
                values = append(values, dbType)
        }</span>

        // Set precision and scale for numeric types
        <span class="cov0" title="0">if precision, scale, ok := col.DecimalSize(); ok </span><span class="cov0" title="0">{
                keys = append(keys, "ARROW:FLIGHT:SQL:PRECISION")
                values = append(values, fmt.Sprintf("%d", precision))
                keys = append(keys, "ARROW:FLIGHT:SQL:SCALE")
                values = append(values, fmt.Sprintf("%d", scale))
        }</span>

        // Set nullable
        <span class="cov0" title="0">if nullable, ok := col.Nullable(); ok </span><span class="cov0" title="0">{
                keys = append(keys, "ARROW:FLIGHT:SQL:IS_NULLABLE")
                values = append(values, fmt.Sprintf("%t", nullable))
        }</span>

        <span class="cov0" title="0">return arrow.NewMetadata(keys, values)</span>
}

// DuckDBToArrowValue converts a DuckDB value to an Arrow-compatible value.
func (tc *typeConverter) DuckDBToArrowValue(value interface{}, arrowType arrow.DataType) (interface{}, error) <span class="cov7" title="7">{
        if value == nil </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        // Handle sql.Null* types
        <span class="cov6" title="6">switch v := value.(type) </span>{
        case sql.NullBool:<span class="cov0" title="0">
                if !v.Valid </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return v.Bool, nil</span>
        case sql.NullByte:<span class="cov0" title="0">
                if !v.Valid </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return v.Byte, nil</span>
        case sql.NullFloat64:<span class="cov0" title="0">
                if !v.Valid </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return v.Float64, nil</span>
        case sql.NullInt16:<span class="cov0" title="0">
                if !v.Valid </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return v.Int16, nil</span>
        case sql.NullInt32:<span class="cov3" title="2">
                if !v.Valid </span><span class="cov1" title="1">{
                        return nil, nil
                }</span>
                <span class="cov1" title="1">return v.Int32, nil</span>
        case sql.NullInt64:<span class="cov0" title="0">
                if !v.Valid </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return v.Int64, nil</span>
        case sql.NullString:<span class="cov3" title="2">
                if !v.Valid </span><span class="cov1" title="1">{
                        return nil, nil
                }</span>
                <span class="cov1" title="1">return v.String, nil</span>
        case sql.NullTime:<span class="cov0" title="0">
                if !v.Valid </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return v.Time, nil</span>
        }

        // Direct conversion for most types
        <span class="cov3" title="2">return value, nil</span>
}

// ArrowToDuckDBValue converts an Arrow value to a DuckDB-compatible value.
func (tc *typeConverter) ArrowToDuckDBValue(value interface{}, duckdbType string) (interface{}, error) <span class="cov4" title="3">{
        if value == nil </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        // Most values can be passed directly
        <span class="cov3" title="2">return value, nil</span>
}

// initializeTypeMap creates the DuckDB to Arrow type mapping.
func initializeTypeMap() map[string]arrow.DataType <span class="cov1" title="1">{
        return map[string]arrow.DataType{
                // Integer types
                "tinyint":   arrow.PrimitiveTypes.Int8,
                "smallint":  arrow.PrimitiveTypes.Int16,
                "integer":   arrow.PrimitiveTypes.Int32,
                "int":       arrow.PrimitiveTypes.Int32,
                "bigint":    arrow.PrimitiveTypes.Int64,
                "hugeint":   arrow.PrimitiveTypes.Int64, // DuckDB HUGEINT mapped to INT64
                "utinyint":  arrow.PrimitiveTypes.Uint8,
                "usmallint": arrow.PrimitiveTypes.Uint16,
                "uinteger":  arrow.PrimitiveTypes.Uint32,
                "uint":      arrow.PrimitiveTypes.Uint32,
                "ubigint":   arrow.PrimitiveTypes.Uint64,

                // Floating point types
                "real":   arrow.PrimitiveTypes.Float32,
                "float":  arrow.PrimitiveTypes.Float32,
                "double": arrow.PrimitiveTypes.Float64,

                // Boolean type
                "boolean": arrow.FixedWidthTypes.Boolean,
                "bool":    arrow.FixedWidthTypes.Boolean,

                // String types
                "varchar": arrow.BinaryTypes.String,
                "text":    arrow.BinaryTypes.String,
                "string":  arrow.BinaryTypes.String,

                // Binary types
                "blob":      arrow.BinaryTypes.Binary,
                "bytea":     arrow.BinaryTypes.Binary,
                "varbinary": arrow.BinaryTypes.Binary,

                // Date/Time types
                "date":      arrow.FixedWidthTypes.Date32,
                "time":      arrow.FixedWidthTypes.Time32s,
                "timestamp": arrow.FixedWidthTypes.Timestamp_us,
                "interval":  arrow.FixedWidthTypes.MonthDayNanoInterval,

                // UUID type
                "uuid": arrow.BinaryTypes.String, // UUID as string for compatibility

                // JSON type
                "json": arrow.BinaryTypes.String, // JSON as string
        }
}</span>

// initializeReverseMap creates the Arrow to DuckDB type mapping.
func initializeReverseMap() map[arrow.Type]string <span class="cov1" title="1">{
        return map[arrow.Type]string{
                // Integer types
                arrow.INT8:   "TINYINT",
                arrow.INT16:  "SMALLINT",
                arrow.INT32:  "INTEGER",
                arrow.INT64:  "BIGINT",
                arrow.UINT8:  "UTINYINT",
                arrow.UINT16: "USMALLINT",
                arrow.UINT32: "UINTEGER",
                arrow.UINT64: "UBIGINT",

                // Floating point types
                arrow.FLOAT32: "FLOAT",
                arrow.FLOAT64: "DOUBLE",

                // Boolean type
                arrow.BOOL: "BOOLEAN",

                // String type
                arrow.STRING: "VARCHAR",

                // Binary type
                arrow.BINARY: "BLOB",

                // Date/Time types
                arrow.DATE32:                  "DATE",
                arrow.DATE64:                  "DATE",
                arrow.TIME32:                  "TIME",
                arrow.TIME64:                  "TIME",
                arrow.TIMESTAMP:               "TIMESTAMP",
                arrow.INTERVAL_MONTH_DAY_NANO: "INTERVAL",
        }
}</span>

// initializeSQLMap creates the DuckDB type to SQL type code mapping.
func initializeSQLMap() map[string]int32 <span class="cov1" title="1">{
        return map[string]int32{
                "tinyint":   int32(java_sql_Types_TINYINT),
                "smallint":  int32(java_sql_Types_SMALLINT),
                "integer":   int32(java_sql_Types_INTEGER),
                "bigint":    int32(java_sql_Types_BIGINT),
                "real":      int32(java_sql_Types_REAL),
                "float":     int32(java_sql_Types_FLOAT),
                "double":    int32(java_sql_Types_DOUBLE),
                "decimal":   int32(java_sql_Types_DECIMAL),
                "numeric":   int32(java_sql_Types_NUMERIC),
                "boolean":   int32(java_sql_Types_BOOLEAN),
                "varchar":   int32(java_sql_Types_VARCHAR),
                "text":      int32(java_sql_Types_VARCHAR),
                "blob":      int32(java_sql_Types_BLOB),
                "date":      int32(java_sql_Types_DATE),
                "time":      int32(java_sql_Types_TIME),
                "timestamp": int32(java_sql_Types_TIMESTAMP),
        }
}</span>

// Java SQL Types constants (from JDBC spec)
const (
        java_sql_Types_BIT                     = -7
        java_sql_Types_TINYINT                 = -6
        java_sql_Types_SMALLINT                = 5
        java_sql_Types_INTEGER                 = 4
        java_sql_Types_BIGINT                  = -5
        java_sql_Types_FLOAT                   = 6
        java_sql_Types_REAL                    = 7
        java_sql_Types_DOUBLE                  = 8
        java_sql_Types_NUMERIC                 = 2
        java_sql_Types_DECIMAL                 = 3
        java_sql_Types_CHAR                    = 1
        java_sql_Types_VARCHAR                 = 12
        java_sql_Types_LONGVARCHAR             = -1
        java_sql_Types_DATE                    = 91
        java_sql_Types_TIME                    = 92
        java_sql_Types_TIMESTAMP               = 93
        java_sql_Types_BINARY                  = -2
        java_sql_Types_VARBINARY               = -3
        java_sql_Types_LONGVARBINARY           = -4
        java_sql_Types_NULL                    = 0
        java_sql_Types_OTHER                   = 1111
        java_sql_Types_JAVA_OBJECT             = 2000
        java_sql_Types_DISTINCT                = 2001
        java_sql_Types_STRUCT                  = 2002
        java_sql_Types_ARRAY                   = 2003
        java_sql_Types_BLOB                    = 2004
        java_sql_Types_CLOB                    = 2005
        java_sql_Types_REF                     = 2006
        java_sql_Types_DATALINK                = 70
        java_sql_Types_BOOLEAN                 = 16
        java_sql_Types_ROWID                   = -8
        java_sql_Types_NCHAR                   = -15
        java_sql_Types_NVARCHAR                = -9
        java_sql_Types_LONGNVARCHAR            = -16
        java_sql_Types_NCLOB                   = 2011
        java_sql_Types_SQLXML                  = 2009
        java_sql_Types_REF_CURSOR              = 2012
        java_sql_Types_TIME_WITH_TIMEZONE      = 2013
        java_sql_Types_TIMESTAMP_WITH_TIMEZONE = 2014
)

// DuckDBToArrowType converts a DuckDB type string to an Apache Arrow DataType.
func (tc *typeConverter) DuckDBToArrowType(duckdbType string) (arrow.DataType, error) <span class="cov8" title="10">{
        duckdbType = strings.ToLower(strings.TrimSpace(duckdbType))
        if arrowType, ok := tc.typeMap[duckdbType]; ok </span><span class="cov7" title="8">{
                return arrowType, nil
        }</span>
        <span class="cov3" title="2">return ConvertDuckDBTypeToArrow(duckdbType)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package infrastructure provides enterprise-grade JDBC compatibility for Porter.
package infrastructure

import (
        "context"
        stderrors "errors"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/array"
        "github.com/apache/arrow-go/v18/arrow/flight"
        "github.com/apache/arrow-go/v18/arrow/flight/flightsql"
        "github.com/apache/arrow-go/v18/arrow/memory"
        "github.com/rs/zerolog"

        "github.com/TFMV/porter/pkg/errors"
        "github.com/TFMV/porter/pkg/services"
)

// JDBCCompatibilityLayer provides enterprise-grade JDBC compatibility features.
type JDBCCompatibilityLayer struct {
        allocator           memory.Allocator
        logger              zerolog.Logger
        statementClassifier *services.EnterpriseStatementClassifier
        sqlInfoProvider     *EnhancedSQLInfoProvider
        errorMapper         *JDBCErrorMapper
        metrics             JDBCMetrics
        config              JDBCConfig
}

// JDBCConfig holds configuration for JDBC compatibility features.
type JDBCConfig struct {
        StrictCompliance        bool          `yaml:"strict_compliance"`
        EnableStatementCaching  bool          `yaml:"enable_statement_caching"`
        StatementCacheSize      int           `yaml:"statement_cache_size"`
        StatementTimeout        time.Duration `yaml:"statement_timeout"`
        MaxStatementLength      int           `yaml:"max_statement_length"`
        EnableQueryValidation   bool          `yaml:"enable_query_validation"`
        EnableMetricsCollection bool          `yaml:"enable_metrics_collection"`
        ErrorDetailLevel        string        `yaml:"error_detail_level"` // "minimal", "standard", "verbose"
}

// JDBCMetrics interface for JDBC-specific metrics collection.
// This interface is implemented by EnterpriseJDBCMetrics for full functionality.
type JDBCMetrics interface {
        IncrementStatementCount(stmtType string)
        RecordStatementExecutionTime(stmtType string, duration time.Duration)
        IncrementErrorCount(errorType string)
        RecordRowsAffected(count int64)
        IncrementCacheHit()
        IncrementCacheMiss()

        // Extended methods for enterprise features
        RecordQueryComplexity(stmtType string, complexityScore float64)
        RecordResultSetSize(stmtType string, sizeBytes int64)
        UpdateActiveConnections(count int)
        UpdateActiveTransactions(count int)
        UpdateCacheSize(size int)
        UpdateMemoryUsage(bytes int64)
}

// NewJDBCCompatibilityLayer creates a new enterprise-grade JDBC compatibility layer.
func NewJDBCCompatibilityLayer(
        allocator memory.Allocator,
        logger zerolog.Logger,
        config JDBCConfig,
        metrics JDBCMetrics,
) *JDBCCompatibilityLayer <span class="cov0" title="0">{
        return &amp;JDBCCompatibilityLayer{
                allocator:           allocator,
                logger:              logger.With().Str("component", "jdbc-compatibility").Logger(),
                statementClassifier: services.NewEnterpriseStatementClassifier(),
                sqlInfoProvider:     NewEnhancedSQLInfoProvider(allocator),
                errorMapper:         NewJDBCErrorMapper(config.ErrorDetailLevel),
                metrics:             metrics,
                config:              config,
        }
}</span>

// ValidateStatement performs enterprise-grade SQL statement validation.
func (j *JDBCCompatibilityLayer) ValidateStatement(ctx context.Context, sql string) error <span class="cov0" title="0">{
        if !j.config.EnableQueryValidation </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Use the enhanced statement classifier for validation
        <span class="cov0" title="0">if err := j.statementClassifier.ValidateStatement(sql); err != nil </span><span class="cov0" title="0">{
                return j.errorMapper.MapError(fmt.Errorf("validation failed: %w", err))
        }</span>

        // Length validation
        <span class="cov0" title="0">if j.config.MaxStatementLength &gt; 0 &amp;&amp; len(sql) &gt; j.config.MaxStatementLength </span><span class="cov0" title="0">{
                return j.errorMapper.MapError(errors.New(errors.CodeInvalidRequest,
                        fmt.Sprintf("SQL statement exceeds maximum length of %d characters", j.config.MaxStatementLength)))
        }</span>

        // Enhanced security validation using statement classifier
        <span class="cov0" title="0">info, err := j.statementClassifier.AnalyzeStatement(sql)
        if err != nil </span><span class="cov0" title="0">{
                return j.errorMapper.MapError(fmt.Errorf("analysis failed: %w", err))
        }</span>

        // Check for dangerous operations in strict compliance mode
        <span class="cov0" title="0">if j.config.StrictCompliance </span><span class="cov0" title="0">{
                if info.IsDangerous </span><span class="cov0" title="0">{
                        return j.errorMapper.MapError(errors.New(errors.CodePermissionDenied,
                                "dangerous operation not allowed in strict compliance mode"))
                }</span>

                <span class="cov0" title="0">if info.HasSQLInjectionRisk </span><span class="cov0" title="0">{
                        return j.errorMapper.MapError(errors.New(errors.CodePermissionDenied,
                                "potential SQL injection detected"))
                }</span>

                <span class="cov0" title="0">if info.SecurityRisk == services.SecurityRiskHigh || info.SecurityRisk == services.SecurityRiskCritical </span><span class="cov0" title="0">{
                        return j.errorMapper.MapError(errors.New(errors.CodePermissionDenied,
                                fmt.Sprintf("security risk level %s not allowed", info.SecurityRisk.String())))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ClassifyStatementForJDBC classifies SQL statements with JDBC-specific handling.
func (j *JDBCCompatibilityLayer) ClassifyStatementForJDBC(sql string) (services.StatementType, JDBCStatementInfo, error) <span class="cov0" title="0">{
        // Use the enhanced statement classifier
        info, err := j.statementClassifier.AnalyzeStatement(sql)
        if err != nil </span><span class="cov0" title="0">{
                return services.StatementTypeOther, JDBCStatementInfo{}, err
        }</span>

        <span class="cov0" title="0">jdbcInfo := JDBCStatementInfo{
                Type:                info.Type,
                ExpectsResultSet:    info.ExpectsResultSet,
                ExpectsUpdateCount:  info.ExpectsUpdateCount,
                RequiresTransaction: info.RequiresTransaction,
                IsReadOnly:          info.IsReadOnly,
                EstimatedComplexity: info.Complexity,
                SecurityRisk:        info.SecurityRisk,
                IsDangerous:         info.IsDangerous,
                Keywords:            info.Keywords,
                Tables:              info.Tables,
                Operations:          info.Operations,
        }

        // Record metrics
        if j.config.EnableMetricsCollection &amp;&amp; j.metrics != nil </span><span class="cov0" title="0">{
                j.metrics.IncrementStatementCount(info.Type.String())

                // Record complexity if supported
                if complexityRecorder, ok := j.metrics.(interface {
                        RecordQueryComplexity(string, float64)
                }); ok </span><span class="cov0" title="0">{
                        complexityRecorder.RecordQueryComplexity(info.Type.String(), float64(info.Complexity))
                }</span>
        }

        <span class="cov0" title="0">return info.Type, jdbcInfo, nil</span>
}

// CreateJDBCCompatibleFlightInfo creates FlightInfo with JDBC-compatible metadata.
func (j *JDBCCompatibilityLayer) CreateJDBCCompatibleFlightInfo(
        ctx context.Context,
        sql string,
        schema *arrow.Schema,
        stmtType services.StatementType,
) (*flight.FlightInfo, error) <span class="cov0" title="0">{

        // Create descriptor
        desc := &amp;flight.FlightDescriptor{
                Type: flight.DescriptorCMD,
                Cmd:  []byte(sql),
        }

        var resultSchema *arrow.Schema
        var endpoints []*flight.FlightEndpoint

        if stmtType == services.StatementTypeDDL || stmtType == services.StatementTypeDML ||
                stmtType == services.StatementTypeTCL || stmtType == services.StatementTypeDCL </span><span class="cov0" title="0">{
                // For DDL/DML/TCL/DCL, create update count schema
                resultSchema = j.createUpdateCountSchema()
                endpoints = []*flight.FlightEndpoint{{
                        Ticket: &amp;flight.Ticket{Ticket: []byte(sql)},
                }}
        }</span> else<span class="cov0" title="0"> {
                // For DQL/Utility, use provided schema
                resultSchema = schema
                endpoints = []*flight.FlightEndpoint{{
                        Ticket: &amp;flight.Ticket{Ticket: []byte(sql)},
                }}
        }</span>

        <span class="cov0" title="0">return &amp;flight.FlightInfo{
                Schema:           flight.SerializeSchema(resultSchema, j.allocator),
                FlightDescriptor: desc,
                Endpoint:         endpoints,
                TotalRecords:     -1,
                TotalBytes:       -1,
        }, nil</span>
}

// CreateUpdateCountResult creates a JDBC-compatible update count result.
func (j *JDBCCompatibilityLayer) CreateUpdateCountResult(rowsAffected int64) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        schema := j.createUpdateCountSchema()

        // Create record with update count
        builder := array.NewRecordBuilder(j.allocator, schema)
        defer builder.Release()

        int64Builder := builder.Field(0).(*array.Int64Builder)
        int64Builder.Append(rowsAffected)

        record := builder.NewRecord()
        // Note: Don't release record here as it will be used by the consumer

        // Create channel with result
        resultChan := make(chan flight.StreamChunk, 1)
        resultChan &lt;- flight.StreamChunk{Data: record}
        close(resultChan)

        // Record metrics
        if j.config.EnableMetricsCollection &amp;&amp; j.metrics != nil </span><span class="cov0" title="0">{
                j.metrics.RecordRowsAffected(rowsAffected)
        }</span>

        <span class="cov0" title="0">return schema, resultChan, nil</span>
}

// GetEnhancedSQLInfo returns comprehensive SQL information for JDBC clients.
func (j *JDBCCompatibilityLayer) GetEnhancedSQLInfo(infoTypes []uint32) (arrow.Record, error) <span class="cov0" title="0">{
        return j.sqlInfoProvider.GetSQLInfo(infoTypes)
}</span>

// JDBCStatementInfo provides detailed information about SQL statements for JDBC compatibility.
type JDBCStatementInfo struct {
        Type                services.StatementType
        ExpectsResultSet    bool
        ExpectsUpdateCount  bool
        RequiresTransaction bool
        IsReadOnly          bool
        EstimatedComplexity services.StatementComplexity
        SecurityRisk        services.SecurityRiskLevel
        IsDangerous         bool
        Keywords            []string
        Tables              []string
        Operations          []string
}

// createUpdateCountSchema creates the schema for update count results.
func (j *JDBCCompatibilityLayer) createUpdateCountSchema() *arrow.Schema <span class="cov0" title="0">{
        return arrow.NewSchema([]arrow.Field{
                {Name: "rows_affected", Type: arrow.PrimitiveTypes.Int64},
        }, nil)
}</span>

// JDBCErrorMapper provides enterprise-grade error mapping for JDBC compatibility.
type JDBCErrorMapper struct {
        detailLevel string
}

// NewJDBCErrorMapper creates a new JDBC error mapper.
func NewJDBCErrorMapper(detailLevel string) *JDBCErrorMapper <span class="cov0" title="0">{
        return &amp;JDBCErrorMapper{
                detailLevel: detailLevel,
        }
}</span>

// MapError maps internal errors to JDBC-compatible error messages.
func (m *JDBCErrorMapper) MapError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract error details based on configuration
        <span class="cov0" title="0">switch m.detailLevel </span>{
        case "minimal":<span class="cov0" title="0">
                return m.createMinimalError(err)</span>
        case "verbose":<span class="cov0" title="0">
                return m.createVerboseError(err)</span>
        default:<span class="cov0" title="0"> // "standard"
                return m.createStandardError(err)</span>
        }
}

// createMinimalError creates a minimal error message for security.
func (m *JDBCErrorMapper) createMinimalError(err error) error <span class="cov0" title="0">{
        return fmt.Errorf("SQL execution failed")
}</span>

// createStandardError creates a standard error message with basic details.
func (m *JDBCErrorMapper) createStandardError(err error) error <span class="cov0" title="0">{
        var flightErr *errors.FlightError
        if stderrors.As(err, &amp;flightErr) </span><span class="cov0" title="0">{
                switch flightErr.Code </span>{
                case errors.CodeInvalidRequest:<span class="cov0" title="0">
                        return fmt.Errorf("invalid SQL statement: %s", flightErr.Message)</span>
                case errors.CodeNotFound:<span class="cov0" title="0">
                        return fmt.Errorf("object not found: %s", flightErr.Message)</span>
                case errors.CodePermissionDenied:<span class="cov0" title="0">
                        return fmt.Errorf("access denied: %s", flightErr.Message)</span>
                case errors.CodeQueryFailed:<span class="cov0" title="0">
                        return fmt.Errorf("query execution failed: %s", flightErr.Message)</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("database error: %s", flightErr.Message)</span>
                }
        }
        <span class="cov0" title="0">return fmt.Errorf("database error: %s", err.Error())</span>
}

// createVerboseError creates a detailed error message for debugging.
func (m *JDBCErrorMapper) createVerboseError(err error) error <span class="cov0" title="0">{
        return fmt.Errorf("detailed error: %w", err)
}</span>

// EnhancedSQLInfoProvider provides comprehensive SQL information for enterprise JDBC clients.
type EnhancedSQLInfoProvider struct {
        allocator memory.Allocator
        sqlInfo   map[uint32]interface{}
        mu        sync.RWMutex
}

// NewEnhancedSQLInfoProvider creates a new enhanced SQL info provider.
func NewEnhancedSQLInfoProvider(allocator memory.Allocator) *EnhancedSQLInfoProvider <span class="cov0" title="0">{
        provider := &amp;EnhancedSQLInfoProvider{
                allocator: allocator,
                sqlInfo:   make(map[uint32]interface{}),
        }
        provider.initializeEnhancedSQLInfo()
        return provider
}</span>

// initializeEnhancedSQLInfo sets up comprehensive SQL information.
func (p *EnhancedSQLInfoProvider) initializeEnhancedSQLInfo() <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // Server identification
        p.sqlInfo[uint32(flightsql.SqlInfoFlightSqlServerName)] = "Porter Enterprise"
        p.sqlInfo[uint32(flightsql.SqlInfoFlightSqlServerVersion)] = "2.0.0"
        p.sqlInfo[uint32(flightsql.SqlInfoFlightSqlServerArrowVersion)] = "18.0.0"
        p.sqlInfo[uint32(flightsql.SqlInfoFlightSqlServerReadOnly)] = false
        p.sqlInfo[uint32(flightsql.SqlInfoFlightSqlServerTransaction)] = int32(flightsql.SqlTransactionTransaction)

        // Enhanced capabilities
        p.sqlInfo[uint32(flightsql.SqlInfoDDLCatalog)] = true
        p.sqlInfo[uint32(flightsql.SqlInfoDDLSchema)] = true
        p.sqlInfo[uint32(flightsql.SqlInfoDDLTable)] = true
        p.sqlInfo[uint32(flightsql.SqlInfoAllTablesAreASelectable)] = true
        p.sqlInfo[uint32(flightsql.SqlInfoTransactionsSupported)] = true

        // JDBC-specific features (using available constants)
        p.sqlInfo[uint32(flightsql.SqlInfoSupportsLikeEscapeClause)] = true
        p.sqlInfo[uint32(flightsql.SqlInfoSupportsNonNullableColumns)] = true

        // Enhanced keyword and function lists from statement classifier
        p.sqlInfo[uint32(flightsql.SqlInfoKeywords)] = p.getEnterpriseKeywords()
        p.sqlInfo[uint32(flightsql.SqlInfoNumericFunctions)] = p.getEnterpriseNumericFunctions()
        p.sqlInfo[uint32(flightsql.SqlInfoStringFunctions)] = p.getEnterpriseStringFunctions()
}</span>

// GetSQLInfo returns SQL information for the given info types.
func (p *EnhancedSQLInfoProvider) GetSQLInfo(infoTypes []uint32) (arrow.Record, error) <span class="cov0" title="0">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        // Create schema
        schema := arrow.NewSchema([]arrow.Field{
                {Name: "info_name", Type: arrow.PrimitiveTypes.Uint32},
                {Name: "value", Type: arrow.BinaryTypes.String},
        }, nil)

        // Build arrays
        builder := array.NewRecordBuilder(p.allocator, schema)
        defer builder.Release()

        infoNameBuilder := builder.Field(0).(*array.Uint32Builder)
        valueBuilder := builder.Field(1).(*array.StringBuilder)

        // If no specific info types requested, return all
        if len(infoTypes) == 0 </span><span class="cov0" title="0">{
                for info := range p.sqlInfo </span><span class="cov0" title="0">{
                        infoTypes = append(infoTypes, info)
                }</span>
        }

        // Add requested info
        <span class="cov0" title="0">for _, infoType := range infoTypes </span><span class="cov0" title="0">{
                if value, exists := p.sqlInfo[infoType]; exists </span><span class="cov0" title="0">{
                        infoNameBuilder.Append(infoType)
                        valueBuilder.Append(p.formatValue(value))
                }</span>
        }

        <span class="cov0" title="0">return builder.NewRecord(), nil</span>
}

// getEnterpriseKeywords returns comprehensive SQL keywords for enterprise clients.
func (p *EnhancedSQLInfoProvider) getEnterpriseKeywords() []string <span class="cov0" title="0">{
        return []string{
                "ABORT", "ABSOLUTE", "ACCESS", "ACTION", "ADD", "ADMIN", "AFTER", "AGGREGATE",
                "ALL", "ALSO", "ALTER", "ALWAYS", "ANALYSE", "ANALYZE", "AND", "ANY", "ARRAY",
                "AS", "ASC", "ASSERTION", "ASSIGNMENT", "ASYMMETRIC", "AT", "ATTACH", "ATTRIBUTE",
                "AUTHORIZATION", "BACKWARD", "BEFORE", "BEGIN", "BETWEEN", "BIGINT", "BINARY",
                "BIT", "BOOLEAN", "BOTH", "BY", "CACHE", "CALL", "CALLED", "CASCADE", "CASCADED",
                "CASE", "CAST", "CATALOG", "CHAIN", "CHAR", "CHARACTER", "CHARACTERISTICS",
                "CHECK", "CHECKPOINT", "CLASS", "CLOSE", "CLUSTER", "COALESCE", "COLLATE",
                "COLLATION", "COLUMN", "COLUMNS", "COMMENT", "COMMENTS", "COMMIT", "COMMITTED",
                "CONCURRENTLY", "CONFIGURATION", "CONFLICT", "CONNECTION", "CONSTRAINT",
                "CONSTRAINTS", "CONTENT", "CONTINUE", "CONVERSION", "COPY", "COST", "CREATE",
                "CROSS", "CSV", "CUBE", "CURRENT", "CURRENT_CATALOG", "CURRENT_DATE",
                "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_TIME", "CURRENT_TIMESTAMP",
                "CURRENT_USER", "CURSOR", "CYCLE", "DATA", "DATABASE", "DAY", "DAYS",
                "DEALLOCATE", "DEC", "DECIMAL", "DECLARE", "DEFAULT", "DEFAULTS", "DEFERRABLE",
                "DEFERRED", "DEFINER", "DELETE", "DELIMITER", "DELIMITERS", "DEPENDS", "DESC",
                "DESCRIBE", "DETACH", "DICTIONARY", "DISABLE", "DISCARD", "DISTINCT", "DO",
                "DOCUMENT", "DOMAIN", "DOUBLE", "DROP", "EACH", "ELSE", "ENABLE", "ENCODING",
                "ENCRYPTED", "END", "ENUM", "ESCAPE", "EVENT", "EXCEPT", "EXCLUDE", "EXCLUDING",
                "EXCLUSIVE", "EXECUTE", "EXISTS", "EXPLAIN", "EXPORT", "EXTENSION", "EXTERNAL",
                "EXTRACT", "FALSE", "FAMILY", "FETCH", "FILTER", "FIRST", "FLOAT", "FOLLOWING",
                "FOR", "FORCE", "FOREIGN", "FORWARD", "FREEZE", "FROM", "FULL", "FUNCTION",
                "FUNCTIONS", "GENERATED", "GLOB", "GLOBAL", "GRANT", "GRANTED", "GROUP",
                "GROUPING", "HANDLER", "HAVING", "HEADER", "HOLD", "HOUR", "HOURS", "IDENTITY",
                "IF", "ILIKE", "IMMEDIATE", "IMMUTABLE", "IMPLICIT", "IMPORT", "IN", "INCLUDING",
                "INCREMENT", "INDEX", "INDEXES", "INHERIT", "INHERITS", "INITIALLY", "INLINE",
                "INNER", "INOUT", "INPUT", "INSENSITIVE", "INSERT", "INSTEAD", "INT", "INTEGER",
                "INTERSECT", "INTERVAL", "INTO", "INVOKER", "IS", "ISNULL", "ISOLATION", "JOIN",
                "KEY", "LABEL", "LANGUAGE", "LARGE", "LAST", "LATERAL", "LEADING", "LEAKPROOF",
                "LEFT", "LEVEL", "LIKE", "LIMIT", "LISTEN", "LOAD", "LOCAL", "LOCALTIME",
                "LOCALTIMESTAMP", "LOCATION", "LOCK", "LOCKED", "LOGGED", "MACRO", "MAP",
                "MAPPING", "MATCH", "MATERIALIZED", "MAXVALUE", "METHOD", "MICROSECOND",
                "MICROSECONDS", "MILLISECOND", "MILLISECONDS", "MINUTE", "MINUTES", "MINVALUE",
                "MODE", "MONTH", "MONTHS", "MOVE", "NAME", "NAMES", "NATIONAL", "NATURAL",
                "NCHAR", "NEW", "NEXT", "NO", "NONE", "NOT", "NOTHING", "NOTIFY", "NOTNULL",
                "NOWAIT", "NULL", "NULLIF", "NULLS", "NUMERIC", "OBJECT", "OF", "OFF", "OFFSET",
                "OIDS", "OLD", "ON", "ONLY", "OPERATOR", "OPTION", "OPTIONS", "OR", "ORDER",
                "ORDINALITY", "OUT", "OUTER", "OVER", "OVERLAPS", "OVERLAY", "OVERRIDING",
                "OWNED", "OWNER", "PARALLEL", "PARSER", "PARTIAL", "PARTITION", "PASSING",
                "PASSWORD", "PERCENT", "PLACING", "PLANS", "POLICY", "POSITION", "PRAGMA",
                "PRECEDING", "PRECISION", "PREPARE", "PREPARED", "PRESERVE", "PRIMARY", "PRIOR",
                "PRIVILEGES", "PROCEDURAL", "PROCEDURE", "PROGRAM", "PUBLICATION", "QUOTE",
                "RANGE", "READ", "REAL", "REASSIGN", "RECHECK", "RECURSIVE", "REF", "REFERENCES",
                "REFERENCING", "REFRESH", "REINDEX", "RELATIVE", "RELEASE", "RENAME",
                "REPEATABLE", "REPLACE", "REPLICA", "RESET", "RESTART", "RESTRICT", "RETURNING",
                "RETURNS", "REVOKE", "RIGHT", "ROLE", "ROLLBACK", "ROLLUP", "ROW", "ROWS",
                "RULE", "SAMPLE", "SAVEPOINT", "SCHEMA", "SCHEMAS", "SCROLL", "SEARCH", "SECOND",
                "SECONDS", "SECURITY", "SELECT", "SEQUENCE", "SEQUENCES", "SERIALIZABLE",
                "SERVER", "SESSION", "SESSION_USER", "SET", "SETOF", "SETS", "SHARE", "SHOW",
                "SIMILAR", "SIMPLE", "SKIP", "SMALLINT", "SNAPSHOT", "SOME", "SQL", "STABLE",
                "STANDALONE", "START", "STATEMENT", "STATISTICS", "STDIN", "STDOUT", "STORAGE",
                "STRICT", "STRIP", "STRUCT", "SUBSCRIPTION", "SUBSTRING", "SYMMETRIC", "SYSID",
                "SYSTEM", "TABLE", "TABLES", "TABLESAMPLE", "TABLESPACE", "TEMP", "TEMPLATE",
                "TEMPORARY", "TEXT", "THEN", "TIME", "TIMESTAMP", "TO", "TRAILING", "TRANSACTION",
                "TRANSFORM", "TREAT", "TRIGGER", "TRIM", "TRUE", "TRUNCATE", "TRUSTED", "TRY_CAST",
                "TYPE", "TYPES", "UNBOUNDED", "UNCOMMITTED", "UNENCRYPTED", "UNION", "UNIQUE",
                "UNKNOWN", "UNLISTEN", "UNLOGGED", "UNTIL", "UPDATE", "USER", "USING", "VACUUM",
                "VALID", "VALIDATE", "VALIDATOR", "VALUE", "VALUES", "VARCHAR", "VARIADIC",
                "VARYING", "VERBOSE", "VERSION", "VIEW", "VIEWS", "VOLATILE", "WHEN", "WHERE",
                "WHITESPACE", "WINDOW", "WITH", "WITHIN", "WITHOUT", "WORK", "WRAPPER", "WRITE",
                "XML", "XMLATTRIBUTES", "XMLCONCAT", "XMLELEMENT", "XMLEXISTS", "XMLFOREST",
                "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLROOT", "XMLSERIALIZE", "XMLTABLE",
                "YEAR", "YEARS", "YES", "ZONE",
        }
}</span>

// getEnterpriseNumericFunctions returns comprehensive numeric functions.
func (p *EnhancedSQLInfoProvider) getEnterpriseNumericFunctions() []string <span class="cov0" title="0">{
        return []string{
                "ABS", "ACOS", "ASIN", "ATAN", "ATAN2", "CEIL", "CEILING", "COS", "COT",
                "DEGREES", "EXP", "FLOOR", "LOG", "LOG10", "LOG2", "MOD", "PI", "POWER",
                "RADIANS", "RANDOM", "ROUND", "SIGN", "SIN", "SQRT", "TAN", "TRUNCATE",
                "GREATEST", "LEAST", "CBRT", "FACTORIAL", "GAMMA", "LGAMMA", "LN",
                "NEXTAFTER", "POW", "SETSEED", "XOR", "BIT_COUNT", "EVEN",
        }
}</span>

// getEnterpriseStringFunctions returns comprehensive string functions.
func (p *EnhancedSQLInfoProvider) getEnterpriseStringFunctions() []string <span class="cov0" title="0">{
        return []string{
                "ASCII", "CHAR", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHR", "CONCAT", "CONCAT_WS",
                "CONTAINS", "DIFFERENCE", "FORMAT", "INITCAP", "INSERT", "INSTR", "LCASE",
                "LEFT", "LENGTH", "LIKE", "LOCATE", "LOWER", "LPAD", "LTRIM", "MD5",
                "OCTET_LENGTH", "OVERLAY", "POSITION", "REPEAT", "REPLACE", "REVERSE",
                "RIGHT", "RPAD", "RTRIM", "SOUNDEX", "SPACE", "SPLIT_PART", "STRPOS",
                "SUBSTRING", "TRANSLATE", "TRIM", "UCASE", "UPPER", "BASE64", "FROM_BASE64",
                "TO_BASE64", "REGEXP_MATCHES", "REGEXP_REPLACE", "REGEXP_SPLIT_TO_ARRAY",
                "STRING_SPLIT", "STRING_TO_ARRAY", "ARRAY_TO_STRING", "EDITDIST3",
                "HAMMING", "JACCARD", "LEVENSHTEIN", "MISMATCHES", "NFC_NORMALIZE",
                "STRIP_ACCENTS", "UNICODE", "ORD", "PREFIX", "SUFFIX", "STARTS_WITH",
                "ENDS_WITH", "LIKE_ESCAPE", "NOT_LIKE_ESCAPE",
        }
}</span>

// formatValue converts various value types to string representation.
func (p *EnhancedSQLInfoProvider) formatValue(value interface{}) string <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return v</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return "true"
                }</span>
                <span class="cov0" title="0">return "false"</span>
        case int32:<span class="cov0" title="0">
                return fmt.Sprintf("%d", v)</span>
        case int64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", v)</span>
        case []string:<span class="cov0" title="0">
                return fmt.Sprintf("[%s]", strings.Join(v, ","))</span>
        case []int32:<span class="cov0" title="0">
                strs := make([]string, len(v))
                for i, n := range v </span><span class="cov0" title="0">{
                        strs[i] = fmt.Sprintf("%d", n)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("[%s]", strings.Join(strs, ","))</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", v)</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package memory

import (
        "sync/atomic"

        "github.com/apache/arrow-go/v18/arrow/memory"
)

var (
        // globalAllocator is the singleton instance of the tracked allocator
        globalAllocator = NewTrackedAllocator(memory.NewGoAllocator())
)

// TrackedAllocator wraps a memory.Allocator and tracks total allocated bytes
type TrackedAllocator struct {
        underlying memory.Allocator
        bytesUsed  atomic.Int64
}

// NewTrackedAllocator creates a new TrackedAllocator
func NewTrackedAllocator(underlying memory.Allocator) *TrackedAllocator <span class="cov6" title="5">{
        return &amp;TrackedAllocator{
                underlying: underlying,
        }
}</span>

// Allocate implements memory.Allocator interface
func (a *TrackedAllocator) Allocate(size int) []byte <span class="cov10" title="16">{
        a.bytesUsed.Add(int64(size))
        return a.underlying.Allocate(size)
}</span>

// Reallocate implements memory.Allocator interface
func (a *TrackedAllocator) Reallocate(size int, b []byte) []byte <span class="cov3" title="2">{
        oldSize := len(b)
        a.bytesUsed.Add(int64(size - oldSize))
        return a.underlying.Reallocate(size, b)
}</span>

// Free implements memory.Allocator interface
func (a *TrackedAllocator) Free(b []byte) <span class="cov9" title="13">{
        a.bytesUsed.Add(-int64(len(b)))
        a.underlying.Free(b)
}</span>

// BytesUsed returns the current number of bytes allocated
func (a *TrackedAllocator) BytesUsed() int64 <span class="cov9" title="12">{
        return a.bytesUsed.Load()
}</span>

// GetAllocator returns the global tracked allocator instance
func GetAllocator() memory.Allocator <span class="cov1" title="1">{
        return globalAllocator
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package metrics provides metrics collection for the Flight SQL server.
package metrics

import (
        "time"
)

// Collector defines the interface for collecting metrics.
type Collector interface {
        // IncrementCounter increments a counter metric.
        IncrementCounter(name string, labels ...string)

        // RecordHistogram records a value in a histogram metric.
        RecordHistogram(name string, value float64, labels ...string)

        // RecordGauge records a gauge metric value.
        RecordGauge(name string, value float64, labels ...string)

        // StartTimer starts a timer for measuring duration.
        StartTimer(name string) Timer
}

// Timer represents a timing measurement.
type Timer interface {
        // Stop stops the timer and returns the duration in seconds.
        Stop() float64
}

// NoOpCollector is a no-op implementation of Collector.
type NoOpCollector struct{}

// NewNoOpCollector creates a new no-op collector.
func NewNoOpCollector() Collector <span class="cov10" title="4">{
        return &amp;NoOpCollector{}
}</span>

// IncrementCounter does nothing.
func (n *NoOpCollector) IncrementCounter(name string, labels ...string) {<span class="cov1" title="1">}</span>

// RecordHistogram does nothing.
func (n *NoOpCollector) RecordHistogram(name string, value float64, labels ...string) {<span class="cov1" title="1">}</span>

// RecordGauge does nothing.
func (n *NoOpCollector) RecordGauge(name string, value float64, labels ...string) {<span class="cov1" title="1">}</span>

// StartTimer returns a no-op timer.
func (n *NoOpCollector) StartTimer(name string) Timer <span class="cov1" title="1">{
        return &amp;noOpTimer{start: time.Now()}
}</span>

// noOpTimer is a no-op implementation of Timer.
type noOpTimer struct {
        start time.Time
}

// Stop returns the elapsed time in seconds.
func (t *noOpTimer) Stop() float64 <span class="cov5" title="2">{
        return time.Since(t.start).Seconds()
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package metrics

import (
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// PrometheusCollector implements Collector using Prometheus.
type PrometheusCollector struct {
        counters   map[string]*prometheus.CounterVec
        histograms map[string]*prometheus.HistogramVec
        gauges     map[string]*prometheus.GaugeVec
}

// NewPrometheusCollector creates a new Prometheus collector.
func NewPrometheusCollector() Collector <span class="cov7" title="4">{
        return &amp;PrometheusCollector{
                counters:   make(map[string]*prometheus.CounterVec),
                histograms: make(map[string]*prometheus.HistogramVec),
                gauges:     make(map[string]*prometheus.GaugeVec),
        }
}</span>

// IncrementCounter increments a counter metric.
func (p *PrometheusCollector) IncrementCounter(name string, labels ...string) <span class="cov4" title="2">{
        labelNames, labelValues := parseLabelPairs(labels)

        counter, exists := p.counters[name]
        if !exists </span><span class="cov1" title="1">{
                counter = prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: name,
                                Help: fmt.Sprintf("Counter for %s", name),
                        },
                        labelNames,
                )
                prometheus.MustRegister(counter)
                p.counters[name] = counter
        }</span>

        <span class="cov4" title="2">counter.WithLabelValues(labelValues...).Inc()</span>
}

// RecordHistogram records a value in a histogram metric.
func (p *PrometheusCollector) RecordHistogram(name string, value float64, labels ...string) <span class="cov1" title="1">{
        labelNames, labelValues := parseLabelPairs(labels)

        histogram, exists := p.histograms[name]
        if !exists </span><span class="cov1" title="1">{
                histogram = prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    name,
                                Help:    fmt.Sprintf("Histogram for %s", name),
                                Buckets: prometheus.DefBuckets,
                        },
                        labelNames,
                )
                prometheus.MustRegister(histogram)
                p.histograms[name] = histogram
        }</span>

        <span class="cov1" title="1">histogram.WithLabelValues(labelValues...).Observe(value)</span>
}

// RecordGauge records a gauge metric value.
func (p *PrometheusCollector) RecordGauge(name string, value float64, labels ...string) <span class="cov1" title="1">{
        labelNames, labelValues := parseLabelPairs(labels)

        gauge, exists := p.gauges[name]
        if !exists </span><span class="cov1" title="1">{
                gauge = prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: name,
                                Help: fmt.Sprintf("Gauge for %s", name),
                        },
                        labelNames,
                )
                prometheus.MustRegister(gauge)
                p.gauges[name] = gauge
        }</span>

        <span class="cov1" title="1">gauge.WithLabelValues(labelValues...).Set(value)</span>
}

// StartTimer starts a timer for measuring duration.
func (p *PrometheusCollector) StartTimer(name string) Timer <span class="cov1" title="1">{
        return &amp;prometheusTimer{
                start: time.Now(),
                name:  name,
        }
}</span>

// prometheusTimer implements Timer for Prometheus.
type prometheusTimer struct {
        start time.Time
        name  string
}

// Stop returns the elapsed time in seconds.
func (t *prometheusTimer) Stop() float64 <span class="cov1" title="1">{
        return time.Since(t.start).Seconds()
}</span>

// parseLabelPairs parses label pairs from variadic string arguments.
// Expected format: "key1", "value1", "key2", "value2", ...
func parseLabelPairs(labels []string) ([]string, []string) <span class="cov10" title="8">{
        if len(labels)%2 != 0 </span><span class="cov1" title="1">{
                // If odd number of labels, ignore the last one
                labels = labels[:len(labels)-1]
        }</span>

        <span class="cov10" title="8">labelNames := make([]string, 0, len(labels)/2)
        labelValues := make([]string, 0, len(labels)/2)

        for i := 0; i &lt; len(labels); i += 2 </span><span class="cov10" title="8">{
                labelNames = append(labelNames, labels[i])
                labelValues = append(labelValues, labels[i+1])
        }</span>

        <span class="cov10" title="8">return labelNames, labelValues</span>
}

// MetricsServer provides an HTTP server for Prometheus metrics.
type MetricsServer struct {
        address string
        server  *http.Server
        mu      sync.RWMutex
}

// NewMetricsServer creates a new metrics server.
func NewMetricsServer(address string) *MetricsServer <span class="cov4" title="2">{
        return &amp;MetricsServer{
                address: address,
        }
}</span>

// Start starts the metrics server.
func (s *MetricsServer) Start() error <span class="cov1" title="1">{
        mux := http.NewServeMux()
        mux.Handle("/metrics", promhttp.Handler())

        s.mu.Lock()
        s.server = &amp;http.Server{
                Addr:    s.address,
                Handler: mux,
        }
        s.mu.Unlock()

        return s.server.ListenAndServe()
}</span>

// Stop stops the metrics server.
func (s *MetricsServer) Stop() error <span class="cov4" title="2">{
        s.mu.RLock()
        server := s.server
        s.mu.RUnlock()

        if server != nil </span><span class="cov1" title="1">{
                return server.Close()
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package infrastructure

import (
        "net/url"
        "strings"
)

// IsMotherDuckDSN reports whether the given DSN targets MotherDuck.
func IsMotherDuckDSN(dsn string) bool <span class="cov6" title="5">{
        u, err := url.Parse(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov6" title="5">if u.Scheme == "motherduck" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov6" title="5">return u.Scheme == "duckdb" &amp;&amp; strings.HasPrefix(u.Host, "motherduck")</span>
}

// NormalizeMotherDuckDSN converts motherduck:// URIs to the
// duckdb://motherduck/ form understood by DuckDB.
func NormalizeMotherDuckDSN(dsn string) string <span class="cov10" title="12">{
        u, err := url.Parse(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return dsn
        }</span>
        <span class="cov10" title="12">if u.Scheme == "motherduck" </span><span class="cov8" title="7">{
                u.Scheme = "duckdb"
                // For motherduck://dbname, convert to duckdb://motherduck/dbname
                if u.Host != "" &amp;&amp; !strings.HasPrefix(u.Host, "motherduck") </span><span class="cov6" title="5">{
                        u.Path = "/" + u.Host + u.Path
                        u.Host = "motherduck"
                }</span> else<span class="cov3" title="2"> if u.Host == "" </span><span class="cov3" title="2">{
                        u.Host = "motherduck"
                }</span>
                <span class="cov8" title="7">return u.String()</span>
        }
        <span class="cov6" title="5">return dsn</span>
}

// InjectMotherDuckToken ensures the motherduck_token query parameter is set
// when connecting to MotherDuck. If the DSN already contains the parameter or
// the token is empty, the DSN is returned unchanged.
func InjectMotherDuckToken(dsn, token string) string <span class="cov7" title="6">{
        if token == "" </span><span class="cov1" title="1">{
                return dsn
        }</span>
        <span class="cov6" title="5">u, err := url.Parse(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return dsn
        }</span>
        <span class="cov6" title="5">if !IsMotherDuckDSN(dsn) </span><span class="cov1" title="1">{
                return dsn
        }</span>
        <span class="cov6" title="4">q := u.Query()
        if q.Get("motherduck_token") == "" </span><span class="cov6" title="4">{
                q.Set("motherduck_token", token)
                u.RawQuery = q.Encode()
        }</span>
        <span class="cov6" title="4">return u.String()</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package pool provides database connection pooling for DuckDB.
package pool

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "net/url"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        _ "github.com/marcboeker/go-duckdb/v2"
        "github.com/rs/zerolog"

        pkgerrors "github.com/TFMV/porter/pkg/errors"
)

// Config represents pool configuration.
type Config struct {
        DSN                string        `json:"dsn"`
        MaxOpenConnections int           `json:"max_open_connections"`
        MaxIdleConnections int           `json:"max_idle_connections"`
        ConnMaxLifetime    time.Duration `json:"conn_max_lifetime"`
        ConnMaxIdleTime    time.Duration `json:"conn_max_idle_time"`
        HealthCheckPeriod  time.Duration `json:"health_check_period"`
        ConnectionTimeout  time.Duration `json:"connection_timeout"`

        // Enterprise features
        EnableCircuitBreaker    bool          `json:"enable_circuit_breaker"`
        CircuitBreakerThreshold int           `json:"circuit_breaker_threshold"`
        CircuitBreakerTimeout   time.Duration `json:"circuit_breaker_timeout"`
        EnableConnectionRetry   bool          `json:"enable_connection_retry"`
        MaxRetryAttempts        int           `json:"max_retry_attempts"`
        RetryBackoffBase        time.Duration `json:"retry_backoff_base"`
        EnableSlowQueryLogging  bool          `json:"enable_slow_query_logging"`
        SlowQueryThreshold      time.Duration `json:"slow_query_threshold"`
        EnableMetrics           bool          `json:"enable_metrics"`
        MetricsNamespace        string        `json:"metrics_namespace"`
}

// ConnectionPool manages database connections.
type ConnectionPool interface {
        // Get returns a database connection.
        Get(ctx context.Context) (*sql.DB, error)
        // GetWithValidation returns a validated database connection.
        GetWithValidation(ctx context.Context) (*EnterpriseConnection, error)
        // Stats returns pool statistics.
        Stats() PoolStats
        // EnterpriseStats returns comprehensive enterprise statistics.
        EnterpriseStats() EnterprisePoolStats
        // HealthCheck performs a health check on the pool.
        HealthCheck(ctx context.Context) error
        // Close closes the connection pool.
        Close() error
        // SetMetricsCollector sets the metrics collector.
        SetMetricsCollector(collector MetricsCollector)
}

// MetricsCollector interface for collecting pool metrics.
type MetricsCollector interface {
        RecordConnectionAcquisition(duration time.Duration)
        RecordConnectionValidation(success bool, duration time.Duration)
        RecordQueryExecution(query string, duration time.Duration, success bool)
        UpdateActiveConnections(count int)
        IncrementCircuitBreakerTrip()
        IncrementRetryAttempt()
}

// PoolStats represents connection pool statistics.
type PoolStats struct {
        OpenConnections   int           `json:"open_connections"`
        InUse             int           `json:"in_use"`
        Idle              int           `json:"idle"`
        WaitCount         int64         `json:"wait_count"`
        WaitDuration      time.Duration `json:"wait_duration"`
        MaxIdleClosed     int64         `json:"max_idle_closed"`
        MaxLifetimeClosed int64         `json:"max_lifetime_closed"`
        LastHealthCheck   time.Time     `json:"last_health_check"`
        HealthCheckStatus string        `json:"health_check_status"`
}

// EnterprisePoolStats provides comprehensive pool statistics.
type EnterprisePoolStats struct {
        PoolStats
        CircuitBreakerState    string        `json:"circuit_breaker_state"`
        CircuitBreakerFailures int64         `json:"circuit_breaker_failures"`
        TotalRetryAttempts     int64         `json:"total_retry_attempts"`
        SlowQueries            int64         `json:"slow_queries"`
        ValidationFailures     int64         `json:"validation_failures"`
        AverageAcquisitionTime time.Duration `json:"average_acquisition_time"`
        PeakConnections        int           `json:"peak_connections"`
        ConnectionErrors       int64         `json:"connection_errors"`
}

// CircuitBreakerState represents the state of the circuit breaker.
type CircuitBreakerState int

const (
        CircuitBreakerClosed CircuitBreakerState = iota
        CircuitBreakerOpen
        CircuitBreakerHalfOpen
)

func (s CircuitBreakerState) String() string <span class="cov0" title="0">{
        switch s </span>{
        case CircuitBreakerClosed:<span class="cov0" title="0">
                return "closed"</span>
        case CircuitBreakerOpen:<span class="cov0" title="0">
                return "open"</span>
        case CircuitBreakerHalfOpen:<span class="cov0" title="0">
                return "half-open"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

type connectionPool struct {
        db     *sql.DB
        config Config
        logger zerolog.Logger

        // Use atomic.Bool for lock-free closed state
        closed atomic.Bool

        // Health check state with atomic operations
        lastHealthCheck atomic.Int64 // Unix timestamp
        healthStatus    atomic.Value // string

        // Context for graceful shutdown
        ctx    context.Context
        cancel context.CancelFunc

        // Metrics
        waitCount    atomic.Int64
        waitDuration atomic.Int64

        // Enterprise features
        circuitBreaker      *CircuitBreaker
        metricsCollector    MetricsCollector
        enterpriseStats     *EnterpriseStats
        connectionValidator *ConnectionValidator
        queryLogger         *QueryLogger
        mu                  sync.RWMutex
}

// CircuitBreaker implements the circuit breaker pattern for connection failures.
type CircuitBreaker struct {
        state           atomic.Int32 // CircuitBreakerState
        failures        atomic.Int64
        lastFailureTime atomic.Int64
        threshold       int
        timeout         time.Duration
}

// NewCircuitBreaker creates a new circuit breaker.
func NewCircuitBreaker(threshold int, timeout time.Duration) *CircuitBreaker <span class="cov0" title="0">{
        return &amp;CircuitBreaker{
                threshold: threshold,
                timeout:   timeout,
        }
}</span>

// CanExecute checks if the circuit breaker allows execution.
func (cb *CircuitBreaker) CanExecute() bool <span class="cov0" title="0">{
        state := CircuitBreakerState(cb.state.Load())

        switch state </span>{
        case CircuitBreakerClosed:<span class="cov0" title="0">
                return true</span>
        case CircuitBreakerOpen:<span class="cov0" title="0">
                // Check if timeout has passed
                if time.Since(time.Unix(cb.lastFailureTime.Load(), 0)) &gt; cb.timeout </span><span class="cov0" title="0">{
                        // Try to transition to half-open
                        if cb.state.CompareAndSwap(int32(CircuitBreakerOpen), int32(CircuitBreakerHalfOpen)) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        case CircuitBreakerHalfOpen:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// RecordSuccess records a successful operation.
func (cb *CircuitBreaker) RecordSuccess() <span class="cov0" title="0">{
        cb.failures.Store(0)
        cb.state.Store(int32(CircuitBreakerClosed))
}</span>

// RecordFailure records a failed operation.
func (cb *CircuitBreaker) RecordFailure() <span class="cov0" title="0">{
        failures := cb.failures.Add(1)
        cb.lastFailureTime.Store(time.Now().Unix())

        if failures &gt;= int64(cb.threshold) </span><span class="cov0" title="0">{
                cb.state.Store(int32(CircuitBreakerOpen))
        }</span>
}

// GetState returns the current circuit breaker state.
func (cb *CircuitBreaker) GetState() CircuitBreakerState <span class="cov0" title="0">{
        return CircuitBreakerState(cb.state.Load())
}</span>

// GetFailures returns the current failure count.
func (cb *CircuitBreaker) GetFailures() int64 <span class="cov0" title="0">{
        return cb.failures.Load()
}</span>

// EnterpriseStats tracks comprehensive statistics.
type EnterpriseStats struct {
        retryAttempts      atomic.Int64
        slowQueries        atomic.Int64
        validationFailures atomic.Int64
        acquisitionTimes   []time.Duration
        peakConnections    atomic.Int32
        connectionErrors   atomic.Int64
        mu                 sync.RWMutex
}

// NewEnterpriseStats creates new enterprise statistics tracker.
func NewEnterpriseStats() *EnterpriseStats <span class="cov8" title="7">{
        return &amp;EnterpriseStats{
                acquisitionTimes: make([]time.Duration, 0, 1000), // Ring buffer for last 1000 acquisitions
        }
}</span>

// RecordAcquisitionTime records connection acquisition time.
func (es *EnterpriseStats) RecordAcquisitionTime(duration time.Duration) <span class="cov4" title="3">{
        es.mu.Lock()
        defer es.mu.Unlock()

        // Maintain ring buffer
        if len(es.acquisitionTimes) &gt;= 1000 </span><span class="cov0" title="0">{
                es.acquisitionTimes = es.acquisitionTimes[1:]
        }</span>
        <span class="cov4" title="3">es.acquisitionTimes = append(es.acquisitionTimes, duration)</span>
}

// GetAverageAcquisitionTime returns the average acquisition time.
func (es *EnterpriseStats) GetAverageAcquisitionTime() time.Duration <span class="cov0" title="0">{
        es.mu.RLock()
        defer es.mu.RUnlock()

        if len(es.acquisitionTimes) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var total time.Duration
        for _, t := range es.acquisitionTimes </span><span class="cov0" title="0">{
                total += t
        }</span>

        <span class="cov0" title="0">return total / time.Duration(len(es.acquisitionTimes))</span>
}

// ConnectionValidator validates database connections.
type ConnectionValidator struct {
        logger zerolog.Logger
        config Config
}

// NewConnectionValidator creates a new connection validator.
func NewConnectionValidator(logger zerolog.Logger, config Config) *ConnectionValidator <span class="cov8" title="7">{
        return &amp;ConnectionValidator{
                logger: logger,
                config: config,
        }
}</span>

// ValidateConnection performs comprehensive connection validation.
func (cv *ConnectionValidator) ValidateConnection(ctx context.Context, db *sql.DB) error <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                cv.logger.Debug().
                        Dur("validation_duration", time.Since(start)).
                        Msg("Connection validation completed")
        }</span>()

        // Basic ping test
        <span class="cov0" title="0">if err := db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ping failed: %w", err)
        }</span>

        // Query test
        <span class="cov0" title="0">var result int
        if err := db.QueryRowContext(ctx, "SELECT 1").Scan(&amp;result); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("query test failed: %w", err)
        }</span>

        <span class="cov0" title="0">if result != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("query test returned unexpected result: %d", result)
        }</span>

        // Transaction test
        <span class="cov0" title="0">tx, err := db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction begin failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err := tx.Rollback()
                if err != nil &amp;&amp; err != sql.ErrTxDone </span><span class="cov0" title="0">{
                        cv.logger.Error().Err(err).Msg("failed to rollback transaction")
                }</span>
        }()

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction commit failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// QueryLogger logs slow queries and query statistics.
type QueryLogger struct {
        logger    zerolog.Logger
        threshold time.Duration
        enabled   bool
}

// NewQueryLogger creates a new query logger.
func NewQueryLogger(logger zerolog.Logger, threshold time.Duration, enabled bool) *QueryLogger <span class="cov8" title="7">{
        return &amp;QueryLogger{
                logger:    logger,
                threshold: threshold,
                enabled:   enabled,
        }
}</span>

// LogQuery logs query execution details.
func (ql *QueryLogger) LogQuery(query string, duration time.Duration, err error) <span class="cov0" title="0">{
        if !ql.enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">logEvent := ql.logger.Debug()
        if duration &gt; ql.threshold </span><span class="cov0" title="0">{
                logEvent = ql.logger.Warn().Bool("slow_query", true)
        }</span>

        <span class="cov0" title="0">logEvent.
                Dur("duration", duration).
                Str("query", truncateQuery(query)).
                Bool("success", err == nil).
                Msg("Query executed")

        if err != nil </span><span class="cov0" title="0">{
                ql.logger.Error().
                        Err(err).
                        Str("query", truncateQuery(query)).
                        Msg("Query execution failed")
        }</span>
}

// EnterpriseConnection wraps a database connection with enterprise features.
type EnterpriseConnection struct {
        db              *sql.DB
        pool            *connectionPool
        logger          zerolog.Logger
        validator       *ConnectionValidator
        queryLogger     *QueryLogger
        acquisitionTime time.Time
}

// NewEnterpriseConnection creates a new enterprise connection.
func NewEnterpriseConnection(db *sql.DB, pool *connectionPool) *EnterpriseConnection <span class="cov0" title="0">{
        return &amp;EnterpriseConnection{
                db:              db,
                pool:            pool,
                logger:          pool.logger,
                validator:       pool.connectionValidator,
                queryLogger:     pool.queryLogger,
                acquisitionTime: time.Now(),
        }
}</span>

// Execute executes a query with enterprise features.
func (ec *EnterpriseConnection) Execute(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        return ec.executeWithRetry(ctx, func() (sql.Result, error) </span><span class="cov0" title="0">{
                start := time.Now()
                result, err := ec.db.ExecContext(ctx, query, args...)
                duration := time.Since(start)

                ec.queryLogger.LogQuery(query, duration, err)

                if ec.pool.metricsCollector != nil </span><span class="cov0" title="0">{
                        ec.pool.metricsCollector.RecordQueryExecution(query, duration, err == nil)
                }</span>

                <span class="cov0" title="0">if duration &gt; ec.pool.config.SlowQueryThreshold </span><span class="cov0" title="0">{
                        ec.pool.enterpriseStats.slowQueries.Add(1)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        ec.pool.enterpriseStats.connectionErrors.Add(1)
                        return nil, pkgerrors.Wrap(err, pkgerrors.CodeQueryFailed, "query execution failed")
                }</span>

                <span class="cov0" title="0">return result, nil</span>
        })
}

// Query executes a query and returns rows with enterprise features.
func (ec *EnterpriseConnection) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        start := time.Now()
        rows, err := ec.db.QueryContext(ctx, query, args...)
        duration := time.Since(start)

        ec.queryLogger.LogQuery(query, duration, err)

        if ec.pool.metricsCollector != nil </span><span class="cov0" title="0">{
                ec.pool.metricsCollector.RecordQueryExecution(query, duration, err == nil)
        }</span>

        <span class="cov0" title="0">if duration &gt; ec.pool.config.SlowQueryThreshold </span><span class="cov0" title="0">{
                ec.pool.enterpriseStats.slowQueries.Add(1)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.pool.enterpriseStats.connectionErrors.Add(1)
                return nil, pkgerrors.Wrap(err, pkgerrors.CodeQueryFailed, "query execution failed")
        }</span>

        <span class="cov0" title="0">return rows, nil</span>
}

// executeWithRetry executes an operation with retry logic.
func (ec *EnterpriseConnection) executeWithRetry(ctx context.Context, operation func() (sql.Result, error)) (sql.Result, error) <span class="cov0" title="0">{
        if !ec.pool.config.EnableConnectionRetry </span><span class="cov0" title="0">{
                return operation()
        }</span>

        <span class="cov0" title="0">var lastErr error
        backoff := ec.pool.config.RetryBackoffBase

        for attempt := 0; attempt &lt;= ec.pool.config.MaxRetryAttempts; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        ec.pool.enterpriseStats.retryAttempts.Add(1)
                        if ec.pool.metricsCollector != nil </span><span class="cov0" title="0">{
                                ec.pool.metricsCollector.IncrementRetryAttempt()
                        }</span>

                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return nil, ctx.Err()</span>
                        case &lt;-time.After(backoff):<span class="cov0" title="0">
                                backoff *= 2</span> // Exponential backoff
                        }
                }

                <span class="cov0" title="0">result, err := operation()
                if err == nil </span><span class="cov0" title="0">{
                        return result, nil
                }</span>

                <span class="cov0" title="0">lastErr = err

                // Don't retry certain types of errors
                if !isRetryableError(err) </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil, lastErr</span>
}

// isRetryableError determines if an error is retryable.
func isRetryableError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">errStr := strings.ToLower(err.Error())
        retryablePatterns := []string{
                "connection refused",
                "connection reset",
                "timeout",
                "temporary failure",
                "network",
        }

        for _, pattern := range retryablePatterns </span><span class="cov0" title="0">{
                if strings.Contains(errStr, pattern) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// New creates a new connection pool.
func New(cfg Config, logger zerolog.Logger) (ConnectionPool, error) <span class="cov8" title="8">{
        if cfg.DSN == "" </span><span class="cov0" title="0">{
                cfg.DSN = ":memory:" // Default to in-memory database
        }</span>

        // Set defaults
        <span class="cov8" title="8">if cfg.MaxOpenConnections &lt;= 0 </span><span class="cov8" title="7">{
                cfg.MaxOpenConnections = 25
        }</span>
        <span class="cov8" title="8">if cfg.MaxIdleConnections &lt;= 0 </span><span class="cov8" title="7">{
                cfg.MaxIdleConnections = 5
        }</span>
        <span class="cov8" title="8">if cfg.ConnMaxLifetime &lt;= 0 </span><span class="cov8" title="7">{
                cfg.ConnMaxLifetime = 30 * time.Minute
        }</span>
        <span class="cov8" title="8">if cfg.ConnMaxIdleTime &lt;= 0 </span><span class="cov8" title="7">{
                cfg.ConnMaxIdleTime = 10 * time.Minute
        }</span>
        <span class="cov8" title="8">if cfg.ConnectionTimeout &lt;= 0 </span><span class="cov8" title="7">{
                cfg.ConnectionTimeout = 30 * time.Second
        }</span>

        // Enterprise defaults
        <span class="cov8" title="8">if cfg.CircuitBreakerThreshold &lt;= 0 </span><span class="cov8" title="8">{
                cfg.CircuitBreakerThreshold = 5
        }</span>
        <span class="cov8" title="8">if cfg.CircuitBreakerTimeout &lt;= 0 </span><span class="cov8" title="8">{
                cfg.CircuitBreakerTimeout = 60 * time.Second
        }</span>
        <span class="cov8" title="8">if cfg.MaxRetryAttempts &lt;= 0 </span><span class="cov8" title="8">{
                cfg.MaxRetryAttempts = 3
        }</span>
        <span class="cov8" title="8">if cfg.RetryBackoffBase &lt;= 0 </span><span class="cov8" title="8">{
                cfg.RetryBackoffBase = 100 * time.Millisecond
        }</span>
        <span class="cov8" title="8">if cfg.SlowQueryThreshold &lt;= 0 </span><span class="cov8" title="8">{
                cfg.SlowQueryThreshold = 1 * time.Second
        }</span>

        <span class="cov8" title="8">logger.Info().
                Str("dsn", maskDSN(cfg.DSN)).
                Int("max_open", cfg.MaxOpenConnections).
                Int("max_idle", cfg.MaxIdleConnections).
                Dur("conn_lifetime", cfg.ConnMaxLifetime).
                Dur("conn_idle_time", cfg.ConnMaxIdleTime).
                Bool("circuit_breaker", cfg.EnableCircuitBreaker).
                Bool("retry_enabled", cfg.EnableConnectionRetry).
                Msg("Creating enterprise DuckDB connection pool")

        db, err := sql.Open("duckdb", cfg.DSN)
        if err != nil </span><span class="cov1" title="1">{
                return nil, pkgerrors.Wrap(err, pkgerrors.CodeInternal, "failed to open database")
        }</span>

        // Configure connection pool
        <span class="cov8" title="7">db.SetMaxOpenConns(cfg.MaxOpenConnections)
        db.SetMaxIdleConns(cfg.MaxIdleConnections)
        db.SetConnMaxLifetime(cfg.ConnMaxLifetime)
        db.SetConnMaxIdleTime(cfg.ConnMaxIdleTime)

        ctx, cancel := context.WithCancel(context.Background())

        pool := &amp;connectionPool{
                db:     db,
                config: cfg,
                logger: logger,
                ctx:    ctx,
                cancel: cancel,
        }

        // Initialize enterprise features
        if cfg.EnableCircuitBreaker </span><span class="cov0" title="0">{
                pool.circuitBreaker = NewCircuitBreaker(cfg.CircuitBreakerThreshold, cfg.CircuitBreakerTimeout)
        }</span>

        <span class="cov8" title="7">pool.enterpriseStats = NewEnterpriseStats()
        pool.connectionValidator = NewConnectionValidator(logger, cfg)
        pool.queryLogger = NewQueryLogger(logger, cfg.SlowQueryThreshold, cfg.EnableSlowQueryLogging)

        // Initialize health status
        pool.healthStatus.Store("unknown")

        // Verify connection
        connCtx, connCancel := context.WithTimeout(context.Background(), cfg.ConnectionTimeout)
        defer connCancel()

        if err := pool.HealthCheck(connCtx); err != nil </span><span class="cov0" title="0">{
                db.Close()
                cancel()
                return nil, pkgerrors.Wrap(err, pkgerrors.CodeConnectionFailed, "initial health check failed")
        }</span>

        // Start health check routine if configured
        <span class="cov8" title="7">if cfg.HealthCheckPeriod &gt; 0 </span><span class="cov3" title="2">{
                go pool.healthCheckRoutine(ctx)
        }</span>

        <span class="cov8" title="7">logger.Info().Msg("Enterprise DuckDB connection pool created successfully")

        return pool, nil</span>
}

// Get returns a database connection.
func (p *connectionPool) Get(ctx context.Context) (*sql.DB, error) <span class="cov6" title="5">{
        if p.closed.Load() </span><span class="cov3" title="2">{
                return nil, pkgerrors.New(pkgerrors.CodeUnavailable, "connection pool is closed")
        }</span>

        // Check circuit breaker
        <span class="cov4" title="3">if p.circuitBreaker != nil &amp;&amp; !p.circuitBreaker.CanExecute() </span><span class="cov0" title="0">{
                return nil, pkgerrors.New(pkgerrors.CodeUnavailable, "circuit breaker is open")
        }</span>

        // Track wait time
        <span class="cov4" title="3">start := time.Now()
        p.waitCount.Add(1)
        defer func() </span><span class="cov4" title="3">{
                duration := time.Since(start)
                p.waitDuration.Add(int64(duration))
                p.enterpriseStats.RecordAcquisitionTime(duration)

                if p.metricsCollector != nil </span><span class="cov0" title="0">{
                        p.metricsCollector.RecordConnectionAcquisition(duration)
                }</span>
        }()

        // Verify connection is alive
        <span class="cov4" title="3">if err := p.db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                p.logger.Error().Err(err).Msg("Database ping failed")

                if p.circuitBreaker != nil </span><span class="cov0" title="0">{
                        p.circuitBreaker.RecordFailure()
                }</span>

                <span class="cov0" title="0">return nil, pkgerrors.Wrap(err, pkgerrors.CodeConnectionFailed, "database connection failed")</span>
        }

        <span class="cov4" title="3">if p.circuitBreaker != nil </span><span class="cov0" title="0">{
                p.circuitBreaker.RecordSuccess()
        }</span>

        // Update peak connections
        <span class="cov4" title="3">stats := p.db.Stats()
        if int32(stats.OpenConnections) &gt; p.enterpriseStats.peakConnections.Load() </span><span class="cov4" title="3">{
                p.enterpriseStats.peakConnections.Store(int32(stats.OpenConnections))
        }</span>

        <span class="cov4" title="3">if p.metricsCollector != nil </span><span class="cov0" title="0">{
                p.metricsCollector.UpdateActiveConnections(stats.OpenConnections)
        }</span>

        <span class="cov4" title="3">return p.db, nil</span>
}

// GetWithValidation returns a validated database connection.
func (p *connectionPool) GetWithValidation(ctx context.Context) (*EnterpriseConnection, error) <span class="cov0" title="0">{
        db, err := p.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate connection
        <span class="cov0" title="0">start := time.Now()
        validationErr := p.connectionValidator.ValidateConnection(ctx, db)
        validationDuration := time.Since(start)

        if p.metricsCollector != nil </span><span class="cov0" title="0">{
                p.metricsCollector.RecordConnectionValidation(validationErr == nil, validationDuration)
        }</span>

        <span class="cov0" title="0">if validationErr != nil </span><span class="cov0" title="0">{
                p.enterpriseStats.validationFailures.Add(1)
                return nil, pkgerrors.Wrap(validationErr, pkgerrors.CodeConnectionFailed, "connection validation failed")
        }</span>

        <span class="cov0" title="0">return NewEnterpriseConnection(db, p), nil</span>
}

// Stats returns pool statistics.
func (p *connectionPool) Stats() PoolStats <span class="cov4" title="3">{
        dbStats := p.db.Stats()

        return PoolStats{
                OpenConnections:   dbStats.OpenConnections,
                InUse:             dbStats.InUse,
                Idle:              dbStats.Idle,
                WaitCount:         p.waitCount.Load(),
                WaitDuration:      time.Duration(p.waitDuration.Load()),
                MaxIdleClosed:     dbStats.MaxIdleClosed,
                MaxLifetimeClosed: dbStats.MaxLifetimeClosed,
                LastHealthCheck:   time.Unix(p.lastHealthCheck.Load(), 0),
                HealthCheckStatus: p.getHealthStatus(),
        }
}</span>

// EnterpriseStats returns comprehensive enterprise statistics.
func (p *connectionPool) EnterpriseStats() EnterprisePoolStats <span class="cov0" title="0">{
        stats := p.Stats()

        enterpriseStats := EnterprisePoolStats{
                PoolStats:              stats,
                TotalRetryAttempts:     p.enterpriseStats.retryAttempts.Load(),
                SlowQueries:            p.enterpriseStats.slowQueries.Load(),
                ValidationFailures:     p.enterpriseStats.validationFailures.Load(),
                AverageAcquisitionTime: p.enterpriseStats.GetAverageAcquisitionTime(),
                PeakConnections:        int(p.enterpriseStats.peakConnections.Load()),
                ConnectionErrors:       p.enterpriseStats.connectionErrors.Load(),
        }

        if p.circuitBreaker != nil </span><span class="cov0" title="0">{
                enterpriseStats.CircuitBreakerState = p.circuitBreaker.GetState().String()
                enterpriseStats.CircuitBreakerFailures = p.circuitBreaker.GetFailures()
        }</span>

        <span class="cov0" title="0">return enterpriseStats</span>
}

// SetMetricsCollector sets the metrics collector.
func (p *connectionPool) SetMetricsCollector(collector MetricsCollector) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.metricsCollector = collector
}</span>

// HealthCheck performs a health check on the pool.
func (p *connectionPool) HealthCheck(ctx context.Context) error <span class="cov8" title="9">{
        if p.closed.Load() </span><span class="cov1" title="1">{
                return pkgerrors.New(pkgerrors.CodeUnavailable, "connection pool is closed")
        }</span>

        // Test connection
        <span class="cov8" title="8">if err := p.db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                p.updateHealthStatus("unhealthy", err.Error())
                return pkgerrors.Wrap(err, pkgerrors.CodeConnectionFailed, "health check ping failed")
        }</span>

        // Test query execution
        <span class="cov8" title="8">var result int
        err := p.db.QueryRowContext(ctx, "SELECT 1").Scan(&amp;result)
        if err != nil || result != 1 </span><span class="cov0" title="0">{
                p.updateHealthStatus("unhealthy", "query test failed")
                return pkgerrors.Wrap(err, pkgerrors.CodeConnectionFailed, "health check query failed")
        }</span>

        <span class="cov8" title="8">p.updateHealthStatus("healthy", "")
        return nil</span>
}

// Close closes the connection pool.
func (p *connectionPool) Close() error <span class="cov9" title="10">{
        if !p.closed.CompareAndSwap(false, true) </span><span class="cov4" title="3">{
                return nil // Already closed
        }</span>

        <span class="cov8" title="7">p.logger.Info().Msg("Closing enterprise DuckDB connection pool")

        // Cancel the context to stop health check routine
        p.cancel()

        if err := p.db.Close(); err != nil </span><span class="cov0" title="0">{
                return pkgerrors.Wrap(err, pkgerrors.CodeInternal, "failed to close database")
        }</span>

        <span class="cov8" title="7">return nil</span>
}

// healthCheckRoutine performs periodic health checks until ctx is cancelled.
func (p *connectionPool) healthCheckRoutine(ctx context.Context) <span class="cov3" title="2">{
        ticker := time.NewTicker(p.config.HealthCheckPeriod)
        defer ticker.Stop()

        p.logger.Info().Dur("period", p.config.HealthCheckPeriod).Msg("Health check routine started")

        for </span><span class="cov3" title="2">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov3" title="2">
                        p.logger.Info().Msg("Health check routine stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Create a per-probe timeout
                        probeCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
                        if err := p.HealthCheck(probeCtx); err != nil &amp;&amp; !errors.Is(err, context.Canceled) </span><span class="cov0" title="0">{
                                p.logger.Error().Err(err).Msg("Periodic health check failed")
                        }</span>
                        <span class="cov0" title="0">cancel()</span> // Immediate cleanup
                }
        }
}

// updateHealthStatus updates the health status using atomic operations.
func (p *connectionPool) updateHealthStatus(status, detail string) <span class="cov8" title="8">{
        p.lastHealthCheck.Store(time.Now().Unix())
        p.healthStatus.Store(status)

        if status == "unhealthy" &amp;&amp; detail != "" </span><span class="cov0" title="0">{
                p.logger.Warn().
                        Str("status", status).
                        Str("detail", detail).
                        Msg("Connection pool health status changed")
        }</span>
}

// getHealthStatus safely retrieves the current health status.
func (p *connectionPool) getHealthStatus() string <span class="cov4" title="3">{
        if v := p.healthStatus.Load(); v != nil </span><span class="cov4" title="3">{
                return v.(string)
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}

// maskDSN hides sensitive information (passwords, tokens, secrets) but keeps
// enough of the string to be recognisable in logs.
//
// Behaviour:
//
//   - ":memory:" or empty ‚Üí returned verbatim (special DuckDB value)
//   - URL‚Äëlike DSNs       ‚Üí redact user‚Äëpassword and sensitive query params
//   - Plain paths/files   ‚Üí keep first/last 3 runes, mask the middle
//
// The function is intentionally conservative: if it cannot confidently parse
// the string as a URL it falls back to a simple middle‚Äëmask so that nothing
// secret leaks.
func maskDSN(dsn string) string <span class="cov10" title="12">{
        if dsn == "" || dsn == ":memory:" </span><span class="cov8" title="8">{
                return dsn
        }</span>

        <span class="cov6" title="4">u, err := url.Parse(dsn)
        if err == nil &amp;&amp; looksLikeURL(u) </span><span class="cov4" title="3">{
                // ‚îÄ‚îÄ mask user‚Äëinfo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                if ui := u.User; ui != nil </span><span class="cov1" title="1">{
                        user := ui.Username()
                        if _, hasPass := ui.Password(); hasPass </span><span class="cov1" title="1">{
                                u.User = url.UserPassword(user, "*****")
                        }</span> else<span class="cov0" title="0"> {
                                u.User = url.User(user) // just keep the username
                        }</span>
                }

                // ‚îÄ‚îÄ mask sensitive query params ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                <span class="cov4" title="3">q := u.Query()
                for k := range q </span><span class="cov3" title="2">{
                        if isSensitiveKey(k) </span><span class="cov1" title="1">{
                                q.Set(k, "*****")
                        }</span>
                }
                <span class="cov4" title="3">u.RawQuery = q.Encode()
                return u.String()</span>
        }

        // ‚îÄ‚îÄ fallback: simple masking for non‚ÄëURL DSNs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        <span class="cov1" title="1">runes := []rune(dsn)
        if len(runes) &lt;= 10 </span><span class="cov1" title="1">{
                return "***"
        }</span>
        <span class="cov0" title="0">return string(runes[:3]) + "***" + string(runes[len(runes)-3:])</span>
}

// looksLikeURL returns true when the parsed value has enough URL structure to
// treat it as a DSN we can meaningfully redact.
func looksLikeURL(u *url.URL) bool <span class="cov6" title="4">{
        return u.Scheme != "" || u.Host != "" || u.User != nil || u.RawQuery != ""
}</span>

// isSensitiveKey reports whether a query key should have its value masked.
func isSensitiveKey(key string) bool <span class="cov3" title="2">{
        key = strings.ToLower(key)
        switch </span>{
        case strings.Contains(key, "pass"),
                strings.Contains(key, "token"),
                strings.Contains(key, "secret"),
                strings.HasSuffix(key, "key"):<span class="cov1" title="1">
                return true</span>
        default:<span class="cov1" title="1">
                return false</span>
        }
}

// ConnectionWrapper wraps a database connection with additional functionality.
type ConnectionWrapper struct {
        db     *sql.DB
        pool   *connectionPool
        logger zerolog.Logger
}

// NewConnectionWrapper creates a new connection wrapper.
func NewConnectionWrapper(db *sql.DB, pool *connectionPool, logger zerolog.Logger) *ConnectionWrapper <span class="cov1" title="1">{
        return &amp;ConnectionWrapper{
                db:     db,
                pool:   pool,
                logger: logger,
        }
}</span>

// Execute executes a query with retry logic.
func (w *ConnectionWrapper) Execute(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov3" title="2">{
        start := time.Now()
        result, err := w.db.ExecContext(ctx, query, args...)

        w.logger.Debug().
                Dur("duration", time.Since(start)).
                Str("query", truncateQuery(query)).
                Bool("success", err == nil).
                Msg("Executed query")

        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.Wrap(err, pkgerrors.CodeQueryFailed, "query execution failed")
        }</span>

        <span class="cov3" title="2">return result, nil</span>
}

// Query executes a query and returns rows.
func (w *ConnectionWrapper) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov1" title="1">{
        start := time.Now()
        rows, err := w.db.QueryContext(ctx, query, args...)

        w.logger.Debug().
                Dur("duration", time.Since(start)).
                Str("query", truncateQuery(query)).
                Bool("success", err == nil).
                Msg("Executed query")

        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.Wrap(err, pkgerrors.CodeQueryFailed, "query execution failed")
        }</span>

        <span class="cov1" title="1">return rows, nil</span>
}

// truncateQuery truncates long queries for logging.
func truncateQuery(query string) string <span class="cov4" title="3">{
        const maxLen = 100
        if len(query) &lt;= maxLen </span><span class="cov4" title="3">{
                return query
        }</span>
        <span class="cov0" title="0">return query[:maxLen] + "..."</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package pool

import (
        "sync"
        "sync/atomic"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/array"
        "github.com/apache/arrow-go/v18/arrow/memory"
)

// poolConfig holds configuration for the record pool
type poolConfig struct {
        minSize     int     // minimum batch size
        maxSize     int     // maximum batch size
        targetAlloc int64   // target allocation per batch
        growthRate  float64 // how fast to grow batch size
}

// defaultConfig returns sensible defaults
func defaultConfig() poolConfig <span class="cov2" title="5">{
        return poolConfig{
                minSize:     1024,
                maxSize:     32768,
                targetAlloc: 4 * 1024 * 1024, // 4MB target
                growthRate:  1.5,
        }
}</span>

// FastRecordPool is a concurrent, multi‚Äëschema pool optimised for throughput.
type FastRecordPool struct {
        alloc  memory.Allocator // usually the Arrow global allocator
        pools  sync.Map         // *arrow.Schema ‚Üí *sync.Pool
        config poolConfig
        stats  struct {
                hits   atomic.Int64
                misses atomic.Int64
                allocs atomic.Int64
        }
}

// NewFastRecordPool constructs a pool; pass nil for the default Go allocator.
func NewFastRecordPool(alloc memory.Allocator) *FastRecordPool <span class="cov2" title="5">{
        if alloc == nil </span><span class="cov2" title="5">{
                alloc = memory.NewGoAllocator()
        }</span>
        <span class="cov2" title="5">return &amp;FastRecordPool{
                alloc:  alloc,
                config: defaultConfig(),
        }</span>
}

// getPool returns the per‚Äëschema sync.Pool, creating it if necessary.
func (p *FastRecordPool) getPool(schema *arrow.Schema) *sync.Pool <span class="cov8" title="1003">{
        if v, ok := p.pools.Load(schema); ok </span><span class="cov8" title="999">{
                return v.(*sync.Pool)
        }</span>

        // First writer wins; others reuse the stored pool.
        <span class="cov2" title="4">newPool := &amp;sync.Pool{
                New: func() interface{} </span><span class="cov2" title="4">{
                        p.stats.allocs.Add(1)
                        cols := make([]arrow.Array, len(schema.Fields()))
                        for i, f := range schema.Fields() </span><span class="cov3" title="12">{
                                cols[i] = array.MakeArrayOfNull(p.alloc, f.Type, 0)
                        }</span>
                        <span class="cov2" title="4">return array.NewRecord(schema, cols, 0)</span>
                },
        }
        <span class="cov2" title="4">actual, _ := p.pools.LoadOrStore(schema, newPool)
        return actual.(*sync.Pool)</span>
}

// Get returns an empty record for the given schema.
func (p *FastRecordPool) Get(schema *arrow.Schema) arrow.Record <span class="cov8" title="1003">{
        rec := p.getPool(schema).Get().(arrow.Record)
        if rec != nil </span><span class="cov8" title="1003">{
                p.stats.hits.Add(1)
                return rec
        }</span>
        <span class="cov0" title="0">p.stats.misses.Add(1)
        return nil</span>
}

// Put resets the record to zero‚Äëlength and puts it back.
func (p *FastRecordPool) Put(rec arrow.Record) <span class="cov8" title="1002">{
        if rec == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1002">v, ok := p.pools.Load(rec.Schema())
        if !ok </span><span class="cov1" title="2">{
                rec.Release()
                return
        }</span>
        <span class="cov8" title="1000">pool := v.(*sync.Pool)

        // Re‚Äëslice columns to length 0 ‚Äì O(1), no new buffers.
        cols := make([]arrow.Array, rec.NumCols())
        for i := 0; i &lt; int(rec.NumCols()); i++ </span><span class="cov10" title="3000">{
                col := rec.Column(i)
                cols[i] = array.NewSlice(col, 0, 0) // shares buffers, cheap
                col.Release()                       // drop the old reference
        }</span>

        // Replace the record with the zero‚Äëlength version.
        <span class="cov8" title="1000">empty := array.NewRecord(rec.Schema(), cols, 0)
        pool.Put(empty)</span>
}

// Stats returns current pool statistics
type Stats struct {
        Hits   int64
        Misses int64
        Allocs int64
}

// Stats returns current statistics for the pool
func (p *FastRecordPool) Stats() Stats <span class="cov0" title="0">{
        return Stats{
                Hits:   p.stats.hits.Load(),
                Misses: p.stats.misses.Load(),
                Allocs: p.stats.allocs.Load(),
        }
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package pool

import (
        "container/list"
        "sync"
        "sync/atomic"
        "time"

        "github.com/apache/arrow-go/v18/arrow"
)

// entry holds bookkeeping for one schema.
type entry struct {
        schema    *arrow.Schema
        createdAt time.Time
        lastUsed  atomic.Int64 // unix‚Äënanos
        hits      atomic.Int64
}

// SchemaCache is an O(1) LRU cache (pointer‚Äëkeyed, thread‚Äësafe).
type SchemaCache struct {
        cap   int
        mu    sync.Mutex
        lru   *list.List                      // front = most‚Äërecent
        items map[*arrow.Schema]*list.Element // schema ‚Üí *list.Element
}

// NewSchemaCache returns a cache with a given maximum size (&gt;0).
func NewSchemaCache(max int) *SchemaCache <span class="cov1" title="1">{
        if max &lt;= 0 </span><span class="cov0" title="0">{
                max = 100
        }</span>
        <span class="cov1" title="1">return &amp;SchemaCache{
                cap:   max,
                lru:   list.New(),
                items: make(map[*arrow.Schema]*list.Element, max),
        }</span>
}

// Get returns the cached entry (updates LRU &amp; stats) or nil/false.
func (c *SchemaCache) Get(s *arrow.Schema) (*arrow.Schema, bool) <span class="cov10" title="1008">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if ele, ok := c.items[s]; ok </span><span class="cov3" title="6">{
                c.lru.MoveToFront(ele)
                e := ele.Value.(*entry)
                e.hits.Add(1)
                e.lastUsed.Store(time.Now().UnixNano())
                return e.schema, true
        }</span>
        <span class="cov9" title="1002">return nil, false</span>
}

// Put inserts the schema or refreshes its position if already cached.
func (c *SchemaCache) Put(s *arrow.Schema) <span class="cov9" title="1006">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if ele, ok := c.items[s]; ok </span><span class="cov9" title="1000">{
                c.lru.MoveToFront(ele)
                e := ele.Value.(*entry)
                e.hits.Add(1)
                e.lastUsed.Store(time.Now().UnixNano())
                return
        }</span>

        <span class="cov3" title="6">e := &amp;entry{
                schema:    s,
                createdAt: time.Now(),
        }
        e.lastUsed.Store(e.createdAt.UnixNano())
        e.hits.Store(1)

        ele := c.lru.PushFront(e)
        c.items[s] = ele

        if len(c.items) &gt; c.cap </span><span class="cov1" title="1">{
                c.evictOldest()
        }</span>
}

// evictOldest removes the LRU element (caller holds the lock).
func (c *SchemaCache) evictOldest() <span class="cov1" title="1">{
        ele := c.lru.Back()
        if ele == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">c.lru.Remove(ele)
        e := ele.Value.(*entry)
        delete(c.items, e.schema)</span>
}

// Clear empties the cache.
func (c *SchemaCache) Clear() <span class="cov2" title="3">{
        c.mu.Lock()
        c.lru.Init()
        c.items = make(map[*arrow.Schema]*list.Element, c.cap)
        c.mu.Unlock()
}</span>

// Size returns the current number of cached schemas.
func (c *SchemaCache) Size() int <span class="cov2" title="3">{
        c.mu.Lock()
        n := len(c.items)
        c.mu.Unlock()
        return n
}</span>

// CacheStats contains live statistics.
type CacheStats struct {
        Size      int
        Cap       int
        TotalHits int64
        OldestAge time.Duration
}

// Stats gathers statistics (O(n), called rarely).
func (c *SchemaCache) Stats() CacheStats <span class="cov2" title="3">{
        c.mu.Lock()
        defer c.mu.Unlock()

        var (
                total int64
                old   time.Time
                now   = time.Now()
        )

        for e := c.lru.Back(); e != nil; e = e.Prev() </span><span class="cov2" title="3">{
                ent := e.Value.(*entry)
                total += ent.hits.Load()
                if old.IsZero() || ent.createdAt.Before(old) </span><span class="cov2" title="3">{
                        old = ent.createdAt
                }</span>
        }

        <span class="cov2" title="3">age := time.Duration(0)
        if !old.IsZero() </span><span class="cov1" title="2">{
                age = now.Sub(old)
        }</span>
        <span class="cov2" title="3">return CacheStats{
                Size:      len(c.items),
                Cap:       c.cap,
                TotalHits: total,
                OldestAge: age,
        }</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package infrastructure provides enterprise-grade infrastructure
// services for Porter.
package infrastructure

import (
        "database/sql"
        "sync"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/array"
        "github.com/apache/arrow-go/v18/arrow/flight/flightsql"
        "github.com/apache/arrow-go/v18/arrow/flight/flightsql/schema_ref"
        "github.com/apache/arrow-go/v18/arrow/memory"

        "github.com/TFMV/porter/pkg/models"
)

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// SQL‚ÄëINFO PROVIDER
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// SQLInfoProvider exposes DuckDB/Porter SQL capabilities.
type SQLInfoProvider struct {
        once     sync.Once
        alloc    memory.Allocator
        info     map[uint32]interface{}
        infoCopy []models.SQLInfo // cached slice for GetSQLInfo(nil)
}

// NewSQLInfoProvider returns a ready‚Äëto‚Äëuse provider.
func NewSQLInfoProvider(alloc memory.Allocator) *SQLInfoProvider <span class="cov0" title="0">{
        return &amp;SQLInfoProvider{alloc: alloc}
}</span>

func (p *SQLInfoProvider) ensureInit() <span class="cov0" title="0">{
        p.once.Do(func() </span><span class="cov0" title="0">{
                p.info = make(map[uint32]interface{}, 32)

                add := func(k flightsql.SqlInfo, v interface{}) </span><span class="cov0" title="0">{
                        p.info[uint32(k)] = v
                }</span>

                // Flight SQL identification
                <span class="cov0" title="0">add(flightsql.SqlInfoFlightSqlServerName, "Porter")
                add(flightsql.SqlInfoFlightSqlServerVersion, "2.0.0")
                add(flightsql.SqlInfoFlightSqlServerArrowVersion, "18.0.0")
                add(flightsql.SqlInfoFlightSqlServerReadOnly, false)
                add(flightsql.SqlInfoFlightSqlServerTransaction, int32(flightsql.SqlTransactionTransaction))

                // Language support
                add(flightsql.SqlInfoDDLCatalog, false)
                add(flightsql.SqlInfoDDLSchema, true)
                add(flightsql.SqlInfoDDLTable, true)

                // Identifier behaviour
                add(flightsql.SqlInfoIdentifierCase, int64(flightsql.SqlCaseSensitivityCaseInsensitive))
                add(flightsql.SqlInfoIdentifierQuoteChar, `"`)
                add(flightsql.SqlInfoQuotedIdentifierCase, int64(flightsql.SqlCaseSensitivityCaseInsensitive))

                // Sorting / NULL ordering
                add(flightsql.SqlInfoNullOrdering, int64(flightsql.SqlNullOrderingSortAtStart))

                add(flightsql.SqlInfoAllTablesAreASelectable, true)
                add(flightsql.SqlInfoTransactionsSupported, true)

                // Keywords / functions (pre‚Äëallocated capacity improves append perf)
                add(flightsql.SqlInfoKeywords, duckdbKeywords)
                add(flightsql.SqlInfoNumericFunctions, duckdbNumericFns)
                add(flightsql.SqlInfoStringFunctions, duckdbStringFns)

                add(flightsql.SqlInfoSupportsConvert, map[int32][]int32{
                        int32(flightsql.SqlConvertBigInt): {int32(flightsql.SqlConvertInteger)},
                })

                // Cache full copy
                p.infoCopy = make([]models.SQLInfo, 0, len(p.info))
                for k, v := range p.info </span><span class="cov0" title="0">{
                        p.infoCopy = append(p.infoCopy, models.SQLInfo{InfoName: k, Value: v})
                }</span>
        })
}

// GetSQLInfo implements the Flight SQL "GetSqlInfo" RPC semantics.
func (p *SQLInfoProvider) GetSQLInfo(ids []uint32) ([]models.SQLInfo, error) <span class="cov0" title="0">{
        p.ensureInit()

        // "0 ids" means "all".
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return append([]models.SQLInfo(nil), p.infoCopy...), nil // shallow copy
        }</span>

        <span class="cov0" title="0">out := make([]models.SQLInfo, 0, len(ids))
        for _, id := range ids </span><span class="cov0" title="0">{
                if v, ok := p.info[id]; ok </span><span class="cov0" title="0">{
                        out = append(out, models.SQLInfo{InfoName: id, Value: v})
                }</span>
        }
        <span class="cov0" title="0">return out, nil</span>
}

// GetSQLInfoResultMap returns the provider's internal map in Flight format.
// Map is copied to avoid caller mutation.
func (p *SQLInfoProvider) GetSQLInfoResultMap() flightsql.SqlInfoResultMap <span class="cov0" title="0">{
        p.ensureInit()
        cp := make(map[uint32]interface{}, len(p.info))
        for k, v := range p.info </span><span class="cov0" title="0">{
                cp[k] = v
        }</span>
        <span class="cov0" title="0">return flightsql.SqlInfoResultMap(cp)</span>
}

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// XDBC TYPE‚ÄëINFO PROVIDER
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Searchability describes how a type can appear in WHERE clauses.
type Searchability int32

const (
        SearchableNone Searchability = iota
        SearchableLike
        SearchableNoLike
        SearchableFull
)

// XdbcTypeInfoProvider serves XDBC type metadata.
type XdbcTypeInfoProvider struct {
        types []models.XdbcTypeInfo
}

// NewXdbcTypeInfoProvider constructs with built‚Äëin Porter/DuckDB types.
func NewXdbcTypeInfoProvider() *XdbcTypeInfoProvider <span class="cov0" title="0">{
        return &amp;XdbcTypeInfoProvider{
                types: []models.XdbcTypeInfo{
                        // BOOLEAN
                        xdbcBool(),
                        // TINYINT
                        xdbcNumeric("TINYINT", java_sql_Types_TINYINT, 3),
                        // add more as needed‚Ä¶
                },
        }
}</span>

// GetTypeInfo filters by dataType when provided.
func (p *XdbcTypeInfoProvider) GetTypeInfo(dataType *int32) []models.XdbcTypeInfo <span class="cov0" title="0">{
        if dataType == nil </span><span class="cov0" title="0">{
                return p.types
        }</span>
        <span class="cov0" title="0">out := make([]models.XdbcTypeInfo, 0, 4)
        for _, t := range p.types </span><span class="cov0" title="0">{
                if t.DataType == *dataType </span><span class="cov0" title="0">{
                        out = append(out, t)
                }</span>
        }
        <span class="cov0" title="0">return out</span>
}

// GetTypeInfoResult builds an Arrow record for the XDBC response.
func (p *XdbcTypeInfoProvider) GetTypeInfoResult(alloc memory.Allocator, dt *int32) arrow.Record <span class="cov0" title="0">{
        rows := p.GetTypeInfo(dt)

        b := array.NewRecordBuilder(alloc, schema_ref.XdbcTypeInfo)
        defer b.Release()

        appendAny := func(i int, v sql.NullString) </span><span class="cov0" title="0">{
                if v.Valid </span><span class="cov0" title="0">{
                        b.Field(i).(*array.StringBuilder).Append(v.String)
                }</span> else<span class="cov0" title="0"> {
                        b.Field(i).AppendNull()
                }</span>
        }
        <span class="cov0" title="0">appendInt := func(i int, v sql.NullInt32) </span><span class="cov0" title="0">{
                if v.Valid </span><span class="cov0" title="0">{
                        b.Field(i).(*array.Int32Builder).Append(v.Int32)
                }</span> else<span class="cov0" title="0"> {
                        b.Field(i).AppendNull()
                }</span>
        }
        <span class="cov0" title="0">appendBool := func(i int, v sql.NullBool) </span><span class="cov0" title="0">{
                if v.Valid </span><span class="cov0" title="0">{
                        b.Field(i).(*array.BooleanBuilder).Append(v.Bool)
                }</span> else<span class="cov0" title="0"> {
                        b.Field(i).AppendNull()
                }</span>
        }

        <span class="cov0" title="0">for _, t := range rows </span><span class="cov0" title="0">{
                b.Field(0).(*array.StringBuilder).Append(t.TypeName)
                b.Field(1).(*array.Int32Builder).Append(t.DataType)
                appendInt(2, t.ColumnSize)
                appendAny(3, t.LiteralPrefix)
                appendAny(4, t.LiteralSuffix)
                appendAny(5, t.CreateParams)
                b.Field(6).(*array.Int32Builder).Append(t.Nullable)
                b.Field(7).(*array.BooleanBuilder).Append(t.CaseSensitive)
                b.Field(8).(*array.Int32Builder).Append(t.Searchable)
                appendBool(9, t.UnsignedAttribute)
                b.Field(10).(*array.BooleanBuilder).Append(t.FixedPrecScale)
                appendBool(11, t.AutoIncrement)
                appendAny(12, t.LocalTypeName)
                appendInt(13, t.MinimumScale)
                appendInt(14, t.MaximumScale)
                b.Field(15).(*array.Int32Builder).Append(t.SQLDataType)
                appendInt(16, t.DatetimeSubcode)
                appendInt(17, t.NumPrecRadix)
                b.Field(18).AppendNull() // interval_precision
        }</span>

        <span class="cov0" title="0">return b.NewRecord()</span>
}

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// helpers for type info construction
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func xdbcBool() models.XdbcTypeInfo <span class="cov0" title="0">{
        return models.XdbcTypeInfo{
                TypeName:          "BOOLEAN",
                DataType:          java_sql_Types_BOOLEAN,
                ColumnSize:        sqlNullInt32(1),
                Nullable:          1,
                CaseSensitive:     false,
                Searchable:        int32(SearchableFull),
                UnsignedAttribute: sqlNullBool(false),
                FixedPrecScale:    true,
                AutoIncrement:     sqlNullBool(false),
                LocalTypeName:     sqlNullString("BOOLEAN"),
                SQLDataType:       java_sql_Types_BOOLEAN,
                NumPrecRadix:      sqlNullInt32(10),
        }
}</span>

func xdbcNumeric(name string, sqlType int32, prec int32) models.XdbcTypeInfo <span class="cov0" title="0">{
        return models.XdbcTypeInfo{
                TypeName:          name,
                DataType:          sqlType,
                ColumnSize:        sqlNullInt32(prec),
                Nullable:          1,
                CaseSensitive:     false,
                Searchable:        int32(SearchableFull),
                UnsignedAttribute: sqlNullBool(false),
                FixedPrecScale:    true,
                AutoIncrement:     sqlNullBool(false),
                LocalTypeName:     sqlNullString(name),
                SQLDataType:       sqlType,
                NumPrecRadix:      sqlNullInt32(10),
        }
}</span>

func sqlNullString(s string) sql.NullString <span class="cov0" title="0">{ return sql.NullString{String: s, Valid: true} }</span>
func sqlNullInt32(i int32) sql.NullInt32    <span class="cov0" title="0">{ return sql.NullInt32{Int32: i, Valid: true} }</span>
func sqlNullBool(b bool) sql.NullBool       <span class="cov0" title="0">{ return sql.NullBool{Bool: b, Valid: true} }</span>

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// constants
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// DuckDB keyword / function sets
var (
        duckdbKeywords = []string{
                "ABORT", "ACTION", "ADD", "AFTER", "ALL", "ALTER", "AND", "ANY",
                "AS", "ASC", "ATTACH", "AUTOINCREMENT", "BEFORE", "BEGIN", "BETWEEN",
                "BY", "CASCADE", "CASE", "CAST", "CHECK", "COLLATE", "COLUMN",
                "COMMIT", "CONFLICT", "CONSTRAINT", "CREATE", "CROSS", "CURRENT_DATE",
                "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATABASE", "DEFAULT", "DEFERRABLE",
                "DEFERRED", "DELETE", "DESC", "DETACH", "DISTINCT", "DROP", "EACH",
                "ELSE", "END", "ESCAPE", "EXCEPT", "EXCLUDE", "EXISTS", "EXPLAIN",
                "FAIL", "FILTER", "FIRST", "FOLLOWING", "FOR", "FOREIGN", "FROM",
                "FULL", "GROUP", "HAVING", "IF", "IGNORE", "IMMEDIATE", "IN",
                "INDEX", "INITIALLY", "INNER", "INSERT", "INSTEAD", "INTERSECT",
                "INTO", "IS", "ISNULL", "JOIN", "KEY", "LAST", "LEFT", "LIKE",
                "LIMIT", "MATCH", "NATURAL", "NO", "NOT", "NOTNULL", "NULL",
                "OF", "OFFSET", "ON", "OR", "ORDER", "OUTER", "OVER", "PARTITION",
                "PLAN", "PRAGMA", "PRIMARY", "RANGE", "RECURSIVE", "REFERENCES",
                "REINDEX", "RELEASE", "RENAME", "REPLACE", "RESTRICT", "RETURNING",
                "RIGHT", "ROLLBACK", "ROW", "ROWS", "SAVEPOINT", "SELECT", "SET",
                "TABLE", "TEMP", "TEMPORARY", "THEN", "TIES", "TO", "TRANSACTION",
                "TRIGGER", "UNBOUNDED", "UNION", "UNIQUE", "UPDATE", "USING",
                "VACUUM", "VALUES", "VIEW", "VIRTUAL", "WHEN", "WHERE", "WINDOW",
                "WITH", "WITHOUT",
        }

        duckdbNumericFns = []string{
                "ABS", "ACOS", "ASIN", "ATAN", "ATAN2", "CEIL", "CEILING", "COS",
                "COT", "DEGREES", "DIV", "EXP", "FLOOR", "LN", "LOG", "MOD",
                "PI", "POW", "POWER", "RADIANS", "RAND", "RANDOM", "ROUND", "SIGN",
                "SIN", "SQRT", "TAN", "TRUNC", "WIDTH_BUCKET",
        }

        duckdbStringFns = []string{
                "ASCII", "CHAR", "CHAR_LENGTH", "CHR", "CONCAT", "CONTAINS",
                "ENDS_WITH", "INITCAP", "LEFT", "LENGTH", "LIKE", "LOWER",
                "LPAD", "LTRIM", "POSITION", "REGEXP_MATCHES", "REGEXP_REPLACE",
                "REGEXP_EXTRACT", "REPEAT", "REPLACE", "REVERSE", "RIGHT", "RPAD",
                "RTRIM", "SPLIT_PART", "STARTS_WITH", "STRPOS", "SUBSTRING", "TRIM",
                "UPPER",
        }
)

// Java SQL Types (JDBC) ‚Äì extend as needed
const (
        java_sql_Types_BIT           = -7
        java_sql_Types_TINYINT       = -6
        java_sql_Types_SMALLINT      = 5
        java_sql_Types_INTEGER       = 4
        java_sql_Types_BIGINT        = -5
        java_sql_Types_FLOAT         = 6
        java_sql_Types_REAL          = 7
        java_sql_Types_DOUBLE        = 8
        java_sql_Types_NUMERIC       = 2
        java_sql_Types_DECIMAL       = 3
        java_sql_Types_CHAR          = 1
        java_sql_Types_VARCHAR       = 12
        java_sql_Types_LONGVARCHAR   = -1
        java_sql_Types_DATE          = 91
        java_sql_Types_TIME          = 92
        java_sql_Types_TIMESTAMP     = 93
        java_sql_Types_BINARY        = -2
        java_sql_Types_VARBINARY     = -3
        java_sql_Types_LONGVARBINARY = -4
        java_sql_Types_BOOLEAN       = 16
        java_sql_Types_NULL          = 0
        java_sql_Types_OTHER         = 1111
        java_sql_Types_BLOB          = 2004
        java_sql_Types_CLOB          = 2005
        java_sql_Types_ARRAY         = 2003
        java_sql_Types_STRUCT        = 2002
        java_sql_Types_REF           = 2006
        java_sql_Types_DATALINK      = 70
        java_sql_Types_ROWID         = -8
        java_sql_Types_SQLXML        = 2009
        java_sql_Types_NCHAR         = -15
        java_sql_Types_NVARCHAR      = -9
        java_sql_Types_LONGNVARCHAR  = -16
        java_sql_Types_NCLOB         = 2011
        java_sql_Types_REF_CURSOR    = 2012
        java_sql_Types_TIME_WITH_TZ  = 2013
        java_sql_Types_TIMESTAMP_TZ  = 2014
)
</pre>
		
		<pre class="file" id="file32" style="display: none">// Package models provides data structures used throughout the Flight SQL server.
package models

import (
        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/array"
        "github.com/apache/arrow-go/v18/arrow/memory"
)

// GetCatalogsSchema returns the Arrow schema for catalog results.
func GetCatalogsSchema() *arrow.Schema <span class="cov1" title="1">{
        return arrow.NewSchema([]arrow.Field{
                {Name: "catalog_name", Type: arrow.BinaryTypes.String, Nullable: false},
        }, nil)
}</span>

// GetDBSchemasSchema returns the Arrow schema for database schema results.
func GetDBSchemasSchema() *arrow.Schema <span class="cov1" title="1">{
        return arrow.NewSchema([]arrow.Field{
                {Name: "catalog_name", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "db_schema_name", Type: arrow.BinaryTypes.String, Nullable: false},
        }, nil)
}</span>

// GetTablesSchema returns the Arrow schema for table results.
func GetTablesSchema(includeSchema bool) *arrow.Schema <span class="cov1" title="1">{
        fields := []arrow.Field{
                {Name: "catalog_name", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "db_schema_name", Type: arrow.BinaryTypes.String, Nullable: false},
                {Name: "table_name", Type: arrow.BinaryTypes.String, Nullable: false},
                {Name: "table_type", Type: arrow.BinaryTypes.String, Nullable: false},
        }

        if includeSchema </span><span class="cov1" title="1">{
                fields = append(fields, arrow.Field{
                        Name:     "table_schema",
                        Type:     arrow.BinaryTypes.Binary,
                        Nullable: true,
                })
        }</span>

        <span class="cov1" title="1">return arrow.NewSchema(fields, nil)</span>
}

// GetTableTypesSchema returns the Arrow schema for table type results.
func GetTableTypesSchema() *arrow.Schema <span class="cov0" title="0">{
        return arrow.NewSchema([]arrow.Field{
                {Name: "table_type", Type: arrow.BinaryTypes.String, Nullable: false},
        }, nil)
}</span>

// GetColumnsSchema returns the Arrow schema for column metadata results.
func GetColumnsSchema() *arrow.Schema <span class="cov0" title="0">{
        return arrow.NewSchema([]arrow.Field{
                {Name: "table_cat", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "table_schem", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "table_name", Type: arrow.BinaryTypes.String, Nullable: false},
                {Name: "column_name", Type: arrow.BinaryTypes.String, Nullable: false},
                {Name: "data_type", Type: arrow.PrimitiveTypes.Int32, Nullable: false},
                {Name: "type_name", Type: arrow.BinaryTypes.String, Nullable: false},
                {Name: "column_size", Type: arrow.PrimitiveTypes.Int32, Nullable: true},
                {Name: "decimal_digits", Type: arrow.PrimitiveTypes.Int32, Nullable: true},
                {Name: "num_prec_radix", Type: arrow.PrimitiveTypes.Int32, Nullable: true},
                {Name: "nullable", Type: arrow.PrimitiveTypes.Int32, Nullable: false},
                {Name: "remarks", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "column_def", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "sql_data_type", Type: arrow.PrimitiveTypes.Int32, Nullable: true},
                {Name: "char_octet_length", Type: arrow.PrimitiveTypes.Int32, Nullable: true},
                {Name: "ordinal_position", Type: arrow.PrimitiveTypes.Int32, Nullable: false},
                {Name: "is_nullable", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "is_autoincrement", Type: arrow.FixedWidthTypes.Boolean, Nullable: true},
                {Name: "is_generatedcolumn", Type: arrow.FixedWidthTypes.Boolean, Nullable: true},
        }, nil)
}</span>

// GetPrimaryKeysSchema returns the Arrow schema for primary key results.
func GetPrimaryKeysSchema() *arrow.Schema <span class="cov1" title="1">{
        return arrow.NewSchema([]arrow.Field{
                {Name: "catalog_name", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "db_schema_name", Type: arrow.BinaryTypes.String, Nullable: false},
                {Name: "table_name", Type: arrow.BinaryTypes.String, Nullable: false},
                {Name: "column_name", Type: arrow.BinaryTypes.String, Nullable: false},
                {Name: "key_sequence", Type: arrow.PrimitiveTypes.Int32, Nullable: false},
                {Name: "key_name", Type: arrow.BinaryTypes.String, Nullable: true},
        }, nil)
}</span>

// GetImportedKeysSchema returns the Arrow schema for imported foreign key results.
func GetImportedKeysSchema() *arrow.Schema <span class="cov0" title="0">{
        return GetForeignKeysSchema()
}</span>

// GetExportedKeysSchema returns the Arrow schema for exported foreign key results.
func GetExportedKeysSchema() *arrow.Schema <span class="cov0" title="0">{
        return GetForeignKeysSchema()
}</span>

// GetForeignKeysSchema returns the Arrow schema for foreign key results.
func GetForeignKeysSchema() *arrow.Schema <span class="cov0" title="0">{
        return arrow.NewSchema([]arrow.Field{
                {Name: "pk_catalog_name", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "pk_db_schema_name", Type: arrow.BinaryTypes.String, Nullable: false},
                {Name: "pk_table_name", Type: arrow.BinaryTypes.String, Nullable: false},
                {Name: "pk_column_name", Type: arrow.BinaryTypes.String, Nullable: false},
                {Name: "fk_catalog_name", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "fk_db_schema_name", Type: arrow.BinaryTypes.String, Nullable: false},
                {Name: "fk_table_name", Type: arrow.BinaryTypes.String, Nullable: false},
                {Name: "fk_column_name", Type: arrow.BinaryTypes.String, Nullable: false},
                {Name: "key_sequence", Type: arrow.PrimitiveTypes.Int32, Nullable: false},
                {Name: "fk_key_name", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "pk_key_name", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "update_rule", Type: arrow.PrimitiveTypes.Uint8, Nullable: false},
                {Name: "delete_rule", Type: arrow.PrimitiveTypes.Uint8, Nullable: false},
        }, nil)
}</span>

// GetXdbcTypeInfoSchema returns the Arrow schema for XDBC type info results.
func GetXdbcTypeInfoSchema() *arrow.Schema <span class="cov1" title="1">{
        return arrow.NewSchema([]arrow.Field{
                {Name: "type_name", Type: arrow.BinaryTypes.String, Nullable: false},
                {Name: "data_type", Type: arrow.PrimitiveTypes.Int32, Nullable: false},
                {Name: "column_size", Type: arrow.PrimitiveTypes.Int32, Nullable: true},
                {Name: "literal_prefix", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "literal_suffix", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "create_params", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "nullable", Type: arrow.PrimitiveTypes.Int32, Nullable: false},
                {Name: "case_sensitive", Type: arrow.FixedWidthTypes.Boolean, Nullable: false},
                {Name: "searchable", Type: arrow.PrimitiveTypes.Int32, Nullable: false},
                {Name: "unsigned_attribute", Type: arrow.FixedWidthTypes.Boolean, Nullable: true},
                {Name: "fixed_prec_scale", Type: arrow.FixedWidthTypes.Boolean, Nullable: false},
                {Name: "auto_increment", Type: arrow.FixedWidthTypes.Boolean, Nullable: true},
                {Name: "local_type_name", Type: arrow.BinaryTypes.String, Nullable: true},
                {Name: "minimum_scale", Type: arrow.PrimitiveTypes.Int32, Nullable: true},
                {Name: "maximum_scale", Type: arrow.PrimitiveTypes.Int32, Nullable: true},
                {Name: "sql_data_type", Type: arrow.PrimitiveTypes.Int32, Nullable: false},
                {Name: "datetime_subcode", Type: arrow.PrimitiveTypes.Int32, Nullable: true},
                {Name: "num_prec_radix", Type: arrow.PrimitiveTypes.Int32, Nullable: true},
                {Name: "interval_precision", Type: arrow.PrimitiveTypes.Int32, Nullable: true},
        }, nil)
}</span>

// GetSqlInfoSchema returns the Arrow schema for SQL info results.
func GetSqlInfoSchema() *arrow.Schema <span class="cov4" title="2">{
        // SQL info uses a dense union type for the value
        fields := []arrow.Field{
                {Name: "string_value", Type: arrow.BinaryTypes.String, Nullable: false},                                                                     // 0: string value
                {Name: "bool_value", Type: arrow.FixedWidthTypes.Boolean, Nullable: false},                                                                  // 1: bool value
                {Name: "bigint_value", Type: arrow.PrimitiveTypes.Int64, Nullable: false},                                                                   // 2: bigint value
                {Name: "int32_bitmask", Type: arrow.PrimitiveTypes.Int32, Nullable: false},                                                                  // 3: int32 bitmask
                {Name: "string_list", Type: arrow.ListOf(arrow.BinaryTypes.String), Nullable: false},                                                        // 4: string list
                {Name: "int32_to_int32_list_map", Type: arrow.MapOf(arrow.PrimitiveTypes.Int32, arrow.ListOf(arrow.PrimitiveTypes.Int32)), Nullable: false}, // 5: int32 to int32 list map
        }

        codes := []arrow.UnionTypeCode{0, 1, 2, 3, 4, 5}
        valueType := arrow.DenseUnionOf(fields, codes)

        return arrow.NewSchema([]arrow.Field{
                {Name: "info_name", Type: arrow.PrimitiveTypes.Uint32, Nullable: false},
                {Name: "value", Type: valueType, Nullable: false},
        }, nil)
}</span>

// XdbcTypeInfoResult holds XDBC type information for conversion to Arrow.
type XdbcTypeInfoResult struct {
        Types []XdbcTypeInfo
}

// ToArrowRecord converts XdbcTypeInfo results to an Arrow record.
func (x *XdbcTypeInfoResult) ToArrowRecord(allocator memory.Allocator) arrow.Record <span class="cov1" title="1">{
        schema := GetXdbcTypeInfoSchema()
        builder := array.NewRecordBuilder(allocator, schema)
        defer builder.Release()

        for _, typeInfo := range x.Types </span><span class="cov1" title="1">{
                // type_name
                builder.Field(0).(*array.StringBuilder).Append(typeInfo.TypeName)

                // data_type
                builder.Field(1).(*array.Int32Builder).Append(typeInfo.DataType)

                // column_size
                if typeInfo.ColumnSize.Valid </span><span class="cov1" title="1">{
                        builder.Field(2).(*array.Int32Builder).Append(typeInfo.ColumnSize.Int32)
                }</span> else<span class="cov0" title="0"> {
                        builder.Field(2).AppendNull()
                }</span>

                // literal_prefix
                <span class="cov1" title="1">if typeInfo.LiteralPrefix.Valid </span><span class="cov0" title="0">{
                        builder.Field(3).(*array.StringBuilder).Append(typeInfo.LiteralPrefix.String)
                }</span> else<span class="cov1" title="1"> {
                        builder.Field(3).AppendNull()
                }</span>

                // literal_suffix
                <span class="cov1" title="1">if typeInfo.LiteralSuffix.Valid </span><span class="cov0" title="0">{
                        builder.Field(4).(*array.StringBuilder).Append(typeInfo.LiteralSuffix.String)
                }</span> else<span class="cov1" title="1"> {
                        builder.Field(4).AppendNull()
                }</span>

                // create_params
                <span class="cov1" title="1">if typeInfo.CreateParams.Valid </span><span class="cov0" title="0">{
                        builder.Field(5).(*array.StringBuilder).Append(typeInfo.CreateParams.String)
                }</span> else<span class="cov1" title="1"> {
                        builder.Field(5).AppendNull()
                }</span>

                // nullable
                <span class="cov1" title="1">builder.Field(6).(*array.Int32Builder).Append(typeInfo.Nullable)

                // case_sensitive
                builder.Field(7).(*array.BooleanBuilder).Append(typeInfo.CaseSensitive)

                // searchable
                builder.Field(8).(*array.Int32Builder).Append(typeInfo.Searchable)

                // unsigned_attribute
                if typeInfo.UnsignedAttribute.Valid </span><span class="cov1" title="1">{
                        builder.Field(9).(*array.BooleanBuilder).Append(typeInfo.UnsignedAttribute.Bool)
                }</span> else<span class="cov0" title="0"> {
                        builder.Field(9).AppendNull()
                }</span>

                // fixed_prec_scale
                <span class="cov1" title="1">builder.Field(10).(*array.BooleanBuilder).Append(typeInfo.FixedPrecScale)

                // auto_increment
                if typeInfo.AutoIncrement.Valid </span><span class="cov0" title="0">{
                        builder.Field(11).(*array.BooleanBuilder).Append(typeInfo.AutoIncrement.Bool)
                }</span> else<span class="cov1" title="1"> {
                        builder.Field(11).AppendNull()
                }</span>

                // local_type_name
                <span class="cov1" title="1">if typeInfo.LocalTypeName.Valid </span><span class="cov0" title="0">{
                        builder.Field(12).(*array.StringBuilder).Append(typeInfo.LocalTypeName.String)
                }</span> else<span class="cov1" title="1"> {
                        builder.Field(12).AppendNull()
                }</span>

                // minimum_scale
                <span class="cov1" title="1">if typeInfo.MinimumScale.Valid </span><span class="cov0" title="0">{
                        builder.Field(13).(*array.Int32Builder).Append(typeInfo.MinimumScale.Int32)
                }</span> else<span class="cov1" title="1"> {
                        builder.Field(13).AppendNull()
                }</span>

                // maximum_scale
                <span class="cov1" title="1">if typeInfo.MaximumScale.Valid </span><span class="cov0" title="0">{
                        builder.Field(14).(*array.Int32Builder).Append(typeInfo.MaximumScale.Int32)
                }</span> else<span class="cov1" title="1"> {
                        builder.Field(14).AppendNull()
                }</span>

                // sql_data_type
                <span class="cov1" title="1">builder.Field(15).(*array.Int32Builder).Append(typeInfo.SQLDataType)

                // datetime_subcode
                if typeInfo.DatetimeSubcode.Valid </span><span class="cov0" title="0">{
                        builder.Field(16).(*array.Int32Builder).Append(typeInfo.DatetimeSubcode.Int32)
                }</span> else<span class="cov1" title="1"> {
                        builder.Field(16).AppendNull()
                }</span>

                // num_prec_radix
                <span class="cov1" title="1">if typeInfo.NumPrecRadix.Valid </span><span class="cov0" title="0">{
                        builder.Field(17).(*array.Int32Builder).Append(typeInfo.NumPrecRadix.Int32)
                }</span> else<span class="cov1" title="1"> {
                        builder.Field(17).AppendNull()
                }</span>

                // interval_precision
                <span class="cov1" title="1">if typeInfo.IntervalPrecision.Valid </span><span class="cov0" title="0">{
                        builder.Field(18).(*array.Int32Builder).Append(typeInfo.IntervalPrecision.Int32)
                }</span> else<span class="cov1" title="1"> {
                        builder.Field(18).AppendNull()
                }</span>
        }

        <span class="cov1" title="1">return builder.NewRecord()</span>
}

// SqlInfoResult holds SQL info for conversion to Arrow.
type SqlInfoResult struct {
        Info []SQLInfo
}

// ToArrowRecord converts SqlInfo results to an Arrow record.
func (s *SqlInfoResult) ToArrowRecord(allocator memory.Allocator) arrow.Record <span class="cov1" title="1">{
        schema := GetSqlInfoSchema()
        builder := array.NewRecordBuilder(allocator, schema)
        defer builder.Release()

        for _, info := range s.Info </span><span class="cov10" title="7">{
                // info_name
                builder.Field(0).(*array.Uint32Builder).Append(info.InfoName)

                // value (dense union)
                unionBuilder := builder.Field(1).(*array.DenseUnionBuilder)

                switch v := info.Value.(type) </span>{
                case string:<span class="cov1" title="1">
                        unionBuilder.Append(0)
                        unionBuilder.Child(0).(*array.StringBuilder).Append(v)</span>
                case bool:<span class="cov1" title="1">
                        unionBuilder.Append(1)
                        unionBuilder.Child(1).(*array.BooleanBuilder).Append(v)</span>
                case int64:<span class="cov1" title="1">
                        unionBuilder.Append(2)
                        unionBuilder.Child(2).(*array.Int64Builder).Append(v)</span>
                case int32:<span class="cov1" title="1">
                        unionBuilder.Append(3)
                        unionBuilder.Child(3).(*array.Int32Builder).Append(v)</span>
                case []string:<span class="cov1" title="1">
                        unionBuilder.Append(4)
                        listBuilder := unionBuilder.Child(4).(*array.ListBuilder)
                        listBuilder.Append(true)
                        valueBuilder := listBuilder.ValueBuilder().(*array.StringBuilder)
                        for _, s := range v </span><span class="cov4" title="2">{
                                valueBuilder.Append(s)
                        }</span>
                case map[int32][]int32:<span class="cov1" title="1">
                        unionBuilder.Append(5)
                        mapBuilder := unionBuilder.Child(5).(*array.MapBuilder)
                        mapBuilder.Append(true)
                        keyBuilder := mapBuilder.KeyBuilder().(*array.Int32Builder)
                        itemBuilder := mapBuilder.ItemBuilder().(*array.ListBuilder)
                        for k, vals := range v </span><span class="cov1" title="1">{
                                keyBuilder.Append(k)
                                itemBuilder.Append(true)
                                valueBuilder := itemBuilder.ValueBuilder().(*array.Int32Builder)
                                for _, val := range vals </span><span class="cov4" title="2">{
                                        valueBuilder.Append(val)
                                }</span>
                        }
                default:<span class="cov1" title="1">
                        // Default to string representation
                        unionBuilder.Append(0)
                        unionBuilder.Child(0).(*array.StringBuilder).Append("")</span>
                }
        }

        <span class="cov1" title="1">return builder.NewRecord()</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package clickhouse provides ClickHouse‚Äëspecific repository implementations.
package clickhouse

import (
        "context"
        "database/sql"
        "fmt"
        "strings"

        "github.com/rs/zerolog"

        "github.com/TFMV/porter/pkg/errors"
        "github.com/TFMV/porter/pkg/infrastructure"
        "github.com/TFMV/porter/pkg/infrastructure/converter"
        "github.com/TFMV/porter/pkg/infrastructure/pool"
        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/repositories"
        "github.com/apache/arrow-go/v18/arrow"
)

// metadataRepository implements repositories.MetadataRepository for ClickHouse.
type metadataRepository struct {
        pool    pool.ConnectionPool
        sqlInfo *infrastructure.SQLInfoProvider
        log     zerolog.Logger
}

// NewMetadataRepository constructs a ClickHouse metadata repository.
func NewMetadataRepository(p pool.ConnectionPool, info *infrastructure.SQLInfoProvider, lg zerolog.Logger) repositories.MetadataRepository <span class="cov0" title="0">{
        return &amp;metadataRepository{
                pool:    p,
                sqlInfo: info,
                log:     lg.With().Str("repo", "clickhouse-metadata").Logger(),
        }
}</span>

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// public API
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func (r *metadataRepository) GetCatalogs(context.Context) ([]models.Catalog, error) <span class="cov0" title="0">{
        // ClickHouse has databases that act as catalogs
        return []models.Catalog{{
                Name:        "default",
                Description: "ClickHouse default database",
        }}, nil
}</span>

func (r *metadataRepository) GetSchemas(ctx context.Context, catalog, pattern string) ([]models.Schema, error) <span class="cov0" title="0">{
        const q = `
SELECT DISTINCT name as schema_name
FROM   system.databases
WHERE  ($1 = '' OR name LIKE $1)
ORDER  BY name`

        db, err := r.conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, q, like(pattern))
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.wrapDBErr(err, q)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return scanSchemas(rows, catalog)</span>
}

func (r *metadataRepository) GetTables(ctx context.Context, opt models.GetTablesOptions) ([]models.Table, error) <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString(`
SELECT database as table_catalog, database as table_schema, name as table_name, 
       CASE 
         WHEN engine LIKE '%View%' THEN 'VIEW'
         WHEN engine = 'Memory' THEN 'LOCAL TEMPORARY'
         ELSE 'BASE TABLE'
       END as table_type
FROM   system.tables
WHERE  1=1`)
        args := make([]interface{}, 0, 4)

        if opt.SchemaFilterPattern != nil &amp;&amp; !isWild(strPtr(opt.SchemaFilterPattern)) </span><span class="cov0" title="0">{
                sb.WriteString(" AND database LIKE ?")
                args = append(args, likeDeref(opt.SchemaFilterPattern))
        }</span>
        <span class="cov0" title="0">if !isWild(strPtr(opt.TableNameFilterPattern)) </span><span class="cov0" title="0">{
                sb.WriteString(" AND name LIKE ?")
                args = append(args, likeDeref(opt.TableNameFilterPattern))
        }</span>
        <span class="cov0" title="0">if len(opt.TableTypes) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString(" AND (")
                for i, t := range opt.TableTypes </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                sb.WriteString(" OR ")
                        }</span>
                        <span class="cov0" title="0">switch t </span>{
                        case "VIEW":<span class="cov0" title="0">
                                sb.WriteString("engine LIKE '%View%'")</span>
                        case "LOCAL TEMPORARY":<span class="cov0" title="0">
                                sb.WriteString("engine = 'Memory'")</span>
                        default:<span class="cov0" title="0"> // BASE TABLE
                                sb.WriteString("engine NOT LIKE '%View%' AND engine != 'Memory'")</span>
                        }
                }
                <span class="cov0" title="0">sb.WriteString(")")</span>
        }
        <span class="cov0" title="0">sb.WriteString(" ORDER BY database, name")

        db, err := r.conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, sb.String(), args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.wrapDBErr(err, sb.String())
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return scanTables(rows)</span>
}

func (r *metadataRepository) GetTableTypes(context.Context) ([]string, error) <span class="cov0" title="0">{
        return []string{"BASE TABLE", "VIEW", "LOCAL TEMPORARY"}, nil
}</span>

func (r *metadataRepository) GetColumns(ctx context.Context, ref models.TableRef) ([]models.Column, error) <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString(`
SELECT database as table_catalog, database as table_schema, table as table_name,
       name as column_name, position as ordinal_position, default_expression as column_default,
       CASE WHEN is_in_primary_key = 1 THEN 'NO' ELSE 'YES' END as is_nullable, 
       type as data_type,
       NULL as character_maximum_length, NULL as numeric_precision,
       NULL as numeric_scale, NULL as datetime_precision
FROM   system.columns
WHERE  table = ?`)
        args := []interface{}{ref.Table}

        sb.WriteString(" ORDER BY position")

        db, err := r.conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, sb.String(), args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.wrapDBErr(err, sb.String())
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return scanColumns(rows)</span>
}

func (r *metadataRepository) GetTableSchema(ctx context.Context, ref models.TableRef) (*arrow.Schema, error) <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString("SELECT * FROM ")
        if s := strPtr(ref.DBSchema); s != "" </span><span class="cov0" title="0">{
                sb.WriteString(quoteIdentifier(s))
                sb.WriteRune('.')
        }</span>
        <span class="cov0" title="0">sb.WriteString(quoteIdentifier(ref.Table))
        sb.WriteString(" LIMIT 0")

        db, err := r.conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, sb.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.wrapDBErr(err, sb.String())
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        cols, err := rows.ColumnTypes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tc := converter.New(r.log)
        schema, err := tc.ConvertToArrowSchema(cols)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return schema, nil</span>
}

func (r *metadataRepository) GetPrimaryKeys(ctx context.Context, ref models.TableRef) ([]models.Key, error) <span class="cov0" title="0">{
        const q = `
SELECT database, table, name, position
FROM   system.columns
WHERE  table = ? AND is_in_primary_key = 1
ORDER  BY position`

        args := []interface{}{ref.Table}

        db, err := r.conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.wrapDBErr(err, q)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        out := make([]models.Key, 0)
        catalog := strPtr(ref.Catalog)
        schema := strPtr(ref.DBSchema)

        for rows.Next() </span><span class="cov0" title="0">{
                var database, table, name string
                var position int32
                if err := rows.Scan(&amp;database, &amp;table, &amp;name, &amp;position); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out = append(out, models.Key{
                        CatalogName: catalog,
                        SchemaName:  schema,
                        TableName:   ref.Table,
                        ColumnName:  name,
                        KeySequence: position,
                })</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return out, nil</span>
}

// ClickHouse doesn't have traditional foreign keys, so these return empty results
func (r *metadataRepository) GetImportedKeys(ctx context.Context, ref models.TableRef) ([]models.ForeignKey, error) <span class="cov0" title="0">{
        return []models.ForeignKey{}, nil
}</span>

func (r *metadataRepository) GetExportedKeys(ctx context.Context, ref models.TableRef) ([]models.ForeignKey, error) <span class="cov0" title="0">{
        return []models.ForeignKey{}, nil
}</span>

func (r *metadataRepository) GetCrossReference(ctx context.Context, ref models.CrossTableRef) ([]models.ForeignKey, error) <span class="cov0" title="0">{
        return []models.ForeignKey{}, nil
}</span>

func (r *metadataRepository) GetTypeInfo(ctx context.Context, dataType *int32) ([]models.XdbcTypeInfo, error) <span class="cov0" title="0">{
        tc := converter.New(r.log)

        // Define common ClickHouse types
        clickhouseTypes := []string{
                "Int8", "Int16", "Int32", "Int64",
                "UInt8", "UInt16", "UInt32", "UInt64",
                "Float32", "Float64", "Decimal", "Decimal32", "Decimal64", "Decimal128",
                "Bool", "String", "FixedString",
                "Date", "Date32", "DateTime", "DateTime64",
                "Array", "Tuple", "Map", "Nullable",
        }

        // If dataType is nil, return all types
        if dataType == nil </span><span class="cov0" title="0">{
                types := make([]models.XdbcTypeInfo, 0)
                for _, chType := range clickhouseTypes </span><span class="cov0" title="0">{
                        sqlType := tc.GetSQLType(chType)
                        arrowType, err := tc.DuckDBToArrowType(chType)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">types = append(types, models.XdbcTypeInfo{
                                TypeName:          chType,
                                DataType:          sqlType,
                                ColumnSize:        sql.NullInt32{Int32: getColumnSize(arrowType), Valid: true},
                                LiteralPrefix:     sql.NullString{String: getLiteralPrefix(arrowType), Valid: true},
                                LiteralSuffix:     sql.NullString{String: getLiteralSuffix(arrowType), Valid: true},
                                CreateParams:      sql.NullString{String: getCreateParams(arrowType), Valid: true},
                                Nullable:          1, // SQL_NULLABLE
                                CaseSensitive:     getCaseSensitive(arrowType),
                                Searchable:        3, // SQL_SEARCHABLE
                                UnsignedAttribute: sql.NullBool{Bool: false, Valid: true},
                                FixedPrecScale:    getFixedPrecScale(arrowType),
                                AutoIncrement:     sql.NullBool{Bool: false, Valid: true},
                                LocalTypeName:     sql.NullString{String: chType, Valid: true},
                                MinimumScale:      sql.NullInt32{Int32: getMinimumScale(arrowType), Valid: true},
                                MaximumScale:      sql.NullInt32{Int32: getMaximumScale(arrowType), Valid: true},
                                SQLDataType:       sqlType,
                                DatetimeSubcode:   sql.NullInt32{Int32: getSQLDateTimeSub(arrowType), Valid: true},
                                NumPrecRadix:      sql.NullInt32{Int32: getNumPrecRadix(arrowType), Valid: true},
                                IntervalPrecision: sql.NullInt32{Valid: false},
                        })</span>
                }
                <span class="cov0" title="0">return types, nil</span>
        }

        // Filter by specific data type
        <span class="cov0" title="0">for _, chType := range clickhouseTypes </span><span class="cov0" title="0">{
                sqlType := tc.GetSQLType(chType)
                if sqlType == *dataType </span><span class="cov0" title="0">{
                        arrowType, err := tc.DuckDBToArrowType(chType)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">return []models.XdbcTypeInfo{{
                                TypeName:          chType,
                                DataType:          sqlType,
                                ColumnSize:        sql.NullInt32{Int32: getColumnSize(arrowType), Valid: true},
                                LiteralPrefix:     sql.NullString{String: getLiteralPrefix(arrowType), Valid: true},
                                LiteralSuffix:     sql.NullString{String: getLiteralSuffix(arrowType), Valid: true},
                                CreateParams:      sql.NullString{String: getCreateParams(arrowType), Valid: true},
                                Nullable:          1,
                                CaseSensitive:     getCaseSensitive(arrowType),
                                Searchable:        3,
                                UnsignedAttribute: sql.NullBool{Bool: false, Valid: true},
                                FixedPrecScale:    getFixedPrecScale(arrowType),
                                AutoIncrement:     sql.NullBool{Bool: false, Valid: true},
                                LocalTypeName:     sql.NullString{String: chType, Valid: true},
                                MinimumScale:      sql.NullInt32{Int32: getMinimumScale(arrowType), Valid: true},
                                MaximumScale:      sql.NullInt32{Int32: getMaximumScale(arrowType), Valid: true},
                                SQLDataType:       sqlType,
                                DatetimeSubcode:   sql.NullInt32{Int32: getSQLDateTimeSub(arrowType), Valid: true},
                                NumPrecRadix:      sql.NullInt32{Int32: getNumPrecRadix(arrowType), Valid: true},
                                IntervalPrecision: sql.NullInt32{Valid: false},
                        }}, nil</span>
                }
        }

        <span class="cov0" title="0">return []models.XdbcTypeInfo{}, nil</span>
}

func (r *metadataRepository) GetSQLInfo(ctx context.Context, ids []uint32) ([]models.SQLInfo, error) <span class="cov0" title="0">{
        if r.sqlInfo == nil </span><span class="cov0" title="0">{
                return nil, errors.New(errors.CodeInternal, "SQL info provider not configured")
        }</span>
        // Return empty for now - SQLInfo implementation would need to be added
        <span class="cov0" title="0">return []models.SQLInfo{}, nil</span>
}

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// internal helpers
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func (r *metadataRepository) conn(ctx context.Context) (*sql.Conn, error) <span class="cov0" title="0">{
        db, err := r.pool.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.CodeConnectionFailed, "get conn")
        }</span>
        <span class="cov0" title="0">return db.Conn(ctx)</span>
}

func (r *metadataRepository) wrapDBErr(err error, sql string) error <span class="cov0" title="0">{
        return errors.Wrap(err, errors.CodeQueryFailed, fmt.Sprintf("query: %s", truncateSQL(sql, 100)))
}</span>

// Helper functions from DuckDB implementation adapted for ClickHouse
func scanSchemas(rows *sql.Rows, catalog string) ([]models.Schema, error) <span class="cov0" title="0">{
        var schemas []models.Schema
        for rows.Next() </span><span class="cov0" title="0">{
                var name string
                if err := rows.Scan(&amp;name); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">schemas = append(schemas, models.Schema{
                        CatalogName: catalog,
                        Name:        name,
                })</span>
        }
        <span class="cov0" title="0">return schemas, rows.Err()</span>
}

func scanTables(rows *sql.Rows) ([]models.Table, error) <span class="cov0" title="0">{
        var tables []models.Table
        for rows.Next() </span><span class="cov0" title="0">{
                var catalog, schema, name, tableType string
                if err := rows.Scan(&amp;catalog, &amp;schema, &amp;name, &amp;tableType); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">tables = append(tables, models.Table{
                        CatalogName: catalog,
                        SchemaName:  schema,
                        Name:        name,
                        Type:        tableType,
                })</span>
        }
        <span class="cov0" title="0">return tables, rows.Err()</span>
}

func scanColumns(rows *sql.Rows) ([]models.Column, error) <span class="cov0" title="0">{
        var columns []models.Column
        for rows.Next() </span><span class="cov0" title="0">{
                var catalog, schema, table, name sql.NullString
                var position sql.NullInt32
                var defaultVal, nullable, dataType sql.NullString
                var charMaxLen, numPrec, numScale, dtPrec sql.NullInt32

                if err := rows.Scan(&amp;catalog, &amp;schema, &amp;table, &amp;name, &amp;position, &amp;defaultVal, &amp;nullable, &amp;dataType, &amp;charMaxLen, &amp;numPrec, &amp;numScale, &amp;dtPrec); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">columns = append(columns, models.Column{
                        CatalogName:       catalog.String,
                        SchemaName:        schema.String,
                        TableName:         table.String,
                        Name:              name.String,
                        OrdinalPosition:   int(position.Int32),
                        DefaultValue:      defaultVal,
                        IsNullable:        nullable.String == "YES",
                        DataType:          dataType.String,
                        CharMaxLength:     sql.NullInt64{Int64: int64(charMaxLen.Int32), Valid: charMaxLen.Valid},
                        NumericPrecision:  sql.NullInt64{Int64: int64(numPrec.Int32), Valid: numPrec.Valid},
                        NumericScale:      sql.NullInt64{Int64: int64(numScale.Int32), Valid: numScale.Valid},
                        DateTimePrecision: sql.NullInt64{Int64: int64(dtPrec.Int32), Valid: dtPrec.Valid},
                })</span>
        }
        <span class="cov0" title="0">return columns, rows.Err()</span>
}

// Utility functions
func like(s string) string <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return "%"
        }</span>
        <span class="cov0" title="0">return s</span>
}

func likeDeref(ptr *string) string <span class="cov0" title="0">{ return like(strPtr(ptr)) }</span>
func isWild(s string) bool         <span class="cov0" title="0">{ return s == "" || s == "%" }</span>
func strPtr(p *string) string <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *p</span>
}

func quoteIdentifier(name string) string <span class="cov0" title="0">{
        return "`" + strings.ReplaceAll(name, "`", "``") + "`"
}</span>

func truncateSQL(s string, max int) string <span class="cov0" title="0">{
        if len(s) &lt;= max </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:max] + "‚Ä¶"</span>
}

// Arrow type helper functions - simplified versions
func getColumnSize(arrowType arrow.DataType) int32 <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.STRING, arrow.BINARY:<span class="cov0" title="0">
                return 65536</span> // Default size for variable-length types
        case arrow.INT8:<span class="cov0" title="0">
                return 3</span>
        case arrow.INT16:<span class="cov0" title="0">
                return 5</span>
        case arrow.INT32:<span class="cov0" title="0">
                return 10</span>
        case arrow.INT64:<span class="cov0" title="0">
                return 19</span>
        case arrow.FLOAT32:<span class="cov0" title="0">
                return 7</span>
        case arrow.FLOAT64:<span class="cov0" title="0">
                return 15</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func getLiteralPrefix(arrowType arrow.DataType) string <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.STRING:<span class="cov0" title="0">
                return "'"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func getLiteralSuffix(arrowType arrow.DataType) string <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.STRING:<span class="cov0" title="0">
                return "'"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func getCreateParams(arrowType arrow.DataType) string <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.DECIMAL128, arrow.DECIMAL256:<span class="cov0" title="0">
                return "precision,scale"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func getCaseSensitive(arrowType arrow.DataType) bool <span class="cov0" title="0">{
        return arrowType.ID() == arrow.STRING
}</span>

func getFixedPrecScale(arrowType arrow.DataType) bool <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.DECIMAL128, arrow.DECIMAL256:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func getMinimumScale(arrowType arrow.DataType) int32 <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.DECIMAL128, arrow.DECIMAL256:<span class="cov0" title="0">
                return 0</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func getMaximumScale(arrowType arrow.DataType) int32 <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.DECIMAL128, arrow.DECIMAL256:<span class="cov0" title="0">
                return 38</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func getSQLDateTimeSub(arrowType arrow.DataType) int32 <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.DATE32, arrow.DATE64:<span class="cov0" title="0">
                return 1</span> // SQL_CODE_DATE
        case arrow.TIME32, arrow.TIME64:<span class="cov0" title="0">
                return 2</span> // SQL_CODE_TIME
        case arrow.TIMESTAMP:<span class="cov0" title="0">
                return 3</span> // SQL_CODE_TIMESTAMP
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func getNumPrecRadix(arrowType arrow.DataType) int32 <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.INT8, arrow.INT16, arrow.INT32, arrow.INT64,
                arrow.UINT8, arrow.UINT16, arrow.UINT32, arrow.UINT64,
                arrow.FLOAT32, arrow.FLOAT64,
                arrow.DECIMAL128, arrow.DECIMAL256:<span class="cov0" title="0">
                return 10</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Package clickhouse provides ClickHouse‚Äëspecific repository implementations.
package clickhouse

import (
        "context"
        "database/sql"
        "sync"
        "sync/atomic"
        "time"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/memory"
        "github.com/rs/zerolog"

        "github.com/TFMV/porter/pkg/errors"
        "github.com/TFMV/porter/pkg/infrastructure/converter"
        "github.com/TFMV/porter/pkg/infrastructure/pool"
        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/repositories"
)

//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// Repository
//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

// preparedStatementRepository implements repositories.PreparedStatementRepository.
type preparedStatementRepository struct {
        pool       pool.ConnectionPool
        alloc      memory.Allocator
        log        zerolog.Logger
        statements sync.Map // map[string]*preparedStatement
}

func NewPreparedStatementRepository(p pool.ConnectionPool, a memory.Allocator, lg zerolog.Logger) repositories.PreparedStatementRepository <span class="cov0" title="0">{
        return &amp;preparedStatementRepository{
                pool:  p,
                alloc: a,
                log:   lg.With().Str("repo", "clickhouse-prepared_stmt").Logger(),
        }
}</span>

//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// Public API
//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

func (r *preparedStatementRepository) Store(_ context.Context, ps *models.PreparedStatement) error <span class="cov0" title="0">{
        r.log.Debug().Str("handle", ps.Handle).Msg("store prepared stmt")
        r.statements.Store(ps.Handle, &amp;preparedStatement{model: ps, createdAt: now()})
        return nil
}</span>

func (r *preparedStatementRepository) Get(_ context.Context, h string) (*models.PreparedStatement, error) <span class="cov0" title="0">{
        ps, ok := r.loadPS(h)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.ErrStatementNotFound.WithDetail("handle", h)
        }</span>
        <span class="cov0" title="0">return ps.model, nil</span>
}

func (r *preparedStatementRepository) Remove(_ context.Context, h string) error <span class="cov0" title="0">{
        ps, ok := r.deletePS(h)
        if !ok </span><span class="cov0" title="0">{
                return errors.ErrStatementNotFound.WithDetail("handle", h)
        }</span>
        <span class="cov0" title="0">if ps.stmt != nil </span><span class="cov0" title="0">{
                _ = ps.stmt.Close() // log only on failure
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *preparedStatementRepository) ExecuteQuery(ctx context.Context, h string, params [][]interface{}) (*models.QueryResult, error) <span class="cov0" title="0">{
        ps, ok := r.loadPS(h)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.ErrStatementNotFound.WithDetail("handle", h)
        }</span>

        // acquire db connection &amp; prepare stmt lazily
        <span class="cov0" title="0">var rows *sql.Rows
        if err := r.withConn(ctx, func(conn *sql.Conn) (err error) </span><span class="cov0" title="0">{
                if err = ps.ensurePrepared(ctx, conn); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if batch := firstBatch(params); batch != nil </span><span class="cov0" title="0">{
                        rows, err = ps.stmt.QueryContext(ctx, batch...)
                }</span> else<span class="cov0" title="0"> {
                        rows, err = ps.stmt.QueryContext(ctx)
                }</span>
                <span class="cov0" title="0">return</span>
        }); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">reader, err := converter.NewBatchReader(r.alloc, rows, r.log)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.CodeInternal, "new batch reader")
        }</span>

        <span class="cov0" title="0">out := make(chan arrow.Record, 8)
        go streamRecords(ctx, reader, out, r.log)

        ps.bumpUsage()
        return &amp;models.QueryResult{Schema: reader.Schema(), Records: out}, nil</span>
}

func (r *preparedStatementRepository) ExecuteUpdate(ctx context.Context, h string, params [][]interface{}) (*models.UpdateResult, error) <span class="cov0" title="0">{
        ps, ok := r.loadPS(h)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.ErrStatementNotFound.WithDetail("handle", h)
        }</span>

        <span class="cov0" title="0">var (
                result sql.Result
                start  = time.Now()
        )

        err := r.withConn(ctx, func(conn *sql.Conn) error </span><span class="cov0" title="0">{
                if err := ps.ensurePrepared(ctx, conn); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">var execErr error
                if batch := firstBatch(params); batch != nil </span><span class="cov0" title="0">{
                        result, execErr = ps.stmt.ExecContext(ctx, batch...)
                }</span> else<span class="cov0" title="0"> {
                        result, execErr = ps.stmt.ExecContext(ctx)
                }</span>
                <span class="cov0" title="0">return execErr</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rows, _ := result.RowsAffected() // ignore error, ‚Äë1 on unknown
        ps.bumpUsage()

        dur := time.Since(start)
        r.log.Debug().
                Str("handle", h).
                Int64("rows", rows).
                Dur("elapsed", dur).
                Msg("clickhouse update ok")

        return &amp;models.UpdateResult{RowsAffected: rows, ExecutionTime: dur}, nil</span>
}

func (r *preparedStatementRepository) List(_ context.Context, txID string) ([]*models.PreparedStatement, error) <span class="cov0" title="0">{
        var list []*models.PreparedStatement
        r.statements.Range(func(_, v any) bool </span><span class="cov0" title="0">{
                ps := v.(*preparedStatement)
                if txID == "" || ps.model.TransactionID == txID </span><span class="cov0" title="0">{
                        list = append(list, ps.model)
                }</span>
                <span class="cov0" title="0">return true</span>
        })
        <span class="cov0" title="0">return list, nil</span>
}

//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// internal helpers
//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

func (r *preparedStatementRepository) withConn(ctx context.Context, fn func(*sql.Conn) error) error <span class="cov0" title="0">{
        db, err := r.pool.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.CodeConnectionFailed, "get conn")
        }</span>
        <span class="cov0" title="0">conn, err := db.Conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.CodeConnectionFailed, "get conn")
        }</span>
        <span class="cov0" title="0">return fn(conn)</span>
}

func (r *preparedStatementRepository) loadPS(h string) (*preparedStatement, bool) <span class="cov0" title="0">{
        if v, ok := r.statements.Load(h); ok </span><span class="cov0" title="0">{
                return v.(*preparedStatement), true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}
func (r *preparedStatementRepository) deletePS(h string) (*preparedStatement, bool) <span class="cov0" title="0">{
        if v, ok := r.statements.LoadAndDelete(h); ok </span><span class="cov0" title="0">{
                return v.(*preparedStatement), true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

func firstBatch(b [][]interface{}) []interface{} <span class="cov0" title="0">{
        if len(b) &gt; 0 &amp;&amp; len(b[0]) &gt; 0 </span><span class="cov0" title="0">{
                return b[0]
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// streamRecords copies Arrow records from reader to chan with proper Retain/Release.
func streamRecords(ctx context.Context, br *converter.BatchReader, out chan arrow.Record, log zerolog.Logger) <span class="cov0" title="0">{
        defer close(out)
        defer br.Release()

        var total int64
        for br.Next() </span><span class="cov0" title="0">{
                rec := br.Record()
                if rec == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">rec.Retain()
                total += rec.NumRows()

                select </span>{
                case out &lt;- rec:<span class="cov0" title="0"></span>
                        // consumer will Release()
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        rec.Release()
                        return</span>
                }
        }
        <span class="cov0" title="0">if err := br.Err(); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("batch reader")
        }</span>
        <span class="cov0" title="0">log.Debug().Int64("rows", total).Msg("clickhouse stream complete")</span>
}

// now is var for deterministic tests.
var now = time.Now

//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// internal prepared stmt wrapper
//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

type preparedStatement struct {
        model     *models.PreparedStatement
        stmt      *sql.Stmt
        createdAt time.Time
        once      sync.Once
}

func (p *preparedStatement) ensurePrepared(ctx context.Context, conn *sql.Conn) error <span class="cov0" title="0">{
        var err error
        p.once.Do(func() </span><span class="cov0" title="0">{
                p.stmt, err = conn.PrepareContext(ctx, p.model.Query)
        }</span>)
        <span class="cov0" title="0">return err</span>
}

func (p *preparedStatement) bumpUsage() <span class="cov0" title="0">{
        atomic.AddInt64(&amp;p.model.ExecutionCount, 1)
        p.model.LastUsedAt = now()
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package clickhouse provides ClickHouse‚Äëspecific repository implementations.
package clickhouse

import (
        "context"
        "database/sql"
        "time"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/memory"
        "github.com/rs/zerolog"

        "github.com/TFMV/porter/pkg/errors"
        "github.com/TFMV/porter/pkg/infrastructure/converter"
        "github.com/TFMV/porter/pkg/infrastructure/pool"
        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/repositories"
)

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Repository
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// queryRepository implements repositories.QueryRepository for ClickHouse.
type queryRepository struct {
        pool  pool.ConnectionPool
        alloc memory.Allocator
        log   zerolog.Logger
}

func NewQueryRepository(p pool.ConnectionPool, a memory.Allocator, lg zerolog.Logger) repositories.QueryRepository <span class="cov0" title="0">{
        return &amp;queryRepository{
                pool:  p,
                alloc: a,
                log:   lg.With().Str("repo", "clickhouse-query").Logger(),
        }
}</span>

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Public API
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func (r *queryRepository) ExecuteQuery(
        ctx context.Context,
        query string,
        txn repositories.Transaction,
        args ...interface{},
) (*models.QueryResult, error) <span class="cov0" title="0">{

        r.log.Debug().
                Str("sql", truncate(query, 120)).
                Bool("in_tx", txn != nil).
                Int("args", len(args)).
                Msg("execute query")

        qr, err := withQuerier(r, ctx, txn, func(q querier) (*models.QueryResult, error) </span><span class="cov0" title="0">{
                rows, err := q.QueryContext(ctx, query, args...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, errors.CodeQueryFailed, "query")
                }</span>

                <span class="cov0" title="0">reader, err := converter.NewBatchReader(r.alloc, rows, r.log)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, errors.CodeInternal, "batch reader")
                }</span>

                <span class="cov0" title="0">out := make(chan arrow.Record, 8)
                go streamQueryRecords(ctx, reader, out, r.log)

                return &amp;models.QueryResult{
                        Schema:  reader.Schema(),
                        Records: out,
                }, nil</span>
        })
        <span class="cov0" title="0">return qr, err</span>
}

func (r *queryRepository) ExecuteUpdate(
        ctx context.Context,
        sqlStmt string,
        txn repositories.Transaction,
        args ...interface{},
) (*models.UpdateResult, error) <span class="cov0" title="0">{

        r.log.Debug().
                Str("sql", truncate(sqlStmt, 120)).
                Bool("in_tx", txn != nil).
                Int("args", len(args)).
                Msg("execute update")

        start := time.Now()

        ur, err := withQuerier(r, ctx, txn, func(q querier) (*models.UpdateResult, error) </span><span class="cov0" title="0">{
                res, err := q.ExecContext(ctx, sqlStmt, args...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, errors.CodeQueryFailed, "exec")
                }</span>
                <span class="cov0" title="0">rows, _ := res.RowsAffected() // ignore error, ‚Äë1 on unknown
                return &amp;models.UpdateResult{
                        RowsAffected:  rows,
                        ExecutionTime: time.Since(start),
                }, nil</span>
        })

        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                r.log.Debug().
                        Int64("rows", ur.RowsAffected).
                        Dur("elapsed", ur.ExecutionTime).
                        Msg("update ok")
        }</span>
        <span class="cov0" title="0">return ur, err</span>
}

func (r *queryRepository) Prepare(
        ctx context.Context,
        query string,
        txn repositories.Transaction,
) (*sql.Stmt, error) <span class="cov0" title="0">{

        r.log.Debug().
                Str("sql", truncate(query, 120)).
                Bool("in_tx", txn != nil).
                Msg("prepare")

        stmt, err := withQuerier(r, ctx, txn, func(q querier) (*sql.Stmt, error) </span><span class="cov0" title="0">{
                ps, err := q.PrepareContext(ctx, query)
                return ps, errors.Wrap(err, errors.CodeQueryFailed, "prepare")
        }</span>)
        <span class="cov0" title="0">return stmt, err</span>
}

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Internal helpers
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// querier is the common subset implemented by *sql.Conn and *sql.Tx.
type querier interface {
        QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
        ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
        PrepareContext(context.Context, string) (*sql.Stmt, error)
}

// withQuerier executes a function with either a transaction or connection.
func withQuerier[T any](
        r *queryRepository,
        ctx context.Context,
        txn repositories.Transaction,
        fn func(querier) (T, error),
) (T, error) <span class="cov0" title="0">{
        // When returning early we need zero value of T
        var zero T

        if txn != nil </span><span class="cov0" title="0">{
                tx := txn.GetDBTx()
                if tx == nil </span><span class="cov0" title="0">{
                        return zero, errors.New(errors.CodeTransactionFailed, "nil sql.Tx in Transaction")
                }</span>
                <span class="cov0" title="0">return fn(tx)</span>
        }

        <span class="cov0" title="0">conn, err := r.pool.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return zero, errors.Wrap(err, errors.CodeConnectionFailed, "get conn")
        }</span>
        // Do not defer conn.Close(); rows/stmt hold the conn until closed.

        <span class="cov0" title="0">return fn(conn)</span>
}

// streamQueryRecords sends Arrow records to channel with correct ref‚Äëcount handling.
func streamQueryRecords(ctx context.Context, br *converter.BatchReader, out chan arrow.Record, log zerolog.Logger) <span class="cov0" title="0">{
        defer close(out)
        defer br.Release()

        var rows int64
        for br.Next() </span><span class="cov0" title="0">{
                rec := br.Record()
                if rec == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">rec.Retain()
                rows += rec.NumRows()

                select </span>{
                case out &lt;- rec:<span class="cov0" title="0"></span>
                        // consumer is now owner
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        rec.Release()
                        return</span>
                }
        }
        <span class="cov0" title="0">if err := br.Err(); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("batch reader")
        }</span>
        <span class="cov0" title="0">log.Debug().Int64("rows", rows).Msg("clickhouse stream complete")</span>
}

// truncate shortens long SQL strings for logs.
func truncate(s string, max int) string <span class="cov0" title="0">{
        if len(s) &lt;= max </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:max] + "‚Ä¶"</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Package clickhouse provides ClickHouse‚Äëspecific repository implementations.
package clickhouse

import (
        "context"
        "database/sql"
        "sync"
        "sync/atomic"
        "time"

        "github.com/google/uuid"
        "github.com/rs/zerolog"

        "github.com/TFMV/porter/pkg/errors"
        "github.com/TFMV/porter/pkg/infrastructure/pool"
        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/repositories"
)

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Repository
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// transactionRepository implements repositories.TransactionRepository.
type transactionRepository struct {
        pool  pool.ConnectionPool
        log   zerolog.Logger
        txMap sync.Map // key = id, val = *clickhouseTransaction
}

func NewTransactionRepository(p pool.ConnectionPool, lg zerolog.Logger) repositories.TransactionRepository <span class="cov0" title="0">{
        return &amp;transactionRepository{
                pool: p,
                log:  lg.With().Str("repo", "clickhouse-txn").Logger(),
        }
}</span>

// Begin starts a new SQL transaction.
func (r *transactionRepository) Begin(ctx context.Context, opt models.TransactionOptions) (repositories.Transaction, error) <span class="cov0" title="0">{
        r.log.Debug().
                Str("iso", string(opt.IsolationLevel)).
                Bool("ro", opt.ReadOnly).
                Msg("begin")

        conn, err := r.pool.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.CodeConnectionFailed, "get conn")
        }</span>

        <span class="cov0" title="0">sqlTx, err := conn.BeginTx(ctx, &amp;sql.TxOptions{
                Isolation: mapIsolation(opt.IsolationLevel),
                ReadOnly:  opt.ReadOnly,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.CodeTransactionFailed, "begin tx")
        }</span>

        <span class="cov0" title="0">sqlConn, err := conn.Conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.CodeConnectionFailed, "get conn")
        }</span>

        <span class="cov0" title="0">txn := &amp;clickhouseTransaction{
                id:       uuid.NewString(),
                sqlTx:    sqlTx,
                conn:     sqlConn,
                readOnly: opt.ReadOnly,
                started:  time.Now(),
        }
        txn.active.Store(true) // Initialize as active
        r.store(txn)

        r.log.Info().Str("id", txn.id).Msg("clickhouse txn started")
        return txn, nil</span>
}

// Get returns an active transaction or ErrTransactionNotFound.
func (r *transactionRepository) Get(_ context.Context, id string) (repositories.Transaction, error) <span class="cov0" title="0">{
        if txn, ok := r.load(id); ok &amp;&amp; txn.IsActive() </span><span class="cov0" title="0">{
                return txn, nil
        }</span>
        <span class="cov0" title="0">return nil, errors.ErrTransactionNotFound.WithDetail("transaction_id", id)</span>
}

// List returns all active transactions.
func (r *transactionRepository) List(_ context.Context) ([]repositories.Transaction, error) <span class="cov0" title="0">{
        var list []repositories.Transaction
        r.txMap.Range(func(_, v any) bool </span><span class="cov0" title="0">{
                t := v.(*clickhouseTransaction)
                if t.IsActive() </span><span class="cov0" title="0">{
                        list = append(list, t)
                }</span> else<span class="cov0" title="0"> {
                        r.delete(t.id)
                }</span>
                <span class="cov0" title="0">return true</span>
        })
        <span class="cov0" title="0">return list, nil</span>
}

// Remove deletes a transaction record (no commit/rollback).
func (r *transactionRepository) Remove(_ context.Context, id string) error <span class="cov0" title="0">{
        r.delete(id)
        return nil
}</span>

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// internal map helpers
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func (r *transactionRepository) store(t *clickhouseTransaction) <span class="cov0" title="0">{ r.txMap.Store(t.id, t) }</span>
func (r *transactionRepository) load(id string) (*clickhouseTransaction, bool) <span class="cov0" title="0">{
        v, ok := r.txMap.Load(id)
        if !ok </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return v.(*clickhouseTransaction), true</span>
}
func (r *transactionRepository) delete(id string) <span class="cov0" title="0">{ r.txMap.Delete(id) }</span>

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// isolation mapping
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func mapIsolation(lvl models.IsolationLevel) sql.IsolationLevel <span class="cov0" title="0">{
        switch lvl </span>{
        case models.IsolationLevelReadUncommitted:<span class="cov0" title="0">
                return sql.LevelReadUncommitted</span>
        case models.IsolationLevelReadCommitted:<span class="cov0" title="0">
                return sql.LevelReadCommitted</span>
        case models.IsolationLevelRepeatableRead:<span class="cov0" title="0">
                return sql.LevelRepeatableRead</span>
        case models.IsolationLevelSerializable:<span class="cov0" title="0">
                return sql.LevelSerializable</span>
        default:<span class="cov0" title="0">
                return sql.LevelDefault</span>
        }
}

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// clickhouseTransaction
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

type clickhouseTransaction struct {
        id       string
        sqlTx    *sql.Tx
        conn     *sql.Conn // returned to pool on Commit/Rollback
        readOnly bool

        started time.Time
        active  atomic.Bool
}

func (t *clickhouseTransaction) ID() string <span class="cov0" title="0">{ return t.id }</span>

func (t *clickhouseTransaction) Commit(ctx context.Context) error <span class="cov0" title="0">{
        if !t.setInactive() </span><span class="cov0" title="0">{
                return errors.New(errors.CodeTransactionFailed, "transaction not active")
        }</span>
        <span class="cov0" title="0">if err := t.sqlTx.Commit(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.CodeTransactionFailed, "commit")
        }</span>
        <span class="cov0" title="0">_ = t.conn.Close()
        return nil</span>
}

func (t *clickhouseTransaction) Rollback(ctx context.Context) error <span class="cov0" title="0">{
        if !t.setInactive() </span><span class="cov0" title="0">{
                return errors.New(errors.CodeTransactionFailed, "transaction not active")
        }</span>
        <span class="cov0" title="0">if err := t.sqlTx.Rollback(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.CodeTransactionFailed, "rollback")
        }</span>
        <span class="cov0" title="0">_ = t.conn.Close()
        return nil</span>
}

func (t *clickhouseTransaction) IsActive() bool <span class="cov0" title="0">{ return t.active.Load() }</span>

func (t *clickhouseTransaction) GetDBTx() *sql.Tx <span class="cov0" title="0">{
        if t.IsActive() </span><span class="cov0" title="0">{
                return t.sqlTx
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// setInactive atomically flips the active flag; returns true if it was active.
func (t *clickhouseTransaction) setInactive() bool <span class="cov0" title="0">{ return t.active.Swap(false) }</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// Package duckdb provides DuckDB‚Äëspecific repository implementations.
package duckdb

import (
        "context"
        "database/sql"
        "fmt"
        "strings"

        "github.com/rs/zerolog"

        "github.com/TFMV/porter/pkg/errors"
        "github.com/TFMV/porter/pkg/infrastructure"
        "github.com/TFMV/porter/pkg/infrastructure/converter"
        "github.com/TFMV/porter/pkg/infrastructure/pool"
        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/repositories"
        "github.com/apache/arrow-go/v18/arrow"
)

// metadataRepository implements repositories.MetadataRepository for DuckDB.
type metadataRepository struct {
        pool    pool.ConnectionPool
        sqlInfo *infrastructure.SQLInfoProvider
        log     zerolog.Logger
}

// NewMetadataRepository constructs a DuckDB metadata repository.
func NewMetadataRepository(p pool.ConnectionPool, info *infrastructure.SQLInfoProvider, lg zerolog.Logger) repositories.MetadataRepository <span class="cov0" title="0">{
        return &amp;metadataRepository{
                pool:    p,
                sqlInfo: info,
                log:     lg.With().Str("repo", "metadata").Logger(),
        }
}</span>

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// public API
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func (r *metadataRepository) GetCatalogs(context.Context) ([]models.Catalog, error) <span class="cov0" title="0">{
        // DuckDB has a single in‚Äëmemory catalog.
        return []models.Catalog{{
                Name:        "memory",
                Description: "DuckDB in-memory database",
        }}, nil
}</span>

func (r *metadataRepository) GetSchemas(ctx context.Context, catalog, pattern string) ([]models.Schema, error) <span class="cov0" title="0">{
        const q = `
SELECT DISTINCT schema_name
FROM   information_schema.schemata
WHERE  ($1 = '' OR schema_name LIKE $1)
ORDER  BY schema_name`

        db, err := r.conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, q, like(pattern))
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.wrapDBErr(err, q)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return scanSchemas(rows, catalog)</span>
}

func (r *metadataRepository) GetTables(ctx context.Context, opt models.GetTablesOptions) ([]models.Table, error) <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString(`
SELECT table_catalog, table_schema, table_name, table_type
FROM   information_schema.tables
WHERE  1=1`)
        args := make([]interface{}, 0, 4)

        if opt.SchemaFilterPattern != nil &amp;&amp; !isWild(strPtr(opt.SchemaFilterPattern)) </span><span class="cov0" title="0">{
                sb.WriteString(" AND table_schema LIKE ?")
                args = append(args, likeDeref(opt.SchemaFilterPattern))
        }</span>
        <span class="cov0" title="0">if !isWild(strPtr(opt.TableNameFilterPattern)) </span><span class="cov0" title="0">{
                sb.WriteString(" AND table_name LIKE ?")
                args = append(args, likeDeref(opt.TableNameFilterPattern))
        }</span>
        <span class="cov0" title="0">if len(opt.TableTypes) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString(" AND table_type IN (")
                for i, t := range opt.TableTypes </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                sb.WriteRune(',')
                        }</span>
                        <span class="cov0" title="0">sb.WriteRune('?')
                        args = append(args, t)</span>
                }
                <span class="cov0" title="0">sb.WriteRune(')')</span>
        }
        <span class="cov0" title="0">sb.WriteString(" ORDER BY table_schema, table_name")

        db, err := r.conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, sb.String(), args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.wrapDBErr(err, sb.String())
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return scanTables(rows)</span>
}

func (r *metadataRepository) GetTableTypes(context.Context) ([]string, error) <span class="cov0" title="0">{
        return []string{"BASE TABLE", "VIEW", "LOCAL TEMPORARY"}, nil
}</span>

func (r *metadataRepository) GetColumns(ctx context.Context, ref models.TableRef) ([]models.Column, error) <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString(`
SELECT table_catalog, table_schema, table_name,
       column_name, ordinal_position, column_default,
       is_nullable, data_type,
       character_maximum_length, numeric_precision,
       numeric_scale, datetime_precision
FROM   information_schema.columns
WHERE  table_name = ?`)
        args := []interface{}{ref.Table}

        if s := strPtr(ref.DBSchema); s != "" </span><span class="cov0" title="0">{
                sb.WriteString(" AND table_schema = ?")
                args = append(args, s)
        }</span>
        <span class="cov0" title="0">if c := strPtr(ref.Catalog); c != "" </span><span class="cov0" title="0">{
                sb.WriteString(" AND table_catalog = ?")
                args = append(args, c)
        }</span>
        <span class="cov0" title="0">sb.WriteString(" ORDER BY ordinal_position")

        db, err := r.conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, sb.String(), args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.wrapDBErr(err, sb.String())
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return scanColumns(rows)</span>
}

func (r *metadataRepository) GetTableSchema(ctx context.Context, ref models.TableRef) (*arrow.Schema, error) <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString("SELECT * FROM ")
        if s := strPtr(ref.DBSchema); s != "" </span><span class="cov0" title="0">{
                sb.WriteString(quoteIdentifier(s))
                sb.WriteRune('.')
        }</span>
        <span class="cov0" title="0">sb.WriteString(quoteIdentifier(ref.Table))
        sb.WriteString(" LIMIT 0")

        db, err := r.conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, sb.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.wrapDBErr(err, sb.String())
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        cols, err := rows.ColumnTypes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tc := converter.New(r.log)
        schema, err := tc.ConvertToArrowSchema(cols)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return schema, nil</span>
}

// Foreign‚Äëkey helpers below remain unimplemented in DuckDB.
func (r *metadataRepository) GetPrimaryKeys(ctx context.Context, ref models.TableRef) ([]models.Key, error) <span class="cov0" title="0">{
        // TODO: query catalog tables once DuckDB exposes primary key metadata
        tbl := ref.Table
        if s := strPtr(ref.DBSchema); s != "" </span><span class="cov0" title="0">{
                tbl = fmt.Sprintf("%s.%s", s, tbl)
        }</span>

        <span class="cov0" title="0">const q = `SELECT name, pk FROM pragma_table_info(?) WHERE pk &gt; 0 ORDER BY pk`

        db, err := r.conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, q, tbl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.wrapDBErr(err, q)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        out := make([]models.Key, 0)
        catalog := strPtr(ref.Catalog)
        schema := strPtr(ref.DBSchema)

        for rows.Next() </span><span class="cov0" title="0">{
                var name string
                var seq int32
                if err := rows.Scan(&amp;name, &amp;seq); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out = append(out, models.Key{
                        CatalogName: catalog,
                        SchemaName:  schema,
                        TableName:   ref.Table,
                        ColumnName:  name,
                        KeySequence: seq,
                })</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return out, nil</span>
}
func (r *metadataRepository) GetImportedKeys(ctx context.Context, ref models.TableRef) ([]models.ForeignKey, error) <span class="cov0" title="0">{
        // DuckDB exposes basic foreign key metadata via PRAGMA foreign_key_list.
        // This only returns table-local information and does not include catalog
        // or constraint names. We map the available columns to the ForeignKey
        // model and leave catalog/schema information blank if not provided.

        tbl := ref.Table
        if s := strPtr(ref.DBSchema); s != "" </span><span class="cov0" title="0">{
                tbl = fmt.Sprintf("%s.%s", s, tbl)
        }</span>

        <span class="cov0" title="0">const q = "PRAGMA foreign_key_list(?)"

        db, err := r.conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, q, tbl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.wrapDBErr(err, q)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var fks []models.ForeignKey
        fkCatalog := strPtr(ref.Catalog)
        fkSchema := strPtr(ref.DBSchema)

        for rows.Next() </span><span class="cov0" title="0">{
                // DuckDB returns: id, seq, table, from, to, on_update, on_delete, match
                var (
                        id       int32
                        seq      int32
                        pkTable  string
                        fkColumn string
                        pkColumn string
                        onUpdate string
                        onDelete string
                        match    string
                )
                if err := rows.Scan(&amp;id, &amp;seq, &amp;pkTable, &amp;fkColumn, &amp;pkColumn, &amp;onUpdate, &amp;onDelete, &amp;match); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">fks = append(fks, models.ForeignKey{
                        PKCatalogName: fkCatalog, // DuckDB currently lacks catalog info
                        PKSchemaName:  fkSchema,
                        PKTableName:   pkTable,
                        PKColumnName:  pkColumn,
                        FKCatalogName: fkCatalog,
                        FKSchemaName:  fkSchema,
                        FKTableName:   ref.Table,
                        FKColumnName:  fkColumn,
                        KeySequence:   seq + 1, // PRAGMA seq starts at 0
                        PKKeyName:     "",
                        FKKeyName:     "",
                        UpdateRule:    toFKRule(onUpdate),
                        DeleteRule:    toFKRule(onDelete),
                })</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TODO: Resolve catalog and constraint names once DuckDB exposes them
        <span class="cov0" title="0">return fks, nil</span>
}
func (r *metadataRepository) GetExportedKeys(ctx context.Context, ref models.TableRef) ([]models.ForeignKey, error) <span class="cov0" title="0">{
        // DuckDB does not expose a direct way to query foreign keys referencing
        // a table. As a basic implementation, scan all tables in the schema and
        // inspect their foreign keys. This may be inefficient for large
        // databases but provides basic functionality until DuckDB adds native
        // support.

        db, err := r.conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString(`
SELECT table_schema, table_name
FROM   information_schema.tables
WHERE  table_type = 'BASE TABLE'`)
        args := make([]interface{}, 0, 2)

        if s := strPtr(ref.DBSchema); s != "" </span><span class="cov0" title="0">{
                sb.WriteString(" AND table_schema = ?")
                args = append(args, s)
        }</span>
        <span class="cov0" title="0">if c := strPtr(ref.Catalog); c != "" </span><span class="cov0" title="0">{
                sb.WriteString(" AND table_catalog = ?")
                args = append(args, c)
        }</span>

        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, sb.String(), args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.wrapDBErr(err, sb.String())
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        pkCatalog := strPtr(ref.Catalog)
        pkSchema := strPtr(ref.DBSchema)

        var fks []models.ForeignKey
        for rows.Next() </span><span class="cov0" title="0">{
                var schema string
                var table string
                if err := rows.Scan(&amp;schema, &amp;table); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">tbl := table
                if schema != "" </span><span class="cov0" title="0">{
                        tbl = fmt.Sprintf("%s.%s", schema, table)
                }</span>

                <span class="cov0" title="0">fkRows, err := db.QueryContext(ctx, "PRAGMA foreign_key_list(?)", tbl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, r.wrapDBErr(err, "PRAGMA foreign_key_list")
                }</span>

                <span class="cov0" title="0">for fkRows.Next() </span><span class="cov0" title="0">{
                        var (
                                id       int32
                                seq      int32
                                pkTable  string
                                fkColumn string
                                pkColumn string
                                onUpdate string
                                onDelete string
                                match    string
                        )
                        if err := fkRows.Scan(&amp;id, &amp;seq, &amp;pkTable, &amp;fkColumn, &amp;pkColumn, &amp;onUpdate, &amp;onDelete, &amp;match); err != nil </span><span class="cov0" title="0">{
                                fkRows.Close()
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">if pkTable != ref.Table </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">fks = append(fks, models.ForeignKey{
                                PKCatalogName: pkCatalog,
                                PKSchemaName:  pkSchema,
                                PKTableName:   ref.Table,
                                PKColumnName:  pkColumn,
                                FKCatalogName: pkCatalog,
                                FKSchemaName:  schema,
                                FKTableName:   table,
                                FKColumnName:  fkColumn,
                                KeySequence:   seq + 1,
                                PKKeyName:     "",
                                FKKeyName:     "",
                                UpdateRule:    toFKRule(onUpdate),
                                DeleteRule:    toFKRule(onDelete),
                        })</span>
                }
                <span class="cov0" title="0">if err := fkRows.Err(); err != nil </span><span class="cov0" title="0">{
                        fkRows.Close()
                        return nil, err
                }</span>
                <span class="cov0" title="0">fkRows.Close()</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TODO: Resolve catalog and constraint names once DuckDB exposes them
        <span class="cov0" title="0">return fks, nil</span>
}
func (r *metadataRepository) GetCrossReference(ctx context.Context, ref models.CrossTableRef) ([]models.ForeignKey, error) <span class="cov0" title="0">{
        // DuckDB does not expose a direct cross-reference query, so inspect the
        // foreign table's PRAGMA foreign_key_list and filter by the referenced
        // primary table. This mirrors the behaviour of GetExportedKeys but for a
        // specific FK table.

        tbl := ref.FKRef.Table
        if s := strPtr(ref.FKRef.DBSchema); s != "" </span><span class="cov0" title="0">{
                tbl = fmt.Sprintf("%s.%s", s, tbl)
        }</span>

        <span class="cov0" title="0">const q = "PRAGMA foreign_key_list(?)"

        db, err := r.conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, q, tbl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.wrapDBErr(err, q)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        pkCatalog := strPtr(ref.PKRef.Catalog)
        pkSchema := strPtr(ref.PKRef.DBSchema)
        fkCatalog := strPtr(ref.FKRef.Catalog)
        fkSchema := strPtr(ref.FKRef.DBSchema)

        var fks []models.ForeignKey
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        id       int32
                        seq      int32
                        pkTable  string
                        fkColumn string
                        pkColumn string
                        onUpdate string
                        onDelete string
                        match    string
                )
                if err := rows.Scan(&amp;id, &amp;seq, &amp;pkTable, &amp;fkColumn, &amp;pkColumn, &amp;onUpdate, &amp;onDelete, &amp;match); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if pkTable != ref.PKRef.Table </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fks = append(fks, models.ForeignKey{
                        PKCatalogName: pkCatalog,
                        PKSchemaName:  pkSchema,
                        PKTableName:   ref.PKRef.Table,
                        PKColumnName:  pkColumn,
                        FKCatalogName: fkCatalog,
                        FKSchemaName:  fkSchema,
                        FKTableName:   ref.FKRef.Table,
                        FKColumnName:  fkColumn,
                        KeySequence:   seq + 1,
                        PKKeyName:     "",
                        FKKeyName:     "",
                        UpdateRule:    toFKRule(onUpdate),
                        DeleteRule:    toFKRule(onDelete),
                })</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TODO: Resolve catalog and constraint names once DuckDB exposes them
        <span class="cov0" title="0">return fks, nil</span>
}

func (r *metadataRepository) GetTypeInfo(ctx context.Context, dataType *int32) ([]models.XdbcTypeInfo, error) <span class="cov0" title="0">{
        tc := converter.New(r.log)

        // Define common DuckDB types
        duckdbTypes := []string{
                "tinyint", "smallint", "integer", "bigint",
                "real", "float", "double", "decimal", "numeric",
                "boolean", "varchar", "text", "blob",
                "date", "time", "timestamp",
        }

        // If dataType is nil, return all types
        if dataType == nil </span><span class="cov0" title="0">{
                types := make([]models.XdbcTypeInfo, 0)
                for _, duckdbType := range duckdbTypes </span><span class="cov0" title="0">{
                        sqlType := tc.GetSQLType(duckdbType)
                        arrowType, err := tc.DuckDBToArrowType(duckdbType)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">types = append(types, models.XdbcTypeInfo{
                                TypeName:          duckdbType,
                                DataType:          sqlType,
                                ColumnSize:        sql.NullInt32{Int32: getColumnSize(arrowType), Valid: true},
                                LiteralPrefix:     sql.NullString{String: getLiteralPrefix(arrowType), Valid: true},
                                LiteralSuffix:     sql.NullString{String: getLiteralSuffix(arrowType), Valid: true},
                                CreateParams:      sql.NullString{String: getCreateParams(arrowType), Valid: true},
                                Nullable:          1, // SQL_NULLABLE
                                CaseSensitive:     getCaseSensitive(arrowType),
                                Searchable:        3, // SQL_SEARCHABLE
                                UnsignedAttribute: sql.NullBool{Bool: false, Valid: true},
                                FixedPrecScale:    getFixedPrecScale(arrowType),
                                AutoIncrement:     sql.NullBool{Bool: false, Valid: true},
                                LocalTypeName:     sql.NullString{String: duckdbType, Valid: true},
                                MinimumScale:      sql.NullInt32{Int32: getMinimumScale(arrowType), Valid: true},
                                MaximumScale:      sql.NullInt32{Int32: getMaximumScale(arrowType), Valid: true},
                                SQLDataType:       sqlType,
                                DatetimeSubcode:   sql.NullInt32{Int32: getSQLDateTimeSub(arrowType), Valid: true},
                                NumPrecRadix:      sql.NullInt32{Int32: getNumPrecRadix(arrowType), Valid: true},
                                IntervalPrecision: sql.NullInt32{Int32: 0, Valid: true},
                        })</span>
                }
                <span class="cov0" title="0">return types, nil</span>
        }

        // Find types matching the specified dataType
        <span class="cov0" title="0">types := make([]models.XdbcTypeInfo, 0)
        for _, duckdbType := range duckdbTypes </span><span class="cov0" title="0">{
                sqlType := tc.GetSQLType(duckdbType)
                if sqlType == *dataType </span><span class="cov0" title="0">{
                        arrowType, err := tc.DuckDBToArrowType(duckdbType)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">types = append(types, models.XdbcTypeInfo{
                                TypeName:          duckdbType,
                                DataType:          sqlType,
                                ColumnSize:        sql.NullInt32{Int32: getColumnSize(arrowType), Valid: true},
                                LiteralPrefix:     sql.NullString{String: getLiteralPrefix(arrowType), Valid: true},
                                LiteralSuffix:     sql.NullString{String: getLiteralSuffix(arrowType), Valid: true},
                                CreateParams:      sql.NullString{String: getCreateParams(arrowType), Valid: true},
                                Nullable:          1, // SQL_NULLABLE
                                CaseSensitive:     getCaseSensitive(arrowType),
                                Searchable:        3, // SQL_SEARCHABLE
                                UnsignedAttribute: sql.NullBool{Bool: false, Valid: true},
                                FixedPrecScale:    getFixedPrecScale(arrowType),
                                AutoIncrement:     sql.NullBool{Bool: false, Valid: true},
                                LocalTypeName:     sql.NullString{String: duckdbType, Valid: true},
                                MinimumScale:      sql.NullInt32{Int32: getMinimumScale(arrowType), Valid: true},
                                MaximumScale:      sql.NullInt32{Int32: getMaximumScale(arrowType), Valid: true},
                                SQLDataType:       sqlType,
                                DatetimeSubcode:   sql.NullInt32{Int32: getSQLDateTimeSub(arrowType), Valid: true},
                                NumPrecRadix:      sql.NullInt32{Int32: getNumPrecRadix(arrowType), Valid: true},
                                IntervalPrecision: sql.NullInt32{Int32: 0, Valid: true},
                        })</span>
                }
        }
        <span class="cov0" title="0">return types, nil</span>
}

// Helper functions for XDBC type info
func getColumnSize(arrowType arrow.DataType) int32 <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.INT8, arrow.UINT8:<span class="cov0" title="0">
                return 3</span>
        case arrow.INT16, arrow.UINT16:<span class="cov0" title="0">
                return 5</span>
        case arrow.INT32, arrow.UINT32:<span class="cov0" title="0">
                return 10</span>
        case arrow.INT64, arrow.UINT64:<span class="cov0" title="0">
                return 19</span>
        case arrow.FLOAT32:<span class="cov0" title="0">
                return 7</span>
        case arrow.FLOAT64:<span class="cov0" title="0">
                return 15</span>
        case arrow.STRING:<span class="cov0" title="0">
                return 0</span> // Variable length
        case arrow.DECIMAL:<span class="cov0" title="0">
                decimalType := arrowType.(arrow.DecimalType)
                return decimalType.GetPrecision()</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func getLiteralPrefix(arrowType arrow.DataType) string <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.STRING:<span class="cov0" title="0">
                return "'"</span>
        case arrow.DATE32, arrow.DATE64:<span class="cov0" title="0">
                return "'"</span>
        case arrow.TIMESTAMP:<span class="cov0" title="0">
                return "'"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func getLiteralSuffix(arrowType arrow.DataType) string <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.STRING:<span class="cov0" title="0">
                return "'"</span>
        case arrow.DATE32, arrow.DATE64:<span class="cov0" title="0">
                return "'"</span>
        case arrow.TIMESTAMP:<span class="cov0" title="0">
                return "'"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func getCreateParams(arrowType arrow.DataType) string <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.DECIMAL:<span class="cov0" title="0">
                return "precision,scale"</span>
        case arrow.STRING:<span class="cov0" title="0">
                return "length"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func getCaseSensitive(arrowType arrow.DataType) bool <span class="cov0" title="0">{
        return arrowType.ID() == arrow.STRING
}</span>

func getFixedPrecScale(arrowType arrow.DataType) bool <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.INT8, arrow.INT16, arrow.INT32, arrow.INT64,
                arrow.UINT8, arrow.UINT16, arrow.UINT32, arrow.UINT64,
                arrow.FLOAT32, arrow.FLOAT64:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func getMinimumScale(arrowType arrow.DataType) int32 <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.DECIMAL:<span class="cov0" title="0">
                return 0</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func getMaximumScale(arrowType arrow.DataType) int32 <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.DECIMAL:<span class="cov0" title="0">
                decimalType := arrowType.(arrow.DecimalType)
                return decimalType.GetScale()</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func getSQLDateTimeSub(arrowType arrow.DataType) int32 <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.DATE32, arrow.DATE64:<span class="cov0" title="0">
                return 1</span> // SQL_CODE_DATE
        case arrow.TIMESTAMP:<span class="cov0" title="0">
                return 2</span> // SQL_CODE_TIMESTAMP
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func getNumPrecRadix(arrowType arrow.DataType) int32 <span class="cov0" title="0">{
        switch arrowType.ID() </span>{
        case arrow.INT8, arrow.INT16, arrow.INT32, arrow.INT64,
                arrow.UINT8, arrow.UINT16, arrow.UINT32, arrow.UINT64:<span class="cov0" title="0">
                return 10</span>
        case arrow.FLOAT32, arrow.FLOAT64:<span class="cov0" title="0">
                return 2</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func (r *metadataRepository) GetSQLInfo(ctx context.Context, ids []uint32) ([]models.SQLInfo, error) <span class="cov0" title="0">{
        return r.sqlInfo.GetSQLInfo(ids)
}</span>

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// small helpers
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func (r *metadataRepository) conn(ctx context.Context) (*sql.Conn, error) <span class="cov0" title="0">{
        db, err := r.pool.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.CodeConnectionFailed, "get conn")
        }</span>
        <span class="cov0" title="0">return db.Conn(ctx)</span>
}

func (r *metadataRepository) wrapDBErr(err error, sql string) error <span class="cov0" title="0">{
        return errors.Wrap(err, errors.CodeQueryFailed, fmt.Sprintf("duckdb query: %s", sql))
}</span>

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// scanning helpers
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func scanSchemas(rows *sql.Rows, catalog string) ([]models.Schema, error) <span class="cov0" title="0">{
        var out []models.Schema
        for rows.Next() </span><span class="cov0" title="0">{
                var name string
                if err := rows.Scan(&amp;name); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out = append(out, models.Schema{CatalogName: catalog, Name: name})</span>
        }
        <span class="cov0" title="0">return out, rows.Err()</span>
}

func scanTables(rows *sql.Rows) ([]models.Table, error) <span class="cov0" title="0">{
        var tbls []models.Table
        for rows.Next() </span><span class="cov0" title="0">{
                var t models.Table
                if err := rows.Scan(&amp;t.CatalogName, &amp;t.SchemaName, &amp;t.Name, &amp;t.Type); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">tbls = append(tbls, t)</span>
        }
        <span class="cov0" title="0">return tbls, rows.Err()</span>
}

func scanColumns(rows *sql.Rows) ([]models.Column, error) <span class="cov0" title="0">{
        var cols []models.Column
        for rows.Next() </span><span class="cov0" title="0">{
                var c models.Column
                var nullable string
                if err := rows.Scan(
                        &amp;c.CatalogName, &amp;c.SchemaName, &amp;c.TableName,
                        &amp;c.Name, &amp;c.OrdinalPosition, &amp;c.DefaultValue,
                        &amp;nullable, &amp;c.DataType, &amp;c.CharMaxLength,
                        &amp;c.NumericPrecision, &amp;c.NumericScale, &amp;c.DateTimePrecision,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">c.IsNullable = nullable == "YES"
                cols = append(cols, c)</span>
        }
        <span class="cov0" title="0">return cols, rows.Err()</span>
}

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// tiny util funcs
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func like(s string) string <span class="cov0" title="0">{
        if isWildPtr(&amp;s) </span><span class="cov0" title="0">{
                return "%"
        }</span>
        <span class="cov0" title="0">return s</span>
}
func likeDeref(ptr *string) string <span class="cov0" title="0">{ return like(strPtr(ptr)) }</span>
func isWildPtr(p *string) bool     <span class="cov0" title="0">{ return p == nil || isWild(*p) }</span>
func isWild(s string) bool         <span class="cov0" title="0">{ return s == "" || s == "%" }</span>
func strPtr(p *string) string <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *p</span>
}

func quoteIdentifier(name string) string <span class="cov0" title="0">{
        return fmt.Sprintf("\"%s\"", strings.ReplaceAll(name, "\"", "\"\""))
}</span>

func toFKRule(rule string) models.FKRule <span class="cov0" title="0">{
        switch strings.ToUpper(rule) </span>{
        case "CASCADE":<span class="cov0" title="0">
                return models.FKRuleCascade</span>
        case "RESTRICT":<span class="cov0" title="0">
                return models.FKRuleRestrict</span>
        case "SET NULL":<span class="cov0" title="0">
                return models.FKRuleSetNull</span>
        case "SET DEFAULT":<span class="cov0" title="0">
                return models.FKRuleSetDefault</span>
        default:<span class="cov0" title="0">
                return models.FKRuleNoAction</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Package duckdb provides DuckDB‚Äëspecific repository implementations.
package duckdb

import (
        "context"
        "database/sql"
        "sync"
        "sync/atomic"
        "time"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/memory"
        "github.com/rs/zerolog"

        "github.com/TFMV/porter/pkg/errors"
        "github.com/TFMV/porter/pkg/infrastructure/converter"
        "github.com/TFMV/porter/pkg/infrastructure/pool"
        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/repositories"
)

//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// Repository
//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

// preparedStatementRepository implements repositories.PreparedStatementRepository.
type preparedStatementRepository struct {
        pool       pool.ConnectionPool
        alloc      memory.Allocator
        log        zerolog.Logger
        statements sync.Map // map[string]*preparedStatement
}

func NewPreparedStatementRepository(p pool.ConnectionPool, a memory.Allocator, lg zerolog.Logger) repositories.PreparedStatementRepository <span class="cov0" title="0">{
        return &amp;preparedStatementRepository{
                pool:  p,
                alloc: a,
                log:   lg.With().Str("repo", "prepared_stmt").Logger(),
        }
}</span>

//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// Public API
//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

func (r *preparedStatementRepository) Store(_ context.Context, ps *models.PreparedStatement) error <span class="cov0" title="0">{
        r.log.Debug().Str("handle", ps.Handle).Msg("store prepared stmt")
        r.statements.Store(ps.Handle, &amp;preparedStatement{model: ps, createdAt: now()})
        return nil
}</span>

func (r *preparedStatementRepository) Get(_ context.Context, h string) (*models.PreparedStatement, error) <span class="cov0" title="0">{
        ps, ok := r.loadPS(h)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.ErrStatementNotFound.WithDetail("handle", h)
        }</span>
        <span class="cov0" title="0">return ps.model, nil</span>
}

func (r *preparedStatementRepository) Remove(_ context.Context, h string) error <span class="cov0" title="0">{
        ps, ok := r.deletePS(h)
        if !ok </span><span class="cov0" title="0">{
                return errors.ErrStatementNotFound.WithDetail("handle", h)
        }</span>
        <span class="cov0" title="0">if ps.stmt != nil </span><span class="cov0" title="0">{
                _ = ps.stmt.Close() // log only on failure
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *preparedStatementRepository) ExecuteQuery(ctx context.Context, h string, params [][]interface{}) (*models.QueryResult, error) <span class="cov0" title="0">{
        ps, ok := r.loadPS(h)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.ErrStatementNotFound.WithDetail("handle", h)
        }</span>

        // acquire db connection &amp; prepare stmt lazily
        <span class="cov0" title="0">var rows *sql.Rows
        if err := r.withConn(ctx, func(conn *sql.Conn) (err error) </span><span class="cov0" title="0">{
                if err = ps.ensurePrepared(ctx, conn); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if batch := firstBatch(params); batch != nil </span><span class="cov0" title="0">{
                        rows, err = ps.stmt.QueryContext(ctx, batch...)
                }</span> else<span class="cov0" title="0"> {
                        rows, err = ps.stmt.QueryContext(ctx)
                }</span>
                <span class="cov0" title="0">return</span>
        }); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">reader, err := converter.NewBatchReader(r.alloc, rows, r.log)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.CodeInternal, "new batch reader")
        }</span>

        <span class="cov0" title="0">out := make(chan arrow.Record, 8)
        go streamRecords(ctx, reader, out, r.log)

        ps.bumpUsage()
        return &amp;models.QueryResult{Schema: reader.Schema(), Records: out}, nil</span>
}

func (r *preparedStatementRepository) ExecuteUpdate(ctx context.Context, h string, params [][]interface{}) (*models.UpdateResult, error) <span class="cov0" title="0">{
        ps, ok := r.loadPS(h)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.ErrStatementNotFound.WithDetail("handle", h)
        }</span>

        <span class="cov0" title="0">var (
                result sql.Result
                start  = time.Now()
        )

        err := r.withConn(ctx, func(conn *sql.Conn) error </span><span class="cov0" title="0">{
                if err := ps.ensurePrepared(ctx, conn); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">var execErr error
                if batch := firstBatch(params); batch != nil </span><span class="cov0" title="0">{
                        result, execErr = ps.stmt.ExecContext(ctx, batch...)
                }</span> else<span class="cov0" title="0"> {
                        result, execErr = ps.stmt.ExecContext(ctx)
                }</span>
                <span class="cov0" title="0">return execErr</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rows, _ := result.RowsAffected() // ignore error, ‚Äë1 on unknown
        ps.bumpUsage()

        dur := time.Since(start)
        r.log.Debug().
                Str("handle", h).
                Int64("rows", rows).
                Dur("elapsed", dur).
                Msg("update ok")

        return &amp;models.UpdateResult{RowsAffected: rows, ExecutionTime: dur}, nil</span>
}

func (r *preparedStatementRepository) List(_ context.Context, txID string) ([]*models.PreparedStatement, error) <span class="cov0" title="0">{
        var list []*models.PreparedStatement
        r.statements.Range(func(_, v any) bool </span><span class="cov0" title="0">{
                ps := v.(*preparedStatement)
                if txID == "" || ps.model.TransactionID == txID </span><span class="cov0" title="0">{
                        list = append(list, ps.model)
                }</span>
                <span class="cov0" title="0">return true</span>
        })
        <span class="cov0" title="0">return list, nil</span>
}

//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// internal helpers
//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

func (r *preparedStatementRepository) withConn(ctx context.Context, fn func(*sql.Conn) error) error <span class="cov0" title="0">{
        db, err := r.pool.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.CodeConnectionFailed, "get conn")
        }</span>
        <span class="cov0" title="0">conn, err := db.Conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.CodeConnectionFailed, "get conn")
        }</span>
        <span class="cov0" title="0">return fn(conn)</span>
}

func (r *preparedStatementRepository) loadPS(h string) (*preparedStatement, bool) <span class="cov0" title="0">{
        if v, ok := r.statements.Load(h); ok </span><span class="cov0" title="0">{
                return v.(*preparedStatement), true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}
func (r *preparedStatementRepository) deletePS(h string) (*preparedStatement, bool) <span class="cov0" title="0">{
        if v, ok := r.statements.LoadAndDelete(h); ok </span><span class="cov0" title="0">{
                return v.(*preparedStatement), true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

func firstBatch(b [][]interface{}) []interface{} <span class="cov0" title="0">{
        if len(b) &gt; 0 &amp;&amp; len(b[0]) &gt; 0 </span><span class="cov0" title="0">{
                return b[0]
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// streamRecords copies Arrow records from reader to chan with proper Retain/Release.
func streamRecords(ctx context.Context, br *converter.BatchReader, out chan arrow.Record, log zerolog.Logger) <span class="cov0" title="0">{
        defer close(out)
        defer br.Release()

        var total int64
        for br.Next() </span><span class="cov0" title="0">{
                rec := br.Record()
                if rec == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">rec.Retain()
                total += rec.NumRows()

                select </span>{
                case out &lt;- rec:<span class="cov0" title="0"></span>
                        // consumer will Release()
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        rec.Release()
                        return</span>
                }
        }
        <span class="cov0" title="0">if err := br.Err(); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("batch reader")
        }</span>
        <span class="cov0" title="0">log.Debug().Int64("rows", total).Msg("stream complete")</span>
}

// now is var for deterministic tests.
var now = time.Now

//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// internal prepared stmt wrapper
//‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

type preparedStatement struct {
        model     *models.PreparedStatement
        stmt      *sql.Stmt
        createdAt time.Time
        once      sync.Once
}

func (p *preparedStatement) ensurePrepared(ctx context.Context, conn *sql.Conn) error <span class="cov0" title="0">{
        var err error
        p.once.Do(func() </span><span class="cov0" title="0">{
                p.stmt, err = conn.PrepareContext(ctx, p.model.Query)
        }</span>)
        <span class="cov0" title="0">return err</span>
}

func (p *preparedStatement) bumpUsage() <span class="cov0" title="0">{
        atomic.AddInt64(&amp;p.model.ExecutionCount, 1)
        p.model.LastUsedAt = now()
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">// Package duckdb provides DuckDB‚Äëspecific repository implementations.
package duckdb

import (
        "context"
        "database/sql"
        "time"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/memory"
        "github.com/rs/zerolog"

        "github.com/TFMV/porter/pkg/errors"
        "github.com/TFMV/porter/pkg/infrastructure/converter"
        "github.com/TFMV/porter/pkg/infrastructure/pool"
        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/repositories"
)

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Repository
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// queryRepository implements repositories.QueryRepository for DuckDB.
type queryRepository struct {
        pool  pool.ConnectionPool
        alloc memory.Allocator
        log   zerolog.Logger
}

func NewQueryRepository(p pool.ConnectionPool, a memory.Allocator, lg zerolog.Logger) repositories.QueryRepository <span class="cov0" title="0">{
        return &amp;queryRepository{
                pool:  p,
                alloc: a,
                log:   lg.With().Str("repo", "query").Logger(),
        }
}</span>

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Public API
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func (r *queryRepository) ExecuteQuery(
        ctx context.Context,
        query string,
        txn repositories.Transaction,
        args ...interface{},
) (*models.QueryResult, error) <span class="cov0" title="0">{

        r.log.Debug().
                Str("sql", truncate(query, 120)).
                Bool("in_tx", txn != nil).
                Int("args", len(args)).
                Msg("execute query")

        qr, err := withQuerier(r, ctx, txn, func(q querier) (*models.QueryResult, error) </span><span class="cov0" title="0">{
                rows, err := q.QueryContext(ctx, query, args...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, errors.CodeQueryFailed, "query")
                }</span>

                <span class="cov0" title="0">reader, err := converter.NewBatchReader(r.alloc, rows, r.log)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, errors.CodeInternal, "batch reader")
                }</span>

                <span class="cov0" title="0">out := make(chan arrow.Record, 8)
                go streamQueryRecords(ctx, reader, out, r.log)

                return &amp;models.QueryResult{
                        Schema:  reader.Schema(),
                        Records: out,
                }, nil</span>
        })
        <span class="cov0" title="0">return qr, err</span>
}

func (r *queryRepository) ExecuteUpdate(
        ctx context.Context,
        sqlStmt string,
        txn repositories.Transaction,
        args ...interface{},
) (*models.UpdateResult, error) <span class="cov0" title="0">{

        r.log.Debug().
                Str("sql", truncate(sqlStmt, 120)).
                Bool("in_tx", txn != nil).
                Int("args", len(args)).
                Msg("execute update")

        start := time.Now()

        ur, err := withQuerier(r, ctx, txn, func(q querier) (*models.UpdateResult, error) </span><span class="cov0" title="0">{
                res, err := q.ExecContext(ctx, sqlStmt, args...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, errors.CodeQueryFailed, "exec")
                }</span>
                <span class="cov0" title="0">rows, _ := res.RowsAffected() // ignore error, ‚Äë1 on unknown
                return &amp;models.UpdateResult{
                        RowsAffected:  rows,
                        ExecutionTime: time.Since(start),
                }, nil</span>
        })

        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                r.log.Debug().
                        Int64("rows", ur.RowsAffected).
                        Dur("elapsed", ur.ExecutionTime).
                        Msg("update ok")
        }</span>
        <span class="cov0" title="0">return ur, err</span>
}

func (r *queryRepository) Prepare(
        ctx context.Context,
        query string,
        txn repositories.Transaction,
) (*sql.Stmt, error) <span class="cov0" title="0">{

        r.log.Debug().
                Str("sql", truncate(query, 120)).
                Bool("in_tx", txn != nil).
                Msg("prepare")

        stmt, err := withQuerier(r, ctx, txn, func(q querier) (*sql.Stmt, error) </span><span class="cov0" title="0">{
                ps, err := q.PrepareContext(ctx, query)
                return ps, errors.Wrap(err, errors.CodeQueryFailed, "prepare")
        }</span>)
        <span class="cov0" title="0">return stmt, err</span>
}

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Internal helpers
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// querier is the common subset implemented by *sql.Conn and *sql.Tx.
type querier interface {
        QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
        ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
        PrepareContext(context.Context, string) (*sql.Stmt, error)
}

// withQuerier executes a function with either a transaction or connection.
func withQuerier[T any](
        r *queryRepository,
        ctx context.Context,
        txn repositories.Transaction,
        fn func(querier) (T, error),
) (T, error) <span class="cov0" title="0">{
        // When returning early we need zero value of T
        var zero T

        if txn != nil </span><span class="cov0" title="0">{
                tx := txn.GetDBTx()
                if tx == nil </span><span class="cov0" title="0">{
                        return zero, errors.New(errors.CodeTransactionFailed, "nil sql.Tx in Transaction")
                }</span>
                <span class="cov0" title="0">return fn(tx)</span>
        }

        <span class="cov0" title="0">conn, err := r.pool.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return zero, errors.Wrap(err, errors.CodeConnectionFailed, "get conn")
        }</span>
        // Do not defer conn.Close(); rows/stmt hold the conn until closed.

        <span class="cov0" title="0">return fn(conn)</span>
}

// streamQueryRecords sends Arrow records to channel with correct ref‚Äëcount handling.
func streamQueryRecords(ctx context.Context, br *converter.BatchReader, out chan arrow.Record, log zerolog.Logger) <span class="cov0" title="0">{
        defer close(out)
        defer br.Release()

        var rows int64
        for br.Next() </span><span class="cov0" title="0">{
                rec := br.Record()
                if rec == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">rec.Retain()
                rows += rec.NumRows()

                select </span>{
                case out &lt;- rec:<span class="cov0" title="0"></span>
                        // consumer is now owner
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        rec.Release()
                        return</span>
                }
        }
        <span class="cov0" title="0">if err := br.Err(); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("batch reader")
        }</span>
        <span class="cov0" title="0">log.Debug().Int64("rows", rows).Msg("stream complete")</span>
}

// truncate shortens long SQL strings for logs.
func truncate(s string, max int) string <span class="cov0" title="0">{
        if len(s) &lt;= max </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:max] + "‚Ä¶"</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Package duckdb provides DuckDB‚Äëspecific repository implementations.
package duckdb

import (
        "context"
        "database/sql"
        "sync"
        "sync/atomic"
        "time"

        "github.com/google/uuid"
        "github.com/rs/zerolog"

        "github.com/TFMV/porter/pkg/errors"
        "github.com/TFMV/porter/pkg/infrastructure/pool"
        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/repositories"
)

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Repository
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// transactionRepository implements repositories.TransactionRepository.
type transactionRepository struct {
        pool  pool.ConnectionPool
        log   zerolog.Logger
        txMap sync.Map // key = id, val = *duckdbTransaction
}

func NewTransactionRepository(p pool.ConnectionPool, lg zerolog.Logger) repositories.TransactionRepository <span class="cov0" title="0">{
        return &amp;transactionRepository{
                pool: p,
                log:  lg.With().Str("repo", "txn").Logger(),
        }
}</span>

// Begin starts a new SQL transaction.
func (r *transactionRepository) Begin(ctx context.Context, opt models.TransactionOptions) (repositories.Transaction, error) <span class="cov0" title="0">{
        r.log.Debug().
                Str("iso", string(opt.IsolationLevel)).
                Bool("ro", opt.ReadOnly).
                Msg("begin")

        conn, err := r.pool.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.CodeConnectionFailed, "get conn")
        }</span>

        <span class="cov0" title="0">sqlTx, err := conn.BeginTx(ctx, &amp;sql.TxOptions{
                Isolation: mapIsolation(opt.IsolationLevel),
                ReadOnly:  opt.ReadOnly,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.CodeTransactionFailed, "begin tx")
        }</span>

        <span class="cov0" title="0">sqlConn, err := conn.Conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.CodeConnectionFailed, "get conn")
        }</span>

        <span class="cov0" title="0">txn := &amp;duckdbTransaction{
                id:       uuid.NewString(),
                sqlTx:    sqlTx,
                conn:     sqlConn,
                readOnly: opt.ReadOnly,
                started:  time.Now(),
        }
        r.store(txn)

        r.log.Info().Str("id", txn.id).Msg("txn started")
        return txn, nil</span>
}

// Get returns an active transaction or ErrTransactionNotFound.
func (r *transactionRepository) Get(_ context.Context, id string) (repositories.Transaction, error) <span class="cov0" title="0">{
        if txn, ok := r.load(id); ok &amp;&amp; txn.IsActive() </span><span class="cov0" title="0">{
                return txn, nil
        }</span>
        <span class="cov0" title="0">return nil, errors.ErrTransactionNotFound.WithDetail("transaction_id", id)</span>
}

// List returns all active transactions.
func (r *transactionRepository) List(_ context.Context) ([]repositories.Transaction, error) <span class="cov0" title="0">{
        var list []repositories.Transaction
        r.txMap.Range(func(_, v any) bool </span><span class="cov0" title="0">{
                t := v.(*duckdbTransaction)
                if t.IsActive() </span><span class="cov0" title="0">{
                        list = append(list, t)
                }</span> else<span class="cov0" title="0"> {
                        r.delete(t.id)
                }</span>
                <span class="cov0" title="0">return true</span>
        })
        <span class="cov0" title="0">return list, nil</span>
}

// Remove deletes a transaction record (no commit/rollback).
func (r *transactionRepository) Remove(_ context.Context, id string) error <span class="cov0" title="0">{
        r.delete(id)
        return nil
}</span>

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// internal map helpers
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func (r *transactionRepository) store(t *duckdbTransaction) <span class="cov0" title="0">{ r.txMap.Store(t.id, t) }</span>
func (r *transactionRepository) load(id string) (*duckdbTransaction, bool) <span class="cov0" title="0">{
        v, ok := r.txMap.Load(id)
        if !ok </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return v.(*duckdbTransaction), true</span>
}
func (r *transactionRepository) delete(id string) <span class="cov0" title="0">{ r.txMap.Delete(id) }</span>

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// isolation mapping
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func mapIsolation(lvl models.IsolationLevel) sql.IsolationLevel <span class="cov0" title="0">{
        switch lvl </span>{
        case models.IsolationLevelReadUncommitted:<span class="cov0" title="0">
                return sql.LevelReadUncommitted</span>
        case models.IsolationLevelReadCommitted:<span class="cov0" title="0">
                return sql.LevelReadCommitted</span>
        case models.IsolationLevelRepeatableRead:<span class="cov0" title="0">
                return sql.LevelRepeatableRead</span>
        case models.IsolationLevelSerializable:<span class="cov0" title="0">
                return sql.LevelSerializable</span>
        default:<span class="cov0" title="0">
                return sql.LevelDefault</span>
        }
}

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// duckdbTransaction
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

type duckdbTransaction struct {
        id       string
        sqlTx    *sql.Tx
        conn     *sql.Conn // returned to pool on Commit/Rollback
        readOnly bool

        started time.Time
        active  atomic.Bool
}

func (t *duckdbTransaction) ID() string <span class="cov0" title="0">{ return t.id }</span>

func (t *duckdbTransaction) Commit(ctx context.Context) error <span class="cov0" title="0">{
        if !t.setInactive() </span><span class="cov0" title="0">{
                return errors.New(errors.CodeTransactionFailed, "transaction not active")
        }</span>
        <span class="cov0" title="0">if err := t.sqlTx.Commit(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.CodeTransactionFailed, "commit")
        }</span>
        <span class="cov0" title="0">_ = t.conn.Close()
        return nil</span>
}

func (t *duckdbTransaction) Rollback(ctx context.Context) error <span class="cov0" title="0">{
        if !t.setInactive() </span><span class="cov0" title="0">{
                return errors.New(errors.CodeTransactionFailed, "transaction not active")
        }</span>
        <span class="cov0" title="0">if err := t.sqlTx.Rollback(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.CodeTransactionFailed, "rollback")
        }</span>
        <span class="cov0" title="0">_ = t.conn.Close()
        return nil</span>
}

func (t *duckdbTransaction) IsActive() bool <span class="cov0" title="0">{ return t.active.Load() }</span>

func (t *duckdbTransaction) GetDBTx() *sql.Tx <span class="cov0" title="0">{
        if t.IsActive() </span><span class="cov0" title="0">{
                return t.sqlTx
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// setInactive atomically flips the active flag; returns true if it was active.
func (t *duckdbTransaction) setInactive() bool <span class="cov0" title="0">{ return t.active.Swap(false) }</span>

// ensure active on creation
func init() <span class="cov0" title="0">{
        var dummy duckdbTransaction
        dummy.active.Store(true)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package server

import (
        "context"
        "fmt"
        "io"
        "strings"

        "github.com/apache/arrow-go/v18/arrow/array"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/flight"
        "github.com/apache/arrow-go/v18/arrow/flight/flightsql"
        arrowmemory "github.com/apache/arrow-go/v18/arrow/memory"
        "github.com/rs/zerolog"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/TFMV/porter/cmd/server/config"
        "github.com/TFMV/porter/pkg/cache"
        "github.com/TFMV/porter/pkg/handlers"
        "github.com/TFMV/porter/pkg/infrastructure/pool"
        "github.com/TFMV/porter/pkg/services"
)

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Types and Interfaces
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// MetricsCollector defines the metrics interface.
type MetricsCollector interface {
        IncrementCounter(name string, labels ...string)
        RecordHistogram(name string, value float64, labels ...string)
        RecordGauge(name string, value float64, labels ...string)
        StartTimer(name string) Timer
}

// Timer represents a timing measurement.
type Timer interface {
        Stop() float64
}

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// FlightSQLServer
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// FlightSQLServer implements the Flight SQL protocol.
type FlightSQLServer struct {
        flightsql.BaseServer

        // Core components
        pool        pool.ConnectionPool
        allocator   arrowmemory.Allocator
        logger      zerolog.Logger
        memoryCache cache.Cache
        cacheKeyGen cache.CacheKeyGenerator

        // Handlers
        queryHandler             handlers.QueryHandler
        metadataHandler          handlers.MetadataHandler
        transactionHandler       handlers.TransactionHandler
        preparedStatementHandler handlers.PreparedStatementHandler

        // Services
        transactionService services.TransactionService

        // State (reserved for future session management)
        // TODO: add session tracking when authentication is implemented
}

// New creates a new Flight SQL server (placeholder - use NewFlightSQLServer for now).
func New(cfg *config.Config, logger zerolog.Logger, metrics MetricsCollector) (*FlightSQLServer, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("use NewFlightSQLServer constructor instead")
}</span>

// Register registers the Flight SQL server with a gRPC server.
func (s *FlightSQLServer) Register(grpcServer *grpc.Server) <span class="cov0" title="0">{
        // Create a Flight SQL server that properly handles SQL commands
        flightServer := flightsql.NewFlightServer(s)
        flight.RegisterFlightServiceServer(grpcServer, flightServer)
}</span>

// GetMiddleware returns gRPC middleware for the server.
func (s *FlightSQLServer) GetMiddleware() []grpc.ServerOption <span class="cov0" title="0">{
        var opts []grpc.ServerOption
        // TODO: Add middleware implementation
        return opts
}</span>

// Close gracefully shuts down the server.
func (s *FlightSQLServer) Close(ctx context.Context) error <span class="cov0" title="0">{
        s.logger.Info().Msg("Closing Flight SQL server")

        // Stop transaction service if it has a Stop method
        if stopper, ok := s.transactionService.(interface{ Stop() }); ok </span><span class="cov0" title="0">{
                stopper.Stop()
        }</span>

        // Close cache
        <span class="cov0" title="0">if err := s.memoryCache.Close(); err != nil </span><span class="cov0" title="0">{
                s.logger.Error().Err(err).Msg("Error closing cache")
        }</span>

        // Close connection pool
        <span class="cov0" title="0">if err := s.pool.Close(); err != nil </span><span class="cov0" title="0">{
                s.logger.Error().Err(err).Msg("Error closing connection pool")
        }</span>

        <span class="cov0" title="0">s.logger.Info().Msg("Flight SQL server closed")
        return nil</span>
}

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Query helpers (deprecated - keeping for compatibility)
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// NewFlightSQLServer wires up all dependencies (deprecated - use New instead).
func NewFlightSQLServer(
        qh handlers.QueryHandler,
        mh handlers.MetadataHandler,
        th handlers.TransactionHandler,
        ph handlers.PreparedStatementHandler,
        p pool.ConnectionPool,
        conv interface{}, // converter.TypeConverter - keeping for compatibility
        alloc arrowmemory.Allocator,
        c cache.Cache,
        kg cache.CacheKeyGenerator,
        m interface{}, // metrics.Collector - keeping for compatibility
        lg zerolog.Logger,
) *FlightSQLServer <span class="cov10" title="12">{
        return &amp;FlightSQLServer{
                queryHandler:             qh,
                metadataHandler:          mh,
                transactionHandler:       th,
                preparedStatementHandler: ph,
                pool:                     p,
                allocator:                alloc,
                memoryCache:              c,
                cacheKeyGen:              kg,
                logger:                   lg.With().Str("component", "server").Logger(),
        }
}</span>

// infoFromSchema creates a FlightInfo from a query and schema.
func (s *FlightSQLServer) infoFromSchema(query string, schema *arrow.Schema) *flight.FlightInfo <span class="cov1" title="1">{
        desc := &amp;flight.FlightDescriptor{
                Type: flight.DescriptorCMD,
                Cmd:  []byte(query),
        }
        return &amp;flight.FlightInfo{
                Schema:           flight.SerializeSchema(schema, s.allocator),
                FlightDescriptor: desc,
                Endpoint: []*flight.FlightEndpoint{{
                        Ticket: &amp;flight.Ticket{Ticket: desc.Cmd},
                }},
                TotalRecords: -1,
                TotalBytes:   -1,
        }
}</span>

// infoStatic creates a FlightInfo for static metadata endpoints.
func (s *FlightSQLServer) infoStatic(desc *flight.FlightDescriptor, schema *arrow.Schema) *flight.FlightInfo <span class="cov3" title="2">{
        return &amp;flight.FlightInfo{
                Schema:           flight.SerializeSchema(schema, s.allocator),
                FlightDescriptor: desc,
                Endpoint: []*flight.FlightEndpoint{{
                        Ticket: &amp;flight.Ticket{Ticket: desc.Cmd},
                }},
                TotalRecords: -1,
                TotalBytes:   -1,
        }
}</span>

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Query helpers
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// GetFlightInfoStatement handles CommandStatementQuery requests from Flight SQL clients
func (s *FlightSQLServer) GetFlightInfoStatement(
        ctx context.Context,
        cmd flightsql.StatementQuery,
        desc *flight.FlightDescriptor,
) (*flight.FlightInfo, error) <span class="cov4" title="3">{
        // Use the query handler to get flight info for the query
        info, err := s.queryHandler.GetFlightInfo(ctx, cmd.GetQuery())
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "get flight info: %v", err)
        }</span>
        <span class="cov4" title="3">return info, nil</span>
}

// DoGetStatement streams the query results, with a fast path to the cache.
func (s *FlightSQLServer) DoGetStatement(
        ctx context.Context,
        ticket flightsql.StatementQueryTicket,
) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov4" title="3">{
        // The statement handle contains the original query as bytes
        query := string(ticket.GetStatementHandle())
        s.logger.Info().Str("query", query).Msg("DoGetStatement received query")
        key := s.cacheKeyGen.GenerateKey(query, nil)

        // ‚îÄ‚îÄ cache hit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if rec, _ := s.memoryCache.Get(ctx, key); rec != nil </span><span class="cov1" title="1">{
                ch := make(chan flight.StreamChunk, 1)
                ch &lt;- flight.StreamChunk{Data: rec}
                close(ch)
                return rec.Schema(), ch, nil
        }</span>

        // ‚îÄ‚îÄ cache miss: ask handler ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        <span class="cov3" title="2">schema, upstream, err := s.queryHandler.ExecuteStatement(ctx, query, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov3" title="2">down := make(chan flight.StreamChunk, 16)

        go func() </span><span class="cov3" title="2">{
                defer close(down)
                first := true
                for c := range upstream </span><span class="cov1" title="1">{
                        if first &amp;&amp; c.Data != nil </span><span class="cov1" title="1">{
                                _ = s.memoryCache.Put(ctx, key, c.Data)
                                first = false
                        }</span>
                        <span class="cov1" title="1">down &lt;- c</span>
                }
        }()

        <span class="cov3" title="2">return schema, down, nil</span>
}

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Update
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func (s *FlightSQLServer) DoPutCommandStatementUpdate(
        ctx context.Context,
        req flightsql.StatementUpdate,
) (int64, error) <span class="cov3" title="2">{
        affected, err := s.queryHandler.ExecuteUpdate(ctx, req.GetQuery(), string(req.GetTransactionId()))
        if err != nil </span><span class="cov1" title="1">{
                return 0, status.Errorf(codes.InvalidArgument, "execute update: %v", err)
        }</span>
        <span class="cov1" title="1">return affected, nil</span>
}

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Metadata helpers
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func (s *FlightSQLServer) infoFromHandler(
        ctx context.Context,
        desc *flight.FlightDescriptor,
        get func() (*arrow.Schema, &lt;-chan flight.StreamChunk, error),
) (*flight.FlightInfo, error) <span class="cov3" title="2">{
        if desc == nil </span><span class="cov1" title="1">{
                return nil, status.Error(codes.InvalidArgument, "missing descriptor")
        }</span>
        <span class="cov1" title="1">schema, _, err := get()
        if err != nil </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.Internal, "%v", err)
        }</span>
        <span class="cov0" title="0">return s.infoStatic(desc, schema), nil</span>
}

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Metadata endpoints
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func (s *FlightSQLServer) GetFlightInfoCatalogs(
        ctx context.Context,
        desc *flight.FlightDescriptor,
) (*flight.FlightInfo, error) <span class="cov3" title="2">{
        schema, _, err := s.metadataHandler.GetCatalogs(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.Internal, "catalogs: %v", err)
        }</span>
        <span class="cov1" title="1">return s.infoStatic(desc, schema), nil</span>
}

func (s *FlightSQLServer) DoGetCatalogs(
        ctx context.Context,
) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        return s.metadataHandler.GetCatalogs(ctx)
}</span>

func (s *FlightSQLServer) GetFlightInfoSchemas(
        ctx context.Context,
        cmd flightsql.GetDBSchemas,
        desc *flight.FlightDescriptor,
) (*flight.FlightInfo, error) <span class="cov0" title="0">{
        return s.infoFromHandler(ctx, desc, func() (*arrow.Schema, &lt;-chan flight.StreamChunk, error) </span><span class="cov0" title="0">{
                return s.metadataHandler.GetSchemas(ctx, cmd.GetCatalog(), cmd.GetDBSchemaFilterPattern())
        }</span>)
}

func (s *FlightSQLServer) DoGetDBSchemas(
        ctx context.Context,
        cmd flightsql.GetDBSchemas,
) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        return s.metadataHandler.GetSchemas(ctx, cmd.GetCatalog(), cmd.GetDBSchemaFilterPattern())
}</span>

func (s *FlightSQLServer) GetFlightInfoTables(
        ctx context.Context,
        cmd flightsql.GetTables,
        desc *flight.FlightDescriptor,
) (*flight.FlightInfo, error) <span class="cov0" title="0">{
        return s.infoFromHandler(ctx, desc, func() (*arrow.Schema, &lt;-chan flight.StreamChunk, error) </span><span class="cov0" title="0">{
                return s.metadataHandler.GetTables(
                        ctx,
                        cmd.GetCatalog(),
                        cmd.GetDBSchemaFilterPattern(),
                        cmd.GetTableNameFilterPattern(),
                        cmd.GetTableTypes(),
                        cmd.GetIncludeSchema(),
                )
        }</span>)
}

func (s *FlightSQLServer) DoGetTables(
        ctx context.Context,
        cmd flightsql.GetTables,
) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        return s.metadataHandler.GetTables(
                ctx,
                cmd.GetCatalog(),
                cmd.GetDBSchemaFilterPattern(),
                cmd.GetTableNameFilterPattern(),
                cmd.GetTableTypes(),
                cmd.GetIncludeSchema(),
        )
}</span>

func (s *FlightSQLServer) GetFlightInfoTableTypes(
        ctx context.Context,
        desc *flight.FlightDescriptor,
) (*flight.FlightInfo, error) <span class="cov0" title="0">{
        return s.infoFromHandler(ctx, desc, func() (*arrow.Schema, &lt;-chan flight.StreamChunk, error) </span><span class="cov0" title="0">{
                return s.metadataHandler.GetTableTypes(ctx)
        }</span>)
}

func (s *FlightSQLServer) DoGetTableTypes(
        ctx context.Context,
) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        return s.metadataHandler.GetTableTypes(ctx)
}</span>

func (s *FlightSQLServer) GetFlightInfoPrimaryKeys(
        ctx context.Context,
        cmd flightsql.TableRef,
        desc *flight.FlightDescriptor,
) (*flight.FlightInfo, error) <span class="cov0" title="0">{
        return s.infoFromHandler(ctx, desc, func() (*arrow.Schema, &lt;-chan flight.StreamChunk, error) </span><span class="cov0" title="0">{
                return s.metadataHandler.GetPrimaryKeys(ctx, cmd.Catalog, cmd.DBSchema, cmd.Table)
        }</span>)
}

func (s *FlightSQLServer) DoGetPrimaryKeys(
        ctx context.Context,
        cmd flightsql.TableRef,
) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        return s.metadataHandler.GetPrimaryKeys(ctx, cmd.Catalog, cmd.DBSchema, cmd.Table)
}</span>

func (s *FlightSQLServer) GetFlightInfoImportedKeys(
        ctx context.Context,
        cmd flightsql.TableRef,
        desc *flight.FlightDescriptor,
) (*flight.FlightInfo, error) <span class="cov0" title="0">{
        return s.infoFromHandler(ctx, desc, func() (*arrow.Schema, &lt;-chan flight.StreamChunk, error) </span><span class="cov0" title="0">{
                return s.metadataHandler.GetImportedKeys(ctx, cmd.Catalog, cmd.DBSchema, cmd.Table)
        }</span>)
}

func (s *FlightSQLServer) DoGetImportedKeys(
        ctx context.Context,
        cmd flightsql.TableRef,
) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        return s.metadataHandler.GetImportedKeys(ctx, cmd.Catalog, cmd.DBSchema, cmd.Table)
}</span>

func (s *FlightSQLServer) GetFlightInfoExportedKeys(
        ctx context.Context,
        cmd flightsql.TableRef,
        desc *flight.FlightDescriptor,
) (*flight.FlightInfo, error) <span class="cov0" title="0">{
        return s.infoFromHandler(ctx, desc, func() (*arrow.Schema, &lt;-chan flight.StreamChunk, error) </span><span class="cov0" title="0">{
                return s.metadataHandler.GetExportedKeys(ctx, cmd.Catalog, cmd.DBSchema, cmd.Table)
        }</span>)
}

func (s *FlightSQLServer) DoGetExportedKeys(
        ctx context.Context,
        cmd flightsql.TableRef,
) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        return s.metadataHandler.GetExportedKeys(ctx, cmd.Catalog, cmd.DBSchema, cmd.Table)
}</span>

func (s *FlightSQLServer) GetFlightInfoCrossReference(
        ctx context.Context,
        cmd flightsql.CrossTableRef,
        desc *flight.FlightDescriptor,
) (*flight.FlightInfo, error) <span class="cov0" title="0">{
        return s.infoFromHandler(ctx, desc, func() (*arrow.Schema, &lt;-chan flight.StreamChunk, error) </span><span class="cov0" title="0">{
                return s.metadataHandler.GetCrossReference(
                        ctx,
                        cmd.PKRef.Catalog,
                        cmd.PKRef.DBSchema,
                        cmd.PKRef.Table,
                        cmd.FKRef.Catalog,
                        cmd.FKRef.DBSchema,
                        cmd.FKRef.Table,
                )
        }</span>)
}

func (s *FlightSQLServer) DoGetCrossReference(
        ctx context.Context,
        cmd flightsql.CrossTableRef,
) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        return s.metadataHandler.GetCrossReference(
                ctx,
                cmd.PKRef.Catalog,
                cmd.PKRef.DBSchema,
                cmd.PKRef.Table,
                cmd.FKRef.Catalog,
                cmd.FKRef.DBSchema,
                cmd.FKRef.Table,
        )
}</span>

func (s *FlightSQLServer) GetFlightInfoXdbcTypeInfo(
        ctx context.Context,
        cmd flightsql.GetXdbcTypeInfo,
        desc *flight.FlightDescriptor,
) (*flight.FlightInfo, error) <span class="cov0" title="0">{
        return s.infoFromHandler(ctx, desc, func() (*arrow.Schema, &lt;-chan flight.StreamChunk, error) </span><span class="cov0" title="0">{
                return s.metadataHandler.GetXdbcTypeInfo(ctx, cmd.GetDataType())
        }</span>)
}

func (s *FlightSQLServer) DoGetXdbcTypeInfo(
        ctx context.Context,
        cmd flightsql.GetXdbcTypeInfo,
) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        return s.metadataHandler.GetXdbcTypeInfo(ctx, cmd.GetDataType())
}</span>

func (s *FlightSQLServer) GetFlightInfoSqlInfo(
        ctx context.Context,
        cmd flightsql.GetSqlInfo,
        desc *flight.FlightDescriptor,
) (*flight.FlightInfo, error) <span class="cov0" title="0">{
        return s.infoFromHandler(ctx, desc, func() (*arrow.Schema, &lt;-chan flight.StreamChunk, error) </span><span class="cov0" title="0">{
                return s.metadataHandler.GetSqlInfo(ctx, cmd.GetInfo())
        }</span>)
}

func (s *FlightSQLServer) DoGetSqlInfo(
        ctx context.Context,
        cmd flightsql.GetSqlInfo,
) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        return s.metadataHandler.GetSqlInfo(ctx, cmd.GetInfo())
}</span>

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Transactions
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func (s *FlightSQLServer) BeginTransaction(
        ctx context.Context,
        req flightsql.ActionBeginTransactionRequest,
) ([]byte, error) <span class="cov3" title="2">{
        id, err := s.transactionHandler.Begin(ctx, false)
        if err != nil </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.Internal, "begin tx: %v", err)
        }</span>
        <span class="cov1" title="1">return []byte(id), nil</span>
}

func (s *FlightSQLServer) EndTransaction(
        ctx context.Context,
        req flightsql.ActionEndTransactionRequest,
) error <span class="cov4" title="3">{
        id := string(req.GetTransactionId())
        var err error
        switch req.GetAction() </span>{
        case flightsql.EndTransactionCommit:<span class="cov3" title="2">
                err = s.transactionHandler.Commit(ctx, id)</span>
        default:<span class="cov1" title="1">
                err = s.transactionHandler.Rollback(ctx, id)</span>
        }
        <span class="cov4" title="3">if err != nil </span><span class="cov1" title="1">{
                return status.Errorf(codes.Internal, "end tx: %v", err)
        }</span>
        <span class="cov3" title="2">return nil</span>
}

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Prepared statements
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

func (s *FlightSQLServer) CreatePreparedStatement(
        ctx context.Context,
        req flightsql.ActionCreatePreparedStatementRequest,
) (flightsql.ActionCreatePreparedStatementResult, error) <span class="cov6" title="4">{
        query := req.GetQuery()
        if strings.TrimSpace(query) == "" </span><span class="cov1" title="1">{
                return flightsql.ActionCreatePreparedStatementResult{}, status.Error(codes.InvalidArgument, "empty query")
        }</span>

        <span class="cov4" title="3">classifier := services.NewStatementClassifier()
        if err := classifier.ValidateStatement(query); err != nil </span><span class="cov0" title="0">{
                return flightsql.ActionCreatePreparedStatementResult{}, status.Errorf(codes.InvalidArgument, "invalid query: %v", err)
        }</span>

        <span class="cov4" title="3">h, sch, err := s.preparedStatementHandler.Create(ctx, query, string(req.GetTransactionId()))
        if err != nil </span><span class="cov1" title="1">{
                return flightsql.ActionCreatePreparedStatementResult{}, status.Errorf(codes.Internal, "create ps: %v", err)
        }</span>
        <span class="cov3" title="2">return flightsql.ActionCreatePreparedStatementResult{
                Handle:        []byte(h),
                DatasetSchema: sch,
        }, nil</span>
}

func (s *FlightSQLServer) ClosePreparedStatement(
        ctx context.Context,
        req flightsql.ActionClosePreparedStatementRequest,
) error <span class="cov0" title="0">{
        if err := s.preparedStatementHandler.Close(ctx, string(req.GetPreparedStatementHandle())); err != nil </span><span class="cov0" title="0">{
                return status.Errorf(codes.Internal, "close ps: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// appendColumnToBuilder appends the contents of arr to the provided builder.
// It attempts to use an AppendArray method when available and falls back to a
// row-wise copy for common Arrow types.
func appendColumnToBuilder(b array.Builder, arr arrow.Array) <span class="cov7" title="6">{
        // Use AppendArray when the builder supports it.
        if app, ok := b.(interface{ AppendArray(arrow.Array) }); ok </span><span class="cov0" title="0">{
                app.AppendArray(arr)
                return
        }</span>

        <span class="cov7" title="6">switch builder := b.(type) </span>{
        case *array.BooleanBuilder:<span class="cov0" title="0">
                col := arr.(*array.Boolean)
                for i := 0; i &lt; col.Len(); i++ </span><span class="cov0" title="0">{
                        if col.IsNull(i) </span><span class="cov0" title="0">{
                                builder.AppendNull()
                        }</span> else<span class="cov0" title="0"> {
                                builder.Append(col.Value(i))
                        }</span>
                }
        case *array.Int8Builder:<span class="cov0" title="0">
                col := arr.(*array.Int8)
                for i := 0; i &lt; col.Len(); i++ </span><span class="cov0" title="0">{
                        if col.IsNull(i) </span><span class="cov0" title="0">{
                                builder.AppendNull()
                        }</span> else<span class="cov0" title="0"> {
                                builder.Append(col.Value(i))
                        }</span>
                }
        case *array.Int16Builder:<span class="cov0" title="0">
                col := arr.(*array.Int16)
                for i := 0; i &lt; col.Len(); i++ </span><span class="cov0" title="0">{
                        if col.IsNull(i) </span><span class="cov0" title="0">{
                                builder.AppendNull()
                        }</span> else<span class="cov0" title="0"> {
                                builder.Append(col.Value(i))
                        }</span>
                }
        case *array.Int32Builder:<span class="cov0" title="0">
                col := arr.(*array.Int32)
                for i := 0; i &lt; col.Len(); i++ </span><span class="cov0" title="0">{
                        if col.IsNull(i) </span><span class="cov0" title="0">{
                                builder.AppendNull()
                        }</span> else<span class="cov0" title="0"> {
                                builder.Append(col.Value(i))
                        }</span>
                }
        case *array.Int64Builder:<span class="cov7" title="6">
                col := arr.(*array.Int64)
                for i := 0; i &lt; col.Len(); i++ </span><span class="cov7" title="6">{
                        if col.IsNull(i) </span><span class="cov0" title="0">{
                                builder.AppendNull()
                        }</span> else<span class="cov7" title="6"> {
                                builder.Append(col.Value(i))
                        }</span>
                }
        case *array.Uint8Builder:<span class="cov0" title="0">
                col := arr.(*array.Uint8)
                for i := 0; i &lt; col.Len(); i++ </span><span class="cov0" title="0">{
                        if col.IsNull(i) </span><span class="cov0" title="0">{
                                builder.AppendNull()
                        }</span> else<span class="cov0" title="0"> {
                                builder.Append(col.Value(i))
                        }</span>
                }
        case *array.Uint16Builder:<span class="cov0" title="0">
                col := arr.(*array.Uint16)
                for i := 0; i &lt; col.Len(); i++ </span><span class="cov0" title="0">{
                        if col.IsNull(i) </span><span class="cov0" title="0">{
                                builder.AppendNull()
                        }</span> else<span class="cov0" title="0"> {
                                builder.Append(col.Value(i))
                        }</span>
                }
        case *array.Uint32Builder:<span class="cov0" title="0">
                col := arr.(*array.Uint32)
                for i := 0; i &lt; col.Len(); i++ </span><span class="cov0" title="0">{
                        if col.IsNull(i) </span><span class="cov0" title="0">{
                                builder.AppendNull()
                        }</span> else<span class="cov0" title="0"> {
                                builder.Append(col.Value(i))
                        }</span>
                }
        case *array.Uint64Builder:<span class="cov0" title="0">
                col := arr.(*array.Uint64)
                for i := 0; i &lt; col.Len(); i++ </span><span class="cov0" title="0">{
                        if col.IsNull(i) </span><span class="cov0" title="0">{
                                builder.AppendNull()
                        }</span> else<span class="cov0" title="0"> {
                                builder.Append(col.Value(i))
                        }</span>
                }
        case *array.Float32Builder:<span class="cov0" title="0">
                col := arr.(*array.Float32)
                for i := 0; i &lt; col.Len(); i++ </span><span class="cov0" title="0">{
                        if col.IsNull(i) </span><span class="cov0" title="0">{
                                builder.AppendNull()
                        }</span> else<span class="cov0" title="0"> {
                                builder.Append(col.Value(i))
                        }</span>
                }
        case *array.Float64Builder:<span class="cov0" title="0">
                col := arr.(*array.Float64)
                for i := 0; i &lt; col.Len(); i++ </span><span class="cov0" title="0">{
                        if col.IsNull(i) </span><span class="cov0" title="0">{
                                builder.AppendNull()
                        }</span> else<span class="cov0" title="0"> {
                                builder.Append(col.Value(i))
                        }</span>
                }
        case *array.StringBuilder:<span class="cov0" title="0">
                col := arr.(*array.String)
                for i := 0; i &lt; col.Len(); i++ </span><span class="cov0" title="0">{
                        if col.IsNull(i) </span><span class="cov0" title="0">{
                                builder.AppendNull()
                        }</span> else<span class="cov0" title="0"> {
                                builder.Append(col.Value(i))
                        }</span>
                }
        case *array.LargeStringBuilder:<span class="cov0" title="0">
                col := arr.(*array.LargeString)
                for i := 0; i &lt; col.Len(); i++ </span><span class="cov0" title="0">{
                        if col.IsNull(i) </span><span class="cov0" title="0">{
                                builder.AppendNull()
                        }</span> else<span class="cov0" title="0"> {
                                builder.Append(col.Value(i))
                        }</span>
                }
        case *array.BinaryBuilder:<span class="cov0" title="0">
                switch col := arr.(type) </span>{
                case *array.Binary:<span class="cov0" title="0">
                        for i := 0; i &lt; col.Len(); i++ </span><span class="cov0" title="0">{
                                if col.IsNull(i) </span><span class="cov0" title="0">{
                                        builder.AppendNull()
                                }</span> else<span class="cov0" title="0"> {
                                        builder.Append(col.Value(i))
                                }</span>
                        }
                case *array.LargeBinary:<span class="cov0" title="0">
                        for i := 0; i &lt; col.Len(); i++ </span><span class="cov0" title="0">{
                                if col.IsNull(i) </span><span class="cov0" title="0">{
                                        builder.AppendNull()
                                }</span> else<span class="cov0" title="0"> {
                                        builder.Append(col.Value(i))
                                }</span>
                        }
                }
        default:<span class="cov0" title="0">
                // Unsupported type - append nulls to maintain row count
                for i := 0; i &lt; arr.Len(); i++ </span><span class="cov0" title="0">{
                        b.AppendNull()
                }</span>
        }
}

func (s *FlightSQLServer) GetFlightInfoPreparedStatement(
        ctx context.Context,
        cmd flightsql.PreparedStatementQuery,
        desc *flight.FlightDescriptor,
) (*flight.FlightInfo, error) <span class="cov0" title="0">{
        schema, err := s.preparedStatementHandler.GetSchema(ctx, string(cmd.GetPreparedStatementHandle()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "get ps schema: %v", err)
        }</span>
        <span class="cov0" title="0">return s.infoStatic(desc, schema), nil</span>
}

func (s *FlightSQLServer) DoGetPreparedStatement(
        ctx context.Context,
        cmd flightsql.PreparedStatementQuery,
) (*arrow.Schema, &lt;-chan flight.StreamChunk, error) <span class="cov0" title="0">{
        return s.preparedStatementHandler.ExecuteQuery(ctx, string(cmd.GetPreparedStatementHandle()), nil)
}</span>

func (s *FlightSQLServer) DoPutPreparedStatementQuery(
        ctx context.Context,
        cmd flightsql.PreparedStatementQuery,
        reader flight.MessageReader,
        writer flight.MetadataWriter,
) ([]byte, error) <span class="cov6" title="4">{
        var (
                builder *array.RecordBuilder
                params  arrow.Record
                schema  *arrow.Schema
        )

        for </span><span class="cov8" title="9">{
                rec, err := reader.Read()
                if err != nil </span><span class="cov4" title="3">{
                        if err == io.EOF </span><span class="cov4" title="3">{
                                break</span>
                        }
                        <span class="cov0" title="0">if builder != nil </span><span class="cov0" title="0">{
                                builder.Release()
                        }</span>
                        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{
                                params.Release()
                        }</span>
                        <span class="cov0" title="0">return nil, status.Errorf(codes.Internal, "read params: %v", err)</span>
                }
                <span class="cov7" title="6">if rec == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov7" title="6">if builder == nil </span><span class="cov6" title="4">{
                        schema = rec.Schema()
                        builder = array.NewRecordBuilder(s.allocator, schema)
                }</span>
                <span class="cov7" title="6">if !rec.Schema().Equal(schema) </span><span class="cov1" title="1">{
                        rec.Release()
                        builder.Release()
                        if params != nil </span><span class="cov0" title="0">{
                                params.Release()
                        }</span>
                        <span class="cov1" title="1">return nil, status.Errorf(codes.InvalidArgument, "parameter batch schema mismatch")</span>
                }
                <span class="cov6" title="5">for i := range rec.Columns() </span><span class="cov6" title="4">{
                        appendColumnToBuilder(builder.Field(i), rec.Column(i))
                }</span>
                <span class="cov6" title="5">rec.Release()</span>
        }

        <span class="cov4" title="3">if builder != nil </span><span class="cov4" title="3">{
                params = builder.NewRecord()
                builder.Release()
        }</span>

        <span class="cov4" title="3">if params != nil </span><span class="cov4" title="3">{
                defer params.Release()
        }</span>

        <span class="cov4" title="3">if err := s.preparedStatementHandler.SetParameters(ctx, string(cmd.GetPreparedStatementHandle()), params); err != nil </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.Internal, "set ps params: %v", err)
        }</span>
        <span class="cov3" title="2">return []byte(cmd.GetPreparedStatementHandle()), nil</span>
}

func (s *FlightSQLServer) DoPutPreparedStatementUpdate(
        ctx context.Context,
        cmd flightsql.PreparedStatementUpdate,
        reader flight.MessageReader,
) (int64, error) <span class="cov6" title="4">{
        var (
                builder *array.RecordBuilder
                params  arrow.Record
                schema  *arrow.Schema
        )

        for </span><span class="cov8" title="8">{
                rec, err := reader.Read()
                if err != nil </span><span class="cov4" title="3">{
                        if err == io.EOF </span><span class="cov4" title="3">{
                                break</span>
                        }
                        <span class="cov0" title="0">if builder != nil </span><span class="cov0" title="0">{
                                builder.Release()
                        }</span>
                        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{
                                params.Release()
                        }</span>
                        <span class="cov0" title="0">return 0, status.Errorf(codes.Internal, "read params: %v", err)</span>
                }
                <span class="cov6" title="5">if rec == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="5">if builder == nil </span><span class="cov6" title="4">{
                        schema = rec.Schema()
                        builder = array.NewRecordBuilder(s.allocator, schema)
                }</span>
                <span class="cov6" title="5">if !rec.Schema().Equal(schema) </span><span class="cov1" title="1">{
                        rec.Release()
                        builder.Release()
                        if params != nil </span><span class="cov0" title="0">{
                                params.Release()
                        }</span>
                        <span class="cov1" title="1">return 0, status.Errorf(codes.InvalidArgument, "parameter batch schema mismatch")</span>
                }
                <span class="cov6" title="4">for i := range rec.Columns() </span><span class="cov3" title="2">{
                        appendColumnToBuilder(builder.Field(i), rec.Column(i))
                }</span>
                <span class="cov6" title="4">rec.Release()</span>
        }

        <span class="cov4" title="3">if builder != nil </span><span class="cov4" title="3">{
                params = builder.NewRecord()
                builder.Release()
        }</span>

        <span class="cov4" title="3">if params != nil </span><span class="cov4" title="3">{
                defer params.Release()
        }</span>

        <span class="cov4" title="3">affected, err := s.preparedStatementHandler.ExecuteUpdate(ctx, string(cmd.GetPreparedStatementHandle()), params)
        if err != nil </span><span class="cov1" title="1">{
                return 0, status.Errorf(codes.Internal, "execute ps update: %v", err)
        }</span>
        <span class="cov3" title="2">return affected, nil</span>
}

// DoExchange handles bidirectional Flight SQL streams.
// Currently unsupported, so return Unimplemented until implemented.
func (s *FlightSQLServer) DoExchange(stream flight.FlightService_DoExchangeServer) error <span class="cov0" title="0">{
        return status.Error(codes.Unimplemented, "DoExchange not implemented")
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">// Package services contains business logic implementations.
package services

import (
        "context"

        "github.com/TFMV/porter/pkg/errors"
        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/repositories"
        "github.com/apache/arrow-go/v18/arrow"
)

// metadataService implements MetadataService interface.
type metadataService struct {
        repo    repositories.MetadataRepository
        logger  Logger
        metrics MetricsCollector
}

// NewMetadataService creates a new metadata service.
func NewMetadataService(
        repo repositories.MetadataRepository,
        logger Logger,
        metrics MetricsCollector,
) MetadataService <span class="cov9" title="11">{
        return &amp;metadataService{
                repo:    repo,
                logger:  logger,
                metrics: metrics,
        }
}</span>

// GetCatalogs returns all available catalogs.
func (s *metadataService) GetCatalogs(ctx context.Context) ([]models.Catalog, error) <span class="cov3" title="2">{
        timer := s.metrics.StartTimer("metadata_get_catalogs")
        defer timer.Stop()

        s.logger.Debug("Getting catalogs")

        catalogs, err := s.repo.GetCatalogs(ctx)
        if err != nil </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("metadata_errors", "operation", "get_catalogs")
                s.logger.Error("Failed to get catalogs", "error", err)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to get catalogs")
        }</span>

        <span class="cov1" title="1">s.metrics.RecordGauge("catalog_count", float64(len(catalogs)))
        s.logger.Info("Retrieved catalogs", "count", len(catalogs))

        return catalogs, nil</span>
}

// GetSchemas returns schemas matching the filter.
func (s *metadataService) GetSchemas(ctx context.Context, catalog string, pattern string) ([]models.Schema, error) <span class="cov3" title="2">{
        timer := s.metrics.StartTimer("metadata_get_schemas")
        defer timer.Stop()

        s.logger.Debug("Getting schemas", "catalog", catalog, "pattern", pattern)

        schemas, err := s.repo.GetSchemas(ctx, catalog, pattern)
        if err != nil </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("metadata_errors", "operation", "get_schemas")
                s.logger.Error("Failed to get schemas", "error", err, "catalog", catalog, "pattern", pattern)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to get schemas")
        }</span>

        <span class="cov1" title="1">s.metrics.RecordGauge("schema_count", float64(len(schemas)))
        s.logger.Info("Retrieved schemas", "count", len(schemas), "catalog", catalog)

        return schemas, nil</span>
}

// GetTables returns tables matching the options.
func (s *metadataService) GetTables(ctx context.Context, opts models.GetTablesOptions) ([]models.Table, error) <span class="cov3" title="2">{
        timer := s.metrics.StartTimer("metadata_get_tables")
        defer timer.Stop()

        s.logger.Debug("Getting tables",
                "catalog", opts.Catalog,
                "schema_pattern", opts.SchemaFilterPattern,
                "table_pattern", opts.TableNameFilterPattern,
                "table_types", opts.TableTypes,
                "include_schema", opts.IncludeSchema)

        // Validate options
        if err := s.validateGetTablesOptions(opts); err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("metadata_validation_errors", "operation", "get_tables")
                return nil, err
        }</span>

        <span class="cov3" title="2">tables, err := s.repo.GetTables(ctx, opts)
        if err != nil </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("metadata_errors", "operation", "get_tables")
                s.logger.Error("Failed to get tables", "error", err, "options", opts)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to get tables")
        }</span>

        <span class="cov1" title="1">s.metrics.RecordGauge("table_count", float64(len(tables)))
        s.logger.Info("Retrieved tables", "count", len(tables))

        return tables, nil</span>
}

// GetTableTypes returns all available table types.
func (s *metadataService) GetTableTypes(ctx context.Context) ([]string, error) <span class="cov3" title="2">{
        timer := s.metrics.StartTimer("metadata_get_table_types")
        defer timer.Stop()

        s.logger.Debug("Getting table types")

        types, err := s.repo.GetTableTypes(ctx)
        if err != nil </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("metadata_errors", "operation", "get_table_types")
                s.logger.Error("Failed to get table types", "error", err)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to get table types")
        }</span>

        <span class="cov1" title="1">s.logger.Info("Retrieved table types", "count", len(types), "types", types)

        return types, nil</span>
}

// GetColumns returns columns for a specific table.
func (s *metadataService) GetColumns(ctx context.Context, table models.TableRef) ([]models.Column, error) <span class="cov3" title="2">{
        timer := s.metrics.StartTimer("metadata_get_columns")
        defer timer.Stop()

        s.logger.Debug("Getting columns",
                "catalog", table.Catalog,
                "schema", table.DBSchema,
                "table", table.Table)

        // Validate table reference
        if err := s.validateTableRef(table); err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("metadata_validation_errors", "operation", "get_columns")
                return nil, err
        }</span>

        <span class="cov3" title="2">columns, err := s.repo.GetColumns(ctx, table)
        if err != nil </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("metadata_errors", "operation", "get_columns")
                s.logger.Error("Failed to get columns", "error", err, "table", table)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to get columns")
        }</span>

        <span class="cov1" title="1">s.metrics.RecordGauge("column_count", float64(len(columns)))
        s.logger.Info("Retrieved columns", "count", len(columns), "table", table.Table)

        return columns, nil</span>
}

// GetTableSchema returns the Arrow schema for a table.
func (s *metadataService) GetTableSchema(ctx context.Context, table models.TableRef) (*arrow.Schema, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("metadata_get_table_schema")
        defer timer.Stop()

        s.logger.Debug("Getting table schema",
                "catalog", table.Catalog,
                "schema", table.DBSchema,
                "table", table.Table)

        if err := s.validateTableRef(table); err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("metadata_validation_errors", "operation", "get_table_schema")
                return nil, err
        }</span>

        <span class="cov0" title="0">schema, err := s.repo.GetTableSchema(ctx, table)
        if err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("metadata_errors", "operation", "get_table_schema")
                s.logger.Error("Failed to get table schema", "error", err, "table", table)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to get table schema")
        }</span>

        <span class="cov0" title="0">s.logger.Info("Retrieved table schema", "table", table.Table)
        return schema, nil</span>
}

// GetPrimaryKeys returns primary keys for a table.
func (s *metadataService) GetPrimaryKeys(ctx context.Context, table models.TableRef) ([]models.Key, error) <span class="cov3" title="2">{
        timer := s.metrics.StartTimer("metadata_get_primary_keys")
        defer timer.Stop()

        s.logger.Debug("Getting primary keys",
                "catalog", table.Catalog,
                "schema", table.DBSchema,
                "table", table.Table)

        // Validate table reference
        if err := s.validateTableRef(table); err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("metadata_validation_errors", "operation", "get_primary_keys")
                return nil, err
        }</span>

        <span class="cov3" title="2">keys, err := s.repo.GetPrimaryKeys(ctx, table)
        if err != nil </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("metadata_errors", "operation", "get_primary_keys")
                s.logger.Error("Failed to get primary keys", "error", err, "table", table)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to get primary keys")
        }</span>

        <span class="cov1" title="1">s.logger.Info("Retrieved primary keys", "count", len(keys), "table", table.Table)

        return keys, nil</span>
}

// GetImportedKeys returns foreign keys that reference a table.
func (s *metadataService) GetImportedKeys(ctx context.Context, table models.TableRef) ([]models.ForeignKey, error) <span class="cov3" title="2">{
        timer := s.metrics.StartTimer("metadata_get_imported_keys")
        defer timer.Stop()

        s.logger.Debug("Getting imported keys",
                "catalog", table.Catalog,
                "schema", table.DBSchema,
                "table", table.Table)

        // Validate table reference
        if err := s.validateTableRef(table); err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("metadata_validation_errors", "operation", "get_imported_keys")
                return nil, err
        }</span>

        <span class="cov3" title="2">keys, err := s.repo.GetImportedKeys(ctx, table)
        if err != nil </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("metadata_errors", "operation", "get_imported_keys")
                s.logger.Error("Failed to get imported keys", "error", err, "table", table)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to get imported keys")
        }</span>

        <span class="cov1" title="1">s.logger.Info("Retrieved imported keys", "count", len(keys), "table", table.Table)

        return keys, nil</span>
}

// GetExportedKeys returns foreign keys from a table.
func (s *metadataService) GetExportedKeys(ctx context.Context, table models.TableRef) ([]models.ForeignKey, error) <span class="cov3" title="2">{
        timer := s.metrics.StartTimer("metadata_get_exported_keys")
        defer timer.Stop()

        s.logger.Debug("Getting exported keys",
                "catalog", table.Catalog,
                "schema", table.DBSchema,
                "table", table.Table)

        // Validate table reference
        if err := s.validateTableRef(table); err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("metadata_validation_errors", "operation", "get_exported_keys")
                return nil, err
        }</span>

        <span class="cov3" title="2">keys, err := s.repo.GetExportedKeys(ctx, table)
        if err != nil </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("metadata_errors", "operation", "get_exported_keys")
                s.logger.Error("Failed to get exported keys", "error", err, "table", table)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to get exported keys")
        }</span>

        <span class="cov1" title="1">s.logger.Info("Retrieved exported keys", "count", len(keys), "table", table.Table)

        return keys, nil</span>
}

// GetCrossReference returns foreign key relationships between two tables.
func (s *metadataService) GetCrossReference(ctx context.Context, ref models.CrossTableRef) ([]models.ForeignKey, error) <span class="cov3" title="2">{
        timer := s.metrics.StartTimer("metadata_get_cross_reference")
        defer timer.Stop()

        s.logger.Debug("Getting cross reference",
                "pk_table", ref.PKRef.Table,
                "fk_table", ref.FKRef.Table)

        // Validate references
        if err := s.validateTableRef(ref.PKRef); err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("metadata_validation_errors", "operation", "get_cross_reference")
                return nil, errors.Wrap(err, errors.CodeInvalidRequest, "invalid primary key table reference")
        }</span>

        <span class="cov3" title="2">if err := s.validateTableRef(ref.FKRef); err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("metadata_validation_errors", "operation", "get_cross_reference")
                return nil, errors.Wrap(err, errors.CodeInvalidRequest, "invalid foreign key table reference")
        }</span>

        <span class="cov3" title="2">keys, err := s.repo.GetCrossReference(ctx, ref)
        if err != nil </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("metadata_errors", "operation", "get_cross_reference")
                s.logger.Error("Failed to get cross reference", "error", err, "ref", ref)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to get cross reference")
        }</span>

        <span class="cov1" title="1">s.logger.Info("Retrieved cross reference", "count", len(keys))

        return keys, nil</span>
}

// GetTypeInfo returns database type information.
func (s *metadataService) GetTypeInfo(ctx context.Context, dataType *int32) ([]models.XdbcTypeInfo, error) <span class="cov3" title="2">{
        timer := s.metrics.StartTimer("metadata_get_type_info")
        defer timer.Stop()

        if dataType != nil </span><span class="cov3" title="2">{
                s.logger.Debug("Getting type info", "data_type", *dataType)
        }</span> else<span class="cov0" title="0"> {
                s.logger.Debug("Getting all type info")
        }</span>

        <span class="cov3" title="2">types, err := s.repo.GetTypeInfo(ctx, dataType)
        if err != nil </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("metadata_errors", "operation", "get_type_info")
                s.logger.Error("Failed to get type info", "error", err)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to get type info")
        }</span>

        <span class="cov1" title="1">s.logger.Info("Retrieved type info", "count", len(types))

        return types, nil</span>
}

// GetSQLInfo returns SQL feature information.
func (s *metadataService) GetSQLInfo(ctx context.Context, infoTypes []uint32) ([]models.SQLInfo, error) <span class="cov3" title="2">{
        timer := s.metrics.StartTimer("metadata_get_sql_info")
        defer timer.Stop()

        if len(infoTypes) &gt; 0 </span><span class="cov3" title="2">{
                s.logger.Debug("Getting SQL info", "info_types", infoTypes)
        }</span> else<span class="cov0" title="0"> {
                s.logger.Debug("Getting all SQL info")
        }</span>

        <span class="cov3" title="2">info, err := s.repo.GetSQLInfo(ctx, infoTypes)
        if err != nil </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("metadata_errors", "operation", "get_sql_info")
                s.logger.Error("Failed to get SQL info", "error", err)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to get SQL info")
        }</span>

        <span class="cov1" title="1">s.logger.Info("Retrieved SQL info", "count", len(info))

        return info, nil</span>
}

// validateGetTablesOptions validates GetTables options.
func (s *metadataService) validateGetTablesOptions(opts models.GetTablesOptions) error <span class="cov3" title="2">{
        // Patterns can be empty (meaning no filter)
        // Table types can be empty (meaning all types)
        // No specific validation needed for now
        return nil
}</span>

// validateTableRef validates a table reference.
func (s *metadataService) validateTableRef(ref models.TableRef) error <span class="cov10" title="12">{
        // Table name is required
        if ref.Table == "" </span><span class="cov0" title="0">{
                return errors.New(errors.CodeInvalidRequest, "table name is required")
        }</span>

        // Catalog and schema can be empty (will use defaults)
        <span class="cov10" title="12">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Package services contains business logic implementations.
package services

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/google/uuid"

        "github.com/TFMV/porter/pkg/errors"
        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/repositories"
        "github.com/apache/arrow-go/v18/arrow"
)

// preparedStatementService implements PreparedStatementService interface.
type preparedStatementService struct {
        repo       repositories.PreparedStatementRepository
        txnService TransactionService
        logger     Logger
        metrics    MetricsCollector
}

// NewPreparedStatementService creates a new prepared statement service.
func NewPreparedStatementService(
        repo repositories.PreparedStatementRepository,
        txnService TransactionService,
        logger Logger,
        metrics MetricsCollector,
) PreparedStatementService <span class="cov0" title="0">{
        return &amp;preparedStatementService{
                repo:       repo,
                txnService: txnService,
                logger:     logger,
                metrics:    metrics,
        }
}</span>

// Create creates a new prepared statement.
func (s *preparedStatementService) Create(ctx context.Context, query string, transactionID string) (*models.PreparedStatement, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("prepared_statement_create")
        defer timer.Stop()

        s.logger.Debug("Creating prepared statement", "query", query, "transaction_id", transactionID)

        // Validate query
        if query == "" </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("prepared_statement_validation_errors")
                return nil, errors.New(errors.CodeInvalidRequest, "query cannot be empty")
        }</span>

        // Validate transaction if specified
        <span class="cov0" title="0">var txn repositories.Transaction
        if transactionID != "" </span><span class="cov0" title="0">{
                var err error
                txn, err = s.txnService.Get(ctx, transactionID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to get transaction", "error", err, "transaction_id", transactionID)
                        s.metrics.IncrementCounter("transaction_lookup_errors")
                        return nil, errors.Wrap(err, errors.CodeTransactionFailed, "failed to get transaction")
                }</span>

                // Check if transaction is still active
                <span class="cov0" title="0">if !txn.IsActive() </span><span class="cov0" title="0">{
                        s.metrics.IncrementCounter("inactive_transaction_errors")
                        return nil, errors.New(errors.CodeTransactionFailed, "transaction is no longer active")
                }</span>
        }

        // Generate handle
        <span class="cov0" title="0">handle := uuid.New().String()

        // Create parameter schema based on the query
        var paramSchema *arrow.Schema
        if strings.Contains(query, "?") </span><span class="cov0" title="0">{
                // Count the number of parameters
                paramCount := strings.Count(query, "?")
                fields := make([]arrow.Field, paramCount)

                // Try to infer parameter types from the query
                // This is a simple implementation - in a real system, you'd want to use a proper SQL parser
                queryUpper := strings.ToUpper(query)
                if strings.Contains(queryUpper, "INSERT INTO") </span><span class="cov0" title="0">{
                        // For INSERT queries, try to infer types from the column list
                        startIdx := strings.Index(queryUpper, "(")
                        endIdx := strings.Index(queryUpper, ")")
                        if startIdx &gt; 0 &amp;&amp; endIdx &gt; startIdx </span><span class="cov0" title="0">{
                                columns := strings.Split(query[startIdx+1:endIdx], ",")
                                for i := 0; i &lt; paramCount &amp;&amp; i &lt; len(columns); i++ </span><span class="cov0" title="0">{
                                        colName := strings.TrimSpace(columns[i])
                                        fields[i] = arrow.Field{
                                                Name:     fmt.Sprintf("param%d", i+1),
                                                Type:     inferTypeFromColumnName(colName),
                                                Nullable: true,
                                        }
                                }</span>
                        }
                }

                // For any remaining fields or if we couldn't infer types, use default types
                <span class="cov0" title="0">for i := 0; i &lt; paramCount; i++ </span><span class="cov0" title="0">{
                        if fields[i].Type == nil </span><span class="cov0" title="0">{
                                fields[i] = arrow.Field{
                                        Name:     fmt.Sprintf("param%d", i+1),
                                        Type:     arrow.PrimitiveTypes.Int64,
                                        Nullable: true,
                                }
                        }</span>
                }
                <span class="cov0" title="0">paramSchema = arrow.NewSchema(fields, nil)</span>
        }

        // Create prepared statement
        <span class="cov0" title="0">stmt := &amp;models.PreparedStatement{
                Handle:            handle,
                Query:             query,
                ParameterSchema:   paramSchema,
                ResultSetSchema:   arrow.NewSchema([]arrow.Field{}, nil),                                   // Initialize with empty schema
                IsResultSetUpdate: !strings.HasPrefix(strings.ToUpper(strings.TrimSpace(query)), "SELECT"), // Basic check for update type
                CreatedAt:         time.Now(),
                LastUsedAt:        time.Now(),
                TransactionID:     transactionID,
        }

        // Store in repository
        if err := s.repo.Store(ctx, stmt); err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("prepared_statement_create_errors")
                s.logger.Error("Failed to store prepared statement", "error", err, "handle", handle)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to create prepared statement")
        }</span>

        // Update metrics
        <span class="cov0" title="0">s.metrics.IncrementCounter("prepared_statements_created")
        s.metrics.RecordGauge("active_prepared_statements", s.getActiveStatementCount(ctx))

        s.logger.Info("Prepared statement created",
                "handle", handle,
                "query", query,
                "has_parameters", paramSchema != nil)

        return stmt, nil</span>
}

// inferTypeFromColumnName tries to infer the Arrow type from a column name
func inferTypeFromColumnName(colName string) arrow.DataType <span class="cov0" title="0">{
        colName = strings.ToUpper(colName)
        switch </span>{
        case strings.Contains(colName, "ID") || strings.Contains(colName, "COUNT"):<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Int64</span>
        case strings.Contains(colName, "NAME") || strings.Contains(colName, "STRING") || strings.Contains(colName, "TEXT"):<span class="cov0" title="0">
                return arrow.BinaryTypes.String</span>
        case strings.Contains(colName, "FLOAT") || strings.Contains(colName, "DOUBLE") || strings.Contains(colName, "DECIMAL"):<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Float64</span>
        default:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Int64</span> // Default to Int64
        }
}

// Get retrieves a prepared statement by handle.
func (s *preparedStatementService) Get(ctx context.Context, handle string) (*models.PreparedStatement, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("prepared_statement_get")
        defer timer.Stop()

        s.logger.Debug("Getting prepared statement", "handle", handle)

        // Validate handle
        if handle == "" </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("prepared_statement_validation_errors")
                return nil, errors.New(errors.CodeInvalidRequest, "handle cannot be empty")
        }</span>

        // Get from repository
        <span class="cov0" title="0">stmt, err := s.repo.Get(ctx, handle)
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        s.metrics.IncrementCounter("prepared_statement_not_found")
                        return nil, errors.ErrStatementNotFound.WithDetail("handle", handle)
                }</span>
                <span class="cov0" title="0">s.metrics.IncrementCounter("prepared_statement_get_errors")
                s.logger.Error("Failed to get prepared statement", "error", err, "handle", handle)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to get prepared statement")</span>
        }

        // Update last used time (best effort)
        <span class="cov0" title="0">stmt.LastUsedAt = time.Now()

        return stmt, nil</span>
}

// Close closes a prepared statement.
func (s *preparedStatementService) Close(ctx context.Context, handle string) error <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("prepared_statement_close")
        defer timer.Stop()

        s.logger.Debug("Closing prepared statement", "handle", handle)

        // Validate handle
        if handle == "" </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("prepared_statement_validation_errors")
                return errors.New(errors.CodeInvalidRequest, "handle cannot be empty")
        }</span>

        // Remove from repository
        <span class="cov0" title="0">if err := s.repo.Remove(ctx, handle); err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        s.metrics.IncrementCounter("prepared_statement_not_found")
                        return errors.ErrStatementNotFound.WithDetail("handle", handle)
                }</span>
                <span class="cov0" title="0">s.metrics.IncrementCounter("prepared_statement_close_errors")
                s.logger.Error("Failed to close prepared statement", "error", err, "handle", handle)
                return errors.Wrap(err, errors.CodeInternal, "failed to close prepared statement")</span>
        }

        // Update metrics
        <span class="cov0" title="0">s.metrics.IncrementCounter("prepared_statements_closed")
        s.metrics.RecordGauge("active_prepared_statements", s.getActiveStatementCount(ctx))

        s.logger.Info("Prepared statement closed", "handle", handle)

        return nil</span>
}

// ExecuteQuery executes a prepared query statement.
func (s *preparedStatementService) ExecuteQuery(ctx context.Context, handle string, params [][]interface{}) (*models.QueryResult, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("prepared_statement_execute_query")
        defer timer.Stop()

        s.logger.Debug("Executing prepared query", "handle", handle, "param_batches", len(params))

        // Get prepared statement
        stmt, err := s.Get(ctx, handle)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if it's a query (not an update)
        <span class="cov0" title="0">if stmt.IsResultSetUpdate </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("prepared_statement_type_mismatch")
                return nil, errors.New(errors.CodeInvalidRequest, "statement is an update, not a query")
        }</span>

        // Validate transaction if specified
        <span class="cov0" title="0">if stmt.TransactionID != "" </span><span class="cov0" title="0">{
                txn, err := s.txnService.Get(ctx, stmt.TransactionID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to get transaction", "error", err, "transaction_id", stmt.TransactionID)
                        s.metrics.IncrementCounter("transaction_lookup_errors")
                        return nil, errors.Wrap(err, errors.CodeTransactionFailed, "failed to get transaction")
                }</span>

                // Check if transaction is still active
                <span class="cov0" title="0">if !txn.IsActive() </span><span class="cov0" title="0">{
                        s.metrics.IncrementCounter("inactive_transaction_errors")
                        return nil, errors.New(errors.CodeTransactionFailed, "transaction is no longer active")
                }</span>
        }

        // Execute query
        <span class="cov0" title="0">start := time.Now()
        result, err := s.repo.ExecuteQuery(ctx, handle, params)
        executionTime := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("prepared_statement_execute_errors")
                s.logger.Error("Failed to execute prepared query",
                        "error", err,
                        "handle", handle,
                        "execution_time", executionTime)
                return nil, errors.Wrap(err, errors.CodeQueryFailed, "failed to execute prepared query")
        }</span>

        // Update result with execution time
        <span class="cov0" title="0">result.ExecutionTime = executionTime

        // Update statement execution count
        stmt.ExecutionCount++
        stmt.LastUsedAt = time.Now()

        // Record metrics
        s.metrics.IncrementCounter("prepared_queries_executed")
        s.metrics.RecordHistogram("prepared_query_execution_time", executionTime.Seconds())
        if result.TotalRows &gt;= 0 </span><span class="cov0" title="0">{
                s.metrics.RecordHistogram("prepared_query_result_rows", float64(result.TotalRows))
        }</span>

        <span class="cov0" title="0">s.logger.Info("Prepared query executed successfully",
                "handle", handle,
                "rows", result.TotalRows,
                "execution_time", executionTime)

        return result, nil</span>
}

// ExecuteUpdate executes a prepared update statement.
func (s *preparedStatementService) ExecuteUpdate(ctx context.Context, handle string, params [][]interface{}) (*models.UpdateResult, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("prepared_statement_execute_update")
        defer timer.Stop()

        s.logger.Debug("Executing prepared update", "handle", handle, "param_batches", len(params))

        // Get prepared statement
        stmt, err := s.Get(ctx, handle)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if it's an update (not a query)
        <span class="cov0" title="0">if !stmt.IsResultSetUpdate </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("prepared_statement_type_mismatch")
                return nil, errors.New(errors.CodeInvalidRequest, "statement is a query, not an update")
        }</span>

        // Validate transaction if specified
        <span class="cov0" title="0">if stmt.TransactionID != "" </span><span class="cov0" title="0">{
                txn, err := s.txnService.Get(ctx, stmt.TransactionID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to get transaction", "error", err, "transaction_id", stmt.TransactionID)
                        s.metrics.IncrementCounter("transaction_lookup_errors")
                        return nil, errors.Wrap(err, errors.CodeTransactionFailed, "failed to get transaction")
                }</span>

                // Check if transaction is still active
                <span class="cov0" title="0">if !txn.IsActive() </span><span class="cov0" title="0">{
                        s.metrics.IncrementCounter("inactive_transaction_errors")
                        return nil, errors.New(errors.CodeTransactionFailed, "transaction is no longer active")
                }</span>
        }

        // Execute update
        <span class="cov0" title="0">start := time.Now()
        result, err := s.repo.ExecuteUpdate(ctx, handle, params)
        executionTime := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("prepared_statement_execute_errors")
                s.logger.Error("Failed to execute prepared update",
                        "error", err,
                        "handle", handle,
                        "execution_time", executionTime)
                return nil, errors.Wrap(err, errors.CodeQueryFailed, "failed to execute prepared update")
        }</span>

        // Update result with execution time
        <span class="cov0" title="0">result.ExecutionTime = executionTime

        // Update statement execution count
        stmt.ExecutionCount++
        stmt.LastUsedAt = time.Now()

        // Record metrics
        s.metrics.IncrementCounter("prepared_updates_executed")
        s.metrics.RecordHistogram("prepared_update_execution_time", executionTime.Seconds())
        s.metrics.RecordHistogram("prepared_update_affected_rows", float64(result.RowsAffected))

        s.logger.Info("Prepared update executed successfully",
                "handle", handle,
                "rows_affected", result.RowsAffected,
                "execution_time", executionTime)

        return result, nil</span>
}

// SetParameters sets parameters for a prepared statement.
func (s *preparedStatementService) SetParameters(ctx context.Context, handle string, params [][]interface{}) error <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("prepared_statement_set_parameters")
        defer timer.Stop()

        s.logger.Debug("Setting parameters for prepared statement", "handle", handle, "param_batches", len(params))

        // Get prepared statement
        stmt, err := s.Get(ctx, handle)
        if err != nil </span><span class="cov0" title="0">{
                return err // Get already logs and increments metrics
        }</span>

        <span class="cov0" title="0">if stmt.ParameterSchema != nil &amp;&amp; len(params) &gt; 0 </span><span class="cov0" title="0">{
                expected := len(stmt.ParameterSchema.Fields())
                if len(params[0]) != expected </span><span class="cov0" title="0">{
                        return errors.New(errors.CodeInvalidRequest, fmt.Sprintf("parameter count mismatch: expected %d got %d", expected, len(params[0])))
                }</span>
        }

        // Store parameters in the statement model (or call repository to update if needed)
        // This depends on how the repository and model are designed to handle parameter binding.
        // For this example, let's assume the PreparedStatement model can hold the bound parameters.
        // If params are to be stored persistently or in a way the repo manages, this would call s.repo.SetParameters(ctx, handle, params)
        <span class="cov0" title="0">stmt.BoundParameters = params // This field needs to be added to models.PreparedStatement
        stmt.LastUsedAt = time.Now()

        // If the repository needs to be updated with the new BoundParameters or LastUsedAt:
        if err := s.repo.Store(ctx, stmt); err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("prepared_statement_set_parameters_errors")
                s.logger.Error("Failed to update prepared statement with new parameters", "error", err, "handle", handle)
                return errors.Wrap(err, errors.CodeInternal, "failed to set parameters")
        }</span>

        <span class="cov0" title="0">s.logger.Info("Parameters set for prepared statement", "handle", handle)
        s.metrics.IncrementCounter("prepared_statement_parameters_set")
        return nil</span>
}

// List returns all prepared statements for a transaction.
func (s *preparedStatementService) List(ctx context.Context, transactionID string) ([]*models.PreparedStatement, error) <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("prepared_statement_list")
        defer timer.Stop()

        s.logger.Debug("Listing prepared statements", "transaction_id", transactionID)

        // List from repository
        stmts, err := s.repo.List(ctx, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("prepared_statement_list_errors")
                s.logger.Error("Failed to list prepared statements", "error", err, "transaction_id", transactionID)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to list prepared statements")
        }</span>

        <span class="cov0" title="0">s.logger.Info("Listed prepared statements",
                "count", len(stmts),
                "transaction_id", transactionID)

        return stmts, nil</span>
}

// getActiveStatementCount returns the current count of active prepared statements.
func (s *preparedStatementService) getActiveStatementCount(ctx context.Context) float64 <span class="cov0" title="0">{
        // This is a best-effort count
        // In a real implementation, this could be maintained in memory or queried from the repository
        stmts, err := s.repo.List(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return float64(len(stmts))</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Package services contains business logic implementations.
package services

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/TFMV/porter/pkg/errors"
        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/repositories"
)

// queryService implements QueryService interface.
type queryService struct {
        repo       repositories.QueryRepository
        txnService TransactionService
        logger     Logger
        metrics    MetricsCollector
        classifier *StatementClassifier
}

// NewQueryService creates a new query service.
func NewQueryService(
        repo repositories.QueryRepository,
        txnService TransactionService,
        logger Logger,
        metrics MetricsCollector,
) QueryService <span class="cov0" title="0">{
        return &amp;queryService{
                repo:       repo,
                txnService: txnService,
                logger:     logger,
                metrics:    metrics,
                classifier: NewStatementClassifier(),
        }
}</span>

// ExecuteQuery executes a query with proper error handling and metrics.
func (s *queryService) ExecuteQuery(ctx context.Context, req *models.QueryRequest) (*models.QueryResult, error) <span class="cov0" title="0">{
        // Start metrics
        timer := s.metrics.StartTimer("query_execution")
        defer timer.Stop()

        // Log query execution
        s.logger.Debug("Executing query", "query", req.Query, "transaction_id", req.TransactionID)

        // Validate request
        if err := s.validateQueryRequest(req); err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("query_validation_errors")
                return nil, err
        }</span>

        // Get transaction if specified
        <span class="cov0" title="0">var txn repositories.Transaction
        if req.TransactionID != "" </span><span class="cov0" title="0">{
                var err error
                txn, err = s.txnService.Get(ctx, req.TransactionID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to get transaction", "error", err, "transaction_id", req.TransactionID)
                        s.metrics.IncrementCounter("transaction_lookup_errors")
                        return nil, errors.Wrap(err, errors.CodeTransactionFailed, "failed to get transaction")
                }</span>

                // Check if transaction is still active
                <span class="cov0" title="0">if !txn.IsActive() </span><span class="cov0" title="0">{
                        s.metrics.IncrementCounter("inactive_transaction_errors")
                        return nil, errors.New(errors.CodeTransactionFailed, "transaction is no longer active")
                }</span>
        }

        // Execute query with timeout
        <span class="cov0" title="0">queryCtx := ctx
        if req.Timeout &gt; 0 </span><span class="cov0" title="0">{
                var cancel context.CancelFunc
                queryCtx, cancel = context.WithTimeout(ctx, req.Timeout)
                defer cancel()
        }</span>

        // Execute query
        <span class="cov0" title="0">start := time.Now()
        result, err := s.repo.ExecuteQuery(queryCtx, req.Query, txn, req.Parameters...)
        executionTime := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("query_execution_errors")
                s.logger.Error("Query execution failed",
                        "error", err,
                        "query", req.Query,
                        "execution_time", executionTime)
                return nil, s.wrapQueryError(err)
        }</span>

        // Update result with execution time
        <span class="cov0" title="0">result.ExecutionTime = executionTime

        // Record metrics
        s.metrics.IncrementCounter("successful_queries")
        s.metrics.RecordHistogram("query_execution_time", executionTime.Seconds())
        if result.TotalRows &gt;= 0 </span><span class="cov0" title="0">{
                s.metrics.RecordHistogram("query_result_rows", float64(result.TotalRows))
        }</span>

        <span class="cov0" title="0">s.logger.Info("Query executed successfully",
                "query", req.Query,
                "rows", result.TotalRows,
                "execution_time", executionTime)

        return result, nil</span>
}

// ExecuteUpdate executes an update statement.
func (s *queryService) ExecuteUpdate(ctx context.Context, req *models.UpdateRequest) (*models.UpdateResult, error) <span class="cov0" title="0">{
        // Start metrics
        timer := s.metrics.StartTimer("update_execution")
        defer timer.Stop()

        // Log update execution
        s.logger.Debug("Executing update", "statement", req.Statement, "transaction_id", req.TransactionID)

        // Validate request
        if err := s.validateUpdateRequest(req); err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("update_validation_errors")
                return nil, err
        }</span>

        // Get transaction if specified
        <span class="cov0" title="0">var txn repositories.Transaction
        if req.TransactionID != "" </span><span class="cov0" title="0">{
                var err error
                txn, err = s.txnService.Get(ctx, req.TransactionID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to get transaction", "error", err, "transaction_id", req.TransactionID)
                        s.metrics.IncrementCounter("transaction_lookup_errors")
                        return nil, errors.Wrap(err, errors.CodeTransactionFailed, "failed to get transaction")
                }</span>

                // Check if transaction is still active
                <span class="cov0" title="0">if !txn.IsActive() </span><span class="cov0" title="0">{
                        s.metrics.IncrementCounter("inactive_transaction_errors")
                        return nil, errors.New(errors.CodeTransactionFailed, "transaction is no longer active")
                }</span>
        }

        // Execute update with timeout
        <span class="cov0" title="0">updateCtx := ctx
        if req.Timeout &gt; 0 </span><span class="cov0" title="0">{
                var cancel context.CancelFunc
                updateCtx, cancel = context.WithTimeout(ctx, req.Timeout)
                defer cancel()
        }</span>

        // Execute update
        <span class="cov0" title="0">start := time.Now()
        result, err := s.repo.ExecuteUpdate(updateCtx, req.Statement, txn, req.Parameters...)
        executionTime := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("update_execution_errors")
                s.logger.Error("Update execution failed",
                        "error", err,
                        "statement", req.Statement,
                        "execution_time", executionTime)
                return nil, s.wrapQueryError(err)
        }</span>

        // Update result with execution time
        <span class="cov0" title="0">result.ExecutionTime = executionTime

        // Record metrics
        s.metrics.IncrementCounter("successful_updates")
        s.metrics.RecordHistogram("update_execution_time", executionTime.Seconds())
        s.metrics.RecordHistogram("update_affected_rows", float64(result.RowsAffected))

        s.logger.Info("Update executed successfully",
                "statement", req.Statement,
                "rows_affected", result.RowsAffected,
                "execution_time", executionTime)

        return result, nil</span>
}

// ValidateQuery validates a SQL query without executing it.
func (s *queryService) ValidateQuery(ctx context.Context, query string) error <span class="cov0" title="0">{
        // Basic validation
        if query == "" </span><span class="cov0" title="0">{
                return errors.New(errors.CodeInvalidRequest, "query cannot be empty")
        }</span>

        // Normalize query
        <span class="cov0" title="0">query = strings.TrimSpace(query)

        // Check for dangerous operations (can be made configurable)
        upperQuery := strings.ToUpper(query)
        dangerousKeywords := []string{
                "DROP DATABASE",
                "DROP SCHEMA",
                "TRUNCATE",
        }

        for _, keyword := range dangerousKeywords </span><span class="cov0" title="0">{
                if strings.Contains(upperQuery, keyword) </span><span class="cov0" title="0">{
                        s.logger.Warn("Dangerous query detected", "query", query, "keyword", keyword)
                        s.metrics.IncrementCounter("dangerous_query_attempts")
                        // Note: We don't block here, just log. This can be made configurable.
                }</span>
        }

        <span class="cov0" title="0">if err := s.classifier.ValidateStatement(query); err != nil </span><span class="cov0" title="0">{
                return errors.New(errors.CodeInvalidRequest, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateQueryRequest validates a query request.
func (s *queryService) validateQueryRequest(req *models.QueryRequest) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New(errors.CodeInvalidRequest, "query request cannot be nil")
        }</span>

        <span class="cov0" title="0">if req.Query == "" </span><span class="cov0" title="0">{
                return errors.ErrInvalidQuery.WithDetail("query", "cannot be empty")
        }</span>

        // Validate max rows
        <span class="cov0" title="0">if req.MaxRows &lt; 0 </span><span class="cov0" title="0">{
                return errors.New(errors.CodeInvalidRequest, "max_rows cannot be negative")
        }</span>

        // Validate timeout
        <span class="cov0" title="0">if req.Timeout &lt; 0 </span><span class="cov0" title="0">{
                return errors.New(errors.CodeInvalidRequest, "timeout cannot be negative")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateUpdateRequest validates an update request.
func (s *queryService) validateUpdateRequest(req *models.UpdateRequest) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New(errors.CodeInvalidRequest, "update request cannot be nil")
        }</span>

        <span class="cov0" title="0">if req.Statement == "" </span><span class="cov0" title="0">{
                return errors.New(errors.CodeInvalidRequest, "statement cannot be empty")
        }</span>

        <span class="cov0" title="0">if err := s.classifier.ValidateStatement(req.Statement); err != nil </span><span class="cov0" title="0">{
                return errors.New(errors.CodeInvalidRequest, err.Error())
        }</span>

        // Validate timeout
        <span class="cov0" title="0">if req.Timeout &lt; 0 </span><span class="cov0" title="0">{
                return errors.New(errors.CodeInvalidRequest, "timeout cannot be negative")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetStatementType returns the type of a SQL statement.
func (s *queryService) GetStatementType(query string) StatementType <span class="cov0" title="0">{
        return s.classifier.ClassifyStatement(query)
}</span>

// IsUpdateStatement returns true if the statement should return an update count.
func (s *queryService) IsUpdateStatement(query string) bool <span class="cov0" title="0">{
        return s.classifier.IsUpdateStatement(query)
}</span>

// IsQueryStatement returns true if the statement should return a result set.
func (s *queryService) IsQueryStatement(query string) bool <span class="cov0" title="0">{
        return s.classifier.IsQueryStatement(query)
}</span>

// wrapQueryError wraps database errors with appropriate error codes.
func (s *queryService) wrapQueryError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">errStr := err.Error()

        // Check for common database errors
        switch </span>{
        case strings.Contains(errStr, "syntax error"):<span class="cov0" title="0">
                return errors.Wrap(err, errors.CodeInvalidRequest, "SQL syntax error")</span>
        case strings.Contains(errStr, "does not exist"):<span class="cov0" title="0">
                return errors.Wrap(err, errors.CodeNotFound, "object not found")</span>
        case strings.Contains(errStr, "permission denied"):<span class="cov0" title="0">
                return errors.Wrap(err, errors.CodePermissionDenied, "permission denied")</span>
        case strings.Contains(errStr, "timeout"):<span class="cov0" title="0">
                return errors.Wrap(err, errors.CodeDeadlineExceeded, "query timeout")</span>
        case strings.Contains(errStr, "connection"):<span class="cov0" title="0">
                return errors.Wrap(err, errors.CodeUnavailable, "database connection error")</span>
        default:<span class="cov0" title="0">
                return errors.Wrap(err, errors.CodeQueryFailed, fmt.Sprintf("query failed: %s", err))</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Package services contains business logic implementations.
package services

import (
        "fmt"
        "regexp"
        "strings"
        "sync"
)

// StatementType represents the type of SQL statement.
type StatementType int

const (
        StatementTypeDDL     StatementType = iota // CREATE, DROP, ALTER, TRUNCATE
        StatementTypeDML                          // INSERT, UPDATE, DELETE, REPLACE, MERGE
        StatementTypeDQL                          // SELECT, WITH...SELECT
        StatementTypeTCL                          // COMMIT, ROLLBACK, SAVEPOINT, BEGIN
        StatementTypeDCL                          // GRANT, REVOKE, DENY
        StatementTypeUtility                      // SHOW, DESCRIBE, EXPLAIN, ANALYZE, SET, USE, PRAGMA
        StatementTypeOther                        // Unrecognized statements
)

// String returns the string representation of the statement type.
func (st StatementType) String() string <span class="cov2" title="5">{
        switch st </span>{
        case StatementTypeDDL:<span class="cov1" title="1">
                return "DDL"</span>
        case StatementTypeDML:<span class="cov1" title="1">
                return "DML"</span>
        case StatementTypeDQL:<span class="cov1" title="1">
                return "DQL"</span>
        case StatementTypeTCL:<span class="cov0" title="0">
                return "TCL"</span>
        case StatementTypeDCL:<span class="cov0" title="0">
                return "DCL"</span>
        case StatementTypeUtility:<span class="cov0" title="0">
                return "UTILITY"</span>
        case StatementTypeOther:<span class="cov1" title="1">
                return "OTHER"</span>
        default:<span class="cov1" title="1">
                return "UNKNOWN"</span>
        }
}

// StatementComplexity indicates the estimated complexity of a SQL statement.
type StatementComplexity int

const (
        ComplexitySimple StatementComplexity = iota
        ComplexityModerate
        ComplexityComplex
        ComplexityVeryComplex
)

// String returns the string representation of statement complexity.
func (sc StatementComplexity) String() string <span class="cov0" title="0">{
        switch sc </span>{
        case ComplexitySimple:<span class="cov0" title="0">
                return "simple"</span>
        case ComplexityModerate:<span class="cov0" title="0">
                return "moderate"</span>
        case ComplexityComplex:<span class="cov0" title="0">
                return "complex"</span>
        case ComplexityVeryComplex:<span class="cov0" title="0">
                return "very_complex"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// StatementInfo provides comprehensive information about a SQL statement.
type StatementInfo struct {
        Type                StatementType
        Complexity          StatementComplexity
        ExpectsResultSet    bool
        ExpectsUpdateCount  bool
        RequiresTransaction bool
        IsReadOnly          bool
        IsDangerous         bool
        HasSQLInjectionRisk bool
        Keywords            []string
        Tables              []string
        Operations          []string
        SecurityRisk        SecurityRiskLevel
}

// SecurityRiskLevel indicates the security risk level of a statement.
type SecurityRiskLevel int

const (
        SecurityRiskNone SecurityRiskLevel = iota
        SecurityRiskLow
        SecurityRiskMedium
        SecurityRiskHigh
        SecurityRiskCritical
)

// String returns the string representation of security risk level.
func (srl SecurityRiskLevel) String() string <span class="cov0" title="0">{
        switch srl </span>{
        case SecurityRiskNone:<span class="cov0" title="0">
                return "none"</span>
        case SecurityRiskLow:<span class="cov0" title="0">
                return "low"</span>
        case SecurityRiskMedium:<span class="cov0" title="0">
                return "medium"</span>
        case SecurityRiskHigh:<span class="cov0" title="0">
                return "high"</span>
        case SecurityRiskCritical:<span class="cov0" title="0">
                return "critical"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// EnterpriseStatementClassifier provides comprehensive SQL statement analysis.
type EnterpriseStatementClassifier struct {
        // Compiled regex patterns for performance
        ddlPatterns     []*regexp.Regexp
        dmlPatterns     []*regexp.Regexp
        dqlPatterns     []*regexp.Regexp
        tclPatterns     []*regexp.Regexp
        dclPatterns     []*regexp.Regexp
        utilityPatterns []*regexp.Regexp

        // Security patterns
        dangerousPatterns []*regexp.Regexp
        injectionPatterns []*regexp.Regexp

        // Complexity analysis patterns
        complexityPatterns map[string]int

        // SQL keywords and functions from GizmoSQL
        sqlKeywords      map[string]bool
        numericFunctions map[string]bool
        stringFunctions  map[string]bool
        dateFunctions    map[string]bool
        systemFunctions  map[string]bool

        // Thread safety
        mu sync.RWMutex
}

// NewEnterpriseStatementClassifier creates a new enterprise-grade statement classifier.
func NewEnterpriseStatementClassifier() *EnterpriseStatementClassifier <span class="cov2" title="4">{
        classifier := &amp;EnterpriseStatementClassifier{
                complexityPatterns: make(map[string]int),
                sqlKeywords:        make(map[string]bool),
                numericFunctions:   make(map[string]bool),
                stringFunctions:    make(map[string]bool),
                dateFunctions:      make(map[string]bool),
                systemFunctions:    make(map[string]bool),
        }

        classifier.initializePatterns()
        classifier.initializeSQLKnowledge()

        return classifier
}</span>

// initializePatterns compiles all regex patterns for statement classification.
func (esc *EnterpriseStatementClassifier) initializePatterns() <span class="cov2" title="4">{
        // DDL patterns - Data Definition Language
        esc.ddlPatterns = []*regexp.Regexp{
                regexp.MustCompile(`(?i)^\s*CREATE\s+`),
                regexp.MustCompile(`(?i)^\s*DROP\s+`),
                regexp.MustCompile(`(?i)^\s*ALTER\s+`),
                regexp.MustCompile(`(?i)^\s*TRUNCATE\s+`),
                regexp.MustCompile(`(?i)^\s*COMMENT\s+ON\s+`),
                regexp.MustCompile(`(?i)^\s*RENAME\s+`),
        }

        // DML patterns - Data Manipulation Language
        esc.dmlPatterns = []*regexp.Regexp{
                regexp.MustCompile(`(?i)^\s*INSERT\s+`),
                regexp.MustCompile(`(?i)^\s*UPDATE\s+`),
                regexp.MustCompile(`(?i)^\s*DELETE\s+`),
                regexp.MustCompile(`(?i)^\s*REPLACE\s+`),
                regexp.MustCompile(`(?i)^\s*MERGE\s+`),
                regexp.MustCompile(`(?i)^\s*UPSERT\s+`),
                regexp.MustCompile(`(?i)^\s*COPY\s+.*\s+FROM\s+`),
                regexp.MustCompile(`(?i)^\s*BULK\s+INSERT\s+`),
        }

        // DQL patterns - Data Query Language
        esc.dqlPatterns = []*regexp.Regexp{
                regexp.MustCompile(`(?i)^\s*SELECT\s+`),
                regexp.MustCompile(`(?i)^\s*WITH\s+.*\s+SELECT\s+`),
                regexp.MustCompile(`(?i)^\s*\(\s*SELECT\s+`), // Subquery
                regexp.MustCompile(`(?i)^\s*VALUES\s+`),
                regexp.MustCompile(`(?i)^\s*TABLE\s+`), // TABLE statement
        }

        // TCL patterns - Transaction Control Language
        esc.tclPatterns = []*regexp.Regexp{
                regexp.MustCompile(`(?i)^\s*BEGIN\s*`),
                regexp.MustCompile(`(?i)^\s*START\s+TRANSACTION\s*`),
                regexp.MustCompile(`(?i)^\s*COMMIT\s*`),
                regexp.MustCompile(`(?i)^\s*ROLLBACK\s*`),
                regexp.MustCompile(`(?i)^\s*SAVEPOINT\s+`),
                regexp.MustCompile(`(?i)^\s*RELEASE\s+SAVEPOINT\s+`),
                regexp.MustCompile(`(?i)^\s*SET\s+TRANSACTION\s+`),
        }

        // DCL patterns - Data Control Language
        esc.dclPatterns = []*regexp.Regexp{
                regexp.MustCompile(`(?i)^\s*GRANT\s+`),
                regexp.MustCompile(`(?i)^\s*REVOKE\s+`),
                regexp.MustCompile(`(?i)^\s*DENY\s+`),
                regexp.MustCompile(`(?i)^\s*CREATE\s+USER\s+`),
                regexp.MustCompile(`(?i)^\s*DROP\s+USER\s+`),
                regexp.MustCompile(`(?i)^\s*ALTER\s+USER\s+`),
                regexp.MustCompile(`(?i)^\s*CREATE\s+ROLE\s+`),
                regexp.MustCompile(`(?i)^\s*DROP\s+ROLE\s+`),
        }

        // Utility patterns
        esc.utilityPatterns = []*regexp.Regexp{
                regexp.MustCompile(`(?i)^\s*SHOW\s+`),
                regexp.MustCompile(`(?i)^\s*DESCRIBE\s+`),
                regexp.MustCompile(`(?i)^\s*DESC\s+`),
                regexp.MustCompile(`(?i)^\s*EXPLAIN\s+`),
                regexp.MustCompile(`(?i)^\s*ANALYZE\s+`),
                regexp.MustCompile(`(?i)^\s*SET\s+`),
                regexp.MustCompile(`(?i)^\s*USE\s+`),
                regexp.MustCompile(`(?i)^\s*PRAGMA\s+`),
                regexp.MustCompile(`(?i)^\s*VACUUM\s*`),
                regexp.MustCompile(`(?i)^\s*REINDEX\s+`),
                regexp.MustCompile(`(?i)^\s*CHECKPOINT\s*`),
                regexp.MustCompile(`(?i)^\s*ATTACH\s+`),
                regexp.MustCompile(`(?i)^\s*DETACH\s+`),
        }

        // Dangerous operation patterns
        esc.dangerousPatterns = []*regexp.Regexp{
                regexp.MustCompile(`(?i)DROP\s+DATABASE`),
                regexp.MustCompile(`(?i)DROP\s+SCHEMA`),
                regexp.MustCompile(`(?i)TRUNCATE\s+.*DATABASE`),
                regexp.MustCompile(`(?i)DELETE\s+FROM\s+.*WHERE\s+1\s*=\s*1`),
                regexp.MustCompile(`(?i)UPDATE\s+.*SET\s+.*WHERE\s+1\s*=\s*1`),
                regexp.MustCompile(`(?i)DROP\s+TABLE\s+.*\*`),
                regexp.MustCompile(`(?i)SHUTDOWN`),
                regexp.MustCompile(`(?i)KILL\s+`),
                regexp.MustCompile(`(?i)FORMAT\s+`),
                regexp.MustCompile(`(?i)RESTORE\s+`),
                regexp.MustCompile(`(?i)BACKUP\s+`),
        }

        // SQL injection patterns
        esc.injectionPatterns = []*regexp.Regexp{
                regexp.MustCompile(`(?i)';`),
                regexp.MustCompile(`(?i)--`),
                regexp.MustCompile(`(?i)/\*`),
                regexp.MustCompile(`(?i)\*/`),
                regexp.MustCompile(`(?i)UNION\s+.*SELECT`),
                regexp.MustCompile(`(?i)OR\s+1\s*=\s*1`),
                regexp.MustCompile(`(?i)AND\s+1\s*=\s*1`),
                regexp.MustCompile(`(?i)'\s*OR\s*'`),
                regexp.MustCompile(`(?i)'\s*AND\s*'`),
                regexp.MustCompile(`(?i)EXEC\s*\(`),
                regexp.MustCompile(`(?i)EXECUTE\s*\(`),
                regexp.MustCompile(`(?i)SP_`),
                regexp.MustCompile(`(?i)XP_`),
        }

        // Complexity analysis patterns with weights
        esc.complexityPatterns = map[string]int{
                "JOIN":         2,
                "LEFT JOIN":    2,
                "RIGHT JOIN":   2,
                "FULL JOIN":    3,
                "CROSS JOIN":   3,
                "INNER JOIN":   2,
                "OUTER JOIN":   3,
                "SUBQUERY":     3,
                "WITH":         2,
                "CTE":          2,
                "WINDOW":       3,
                "OVER":         3,
                "PARTITION BY": 2,
                "GROUP BY":     1,
                "HAVING":       1,
                "ORDER BY":     1,
                "UNION":        2,
                "UNION ALL":    2,
                "INTERSECT":    2,
                "EXCEPT":       2,
                "CASE":         1,
                "EXISTS":       2,
                "NOT EXISTS":   2,
                "IN":           1,
                "NOT IN":       1,
                "ANY":          2,
                "ALL":          2,
                "SOME":         2,
                "RECURSIVE":    4,
                "LATERAL":      3,
        }
}</span>

// initializeSQLKnowledge initializes comprehensive SQL knowledge from GizmoSQL.
func (esc *EnterpriseStatementClassifier) initializeSQLKnowledge() <span class="cov2" title="4">{
        // SQL Keywords from GizmoSQL (400+ keywords)
        keywords := []string{
                "ABORT", "ABSOLUTE", "ACCESS", "ACTION", "ADD", "ADMIN", "AFTER", "AGGREGATE",
                "ALL", "ALSO", "ALTER", "ALWAYS", "ANALYSE", "ANALYZE", "AND", "ANY", "ARRAY",
                "AS", "ASC", "ASSERTION", "ASSIGNMENT", "ASYMMETRIC", "AT", "ATTACH", "ATTRIBUTE",
                "AUTHORIZATION", "BACKWARD", "BEFORE", "BEGIN", "BETWEEN", "BIGINT", "BINARY",
                "BIT", "BOOLEAN", "BOTH", "BY", "CACHE", "CALL", "CALLED", "CASCADE", "CASCADED",
                "CASE", "CAST", "CATALOG", "CHAIN", "CHAR", "CHARACTER", "CHARACTERISTICS",
                "CHECK", "CHECKPOINT", "CLASS", "CLOSE", "CLUSTER", "COALESCE", "COLLATE",
                "COLLATION", "COLUMN", "COLUMNS", "COMMENT", "COMMENTS", "COMMIT", "COMMITTED",
                "CONCURRENTLY", "CONFIGURATION", "CONFLICT", "CONNECTION", "CONSTRAINT",
                "CONSTRAINTS", "CONTENT", "CONTINUE", "CONVERSION", "COPY", "COST", "CREATE",
                "CROSS", "CSV", "CUBE", "CURRENT", "CURRENT_CATALOG", "CURRENT_DATE",
                "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_TIME", "CURRENT_TIMESTAMP",
                "CURRENT_USER", "CURSOR", "CYCLE", "DATA", "DATABASE", "DAY", "DAYS",
                "DEALLOCATE", "DEC", "DECIMAL", "DECLARE", "DEFAULT", "DEFAULTS", "DEFERRABLE",
                "DEFERRED", "DEFINER", "DELETE", "DELIMITER", "DELIMITERS", "DEPENDS", "DESC",
                "DESCRIBE", "DETACH", "DICTIONARY", "DISABLE", "DISCARD", "DISTINCT", "DO",
                "DOCUMENT", "DOMAIN", "DOUBLE", "DROP", "EACH", "ELSE", "ENABLE", "ENCODING",
                "ENCRYPTED", "END", "ENUM", "ESCAPE", "EVENT", "EXCEPT", "EXCLUDE", "EXCLUDING",
                "EXCLUSIVE", "EXECUTE", "EXISTS", "EXPLAIN", "EXPORT", "EXTENSION", "EXTERNAL",
                "EXTRACT", "FALSE", "FAMILY", "FETCH", "FILTER", "FIRST", "FLOAT", "FOLLOWING",
                "FOR", "FORCE", "FOREIGN", "FORWARD", "FREEZE", "FROM", "FULL", "FUNCTION",
                "FUNCTIONS", "GENERATED", "GLOB", "GLOBAL", "GRANT", "GRANTED", "GROUP",
                "GROUPING", "HANDLER", "HAVING", "HEADER", "HOLD", "HOUR", "HOURS", "IDENTITY",
                "IF", "ILIKE", "IMMEDIATE", "IMMUTABLE", "IMPLICIT", "IMPORT", "IN", "INCLUDING",
                "INCREMENT", "INDEX", "INDEXES", "INHERIT", "INHERITS", "INITIALLY", "INLINE",
                "INNER", "INOUT", "INPUT", "INSENSITIVE", "INSERT", "INSTEAD", "INT", "INTEGER",
                "INTERSECT", "INTERVAL", "INTO", "INVOKER", "IS", "ISNULL", "ISOLATION", "JOIN",
                "KEY", "LABEL", "LANGUAGE", "LARGE", "LAST", "LATERAL", "LEADING", "LEAKPROOF",
                "LEFT", "LEVEL", "LIKE", "LIMIT", "LISTEN", "LOAD", "LOCAL", "LOCALTIME",
                "LOCALTIMESTAMP", "LOCATION", "LOCK", "LOCKED", "LOGGED", "MACRO", "MAP",
                "MAPPING", "MATCH", "MATERIALIZED", "MAXVALUE", "METHOD", "MICROSECOND",
                "MICROSECONDS", "MILLISECOND", "MILLISECONDS", "MINUTE", "MINUTES", "MINVALUE",
                "MODE", "MONTH", "MONTHS", "MOVE", "NAME", "NAMES", "NATIONAL", "NATURAL",
                "NCHAR", "NEW", "NEXT", "NO", "NONE", "NOT", "NOTHING", "NOTIFY", "NOTNULL",
                "NOWAIT", "NULL", "NULLIF", "NULLS", "NUMERIC", "OBJECT", "OF", "OFF", "OFFSET",
                "OIDS", "OLD", "ON", "ONLY", "OPERATOR", "OPTION", "OPTIONS", "OR", "ORDER",
                "ORDINALITY", "OUT", "OUTER", "OVER", "OVERLAPS", "OVERLAY", "OVERRIDING",
                "OWNED", "OWNER", "PARALLEL", "PARSER", "PARTIAL", "PARTITION", "PASSING",
                "PASSWORD", "PERCENT", "PLACING", "PLANS", "POLICY", "POSITION", "PRAGMA",
                "PRECEDING", "PRECISION", "PREPARE", "PREPARED", "PRESERVE", "PRIMARY", "PRIOR",
                "PRIVILEGES", "PROCEDURAL", "PROCEDURE", "PROGRAM", "PUBLICATION", "QUOTE",
                "RANGE", "READ", "REAL", "REASSIGN", "RECHECK", "RECURSIVE", "REF", "REFERENCES",
                "REFERENCING", "REFRESH", "REINDEX", "RELATIVE", "RELEASE", "RENAME",
                "REPEATABLE", "REPLACE", "REPLICA", "RESET", "RESTART", "RESTRICT", "RETURNING",
                "RETURNS", "REVOKE", "RIGHT", "ROLE", "ROLLBACK", "ROLLUP", "ROW", "ROWS",
                "RULE", "SAMPLE", "SAVEPOINT", "SCHEMA", "SCHEMAS", "SCROLL", "SEARCH", "SECOND",
                "SECONDS", "SECURITY", "SELECT", "SEQUENCE", "SEQUENCES", "SERIALIZABLE",
                "SERVER", "SESSION", "SESSION_USER", "SET", "SETOF", "SETS", "SHARE", "SHOW",
                "SIMILAR", "SIMPLE", "SKIP", "SMALLINT", "SNAPSHOT", "SOME", "SQL", "STABLE",
                "STANDALONE", "START", "STATEMENT", "STATISTICS", "STDIN", "STDOUT", "STORAGE",
                "STRICT", "STRIP", "STRUCT", "SUBSCRIPTION", "SUBSTRING", "SYMMETRIC", "SYSID",
                "SYSTEM", "TABLE", "TABLES", "TABLESAMPLE", "TABLESPACE", "TEMP", "TEMPLATE",
                "TEMPORARY", "TEXT", "THEN", "TIME", "TIMESTAMP", "TO", "TRAILING", "TRANSACTION",
                "TRANSFORM", "TREAT", "TRIGGER", "TRIM", "TRUE", "TRUNCATE", "TRUSTED", "TRY_CAST",
                "TYPE", "TYPES", "UNBOUNDED", "UNCOMMITTED", "UNENCRYPTED", "UNION", "UNIQUE",
                "UNKNOWN", "UNLISTEN", "UNLOGGED", "UNTIL", "UPDATE", "USER", "USING", "VACUUM",
                "VALID", "VALIDATE", "VALIDATOR", "VALUE", "VALUES", "VARCHAR", "VARIADIC",
                "VARYING", "VERBOSE", "VERSION", "VIEW", "VIEWS", "VOLATILE", "WHEN", "WHERE",
                "WHITESPACE", "WINDOW", "WITH", "WITHIN", "WITHOUT", "WORK", "WRAPPER", "WRITE",
                "XML", "XMLATTRIBUTES", "XMLCONCAT", "XMLELEMENT", "XMLEXISTS", "XMLFOREST",
                "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLROOT", "XMLSERIALIZE", "XMLTABLE",
                "YEAR", "YEARS", "YES", "ZONE",
        }

        for _, keyword := range keywords </span><span class="cov10" title="1804">{
                esc.sqlKeywords[keyword] = true
        }</span>

        // Numeric functions
        <span class="cov2" title="4">numericFuncs := []string{
                "ABS", "ACOS", "ASIN", "ATAN", "ATAN2", "CEIL", "CEILING", "COS", "COT",
                "DEGREES", "EXP", "FLOOR", "LOG", "LOG10", "LOG2", "MOD", "PI", "POWER",
                "RADIANS", "RANDOM", "ROUND", "SIGN", "SIN", "SQRT", "TAN", "TRUNCATE",
                "GREATEST", "LEAST", "CBRT", "FACTORIAL", "GAMMA", "LGAMMA", "LN",
                "NEXTAFTER", "POW", "SETSEED", "XOR", "BIT_COUNT", "EVEN",
        }

        for _, fn := range numericFuncs </span><span class="cov7" title="156">{
                esc.numericFunctions[fn] = true
        }</span>

        // String functions
        <span class="cov2" title="4">stringFuncs := []string{
                "ASCII", "CHAR", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHR", "CONCAT", "CONCAT_WS",
                "CONTAINS", "DIFFERENCE", "FORMAT", "INITCAP", "INSERT", "INSTR", "LCASE",
                "LEFT", "LENGTH", "LIKE", "LOCATE", "LOWER", "LPAD", "LTRIM", "MD5",
                "OCTET_LENGTH", "OVERLAY", "POSITION", "REPEAT", "REPLACE", "REVERSE",
                "RIGHT", "RPAD", "RTRIM", "SOUNDEX", "SPACE", "SPLIT_PART", "STRPOS",
                "SUBSTRING", "TRANSLATE", "TRIM", "UCASE", "UPPER", "BASE64", "FROM_BASE64",
                "TO_BASE64", "REGEXP_MATCHES", "REGEXP_REPLACE", "REGEXP_SPLIT_TO_ARRAY",
                "STRING_SPLIT", "STRING_TO_ARRAY", "ARRAY_TO_STRING", "EDITDIST3",
                "HAMMING", "JACCARD", "LEVENSHTEIN", "MISMATCHES", "NFC_NORMALIZE",
                "STRIP_ACCENTS", "UNICODE", "ORD", "PREFIX", "SUFFIX", "STARTS_WITH",
                "ENDS_WITH", "LIKE_ESCAPE", "NOT_LIKE_ESCAPE",
        }

        for _, fn := range stringFuncs </span><span class="cov7" title="256">{
                esc.stringFunctions[fn] = true
        }</span>

        // Date/time functions
        <span class="cov2" title="4">dateFuncs := []string{
                "NOW", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "LOCALTIME",
                "LOCALTIMESTAMP", "DATE", "TIME", "TIMESTAMP", "EXTRACT", "DATE_PART",
                "DATE_TRUNC", "AGE", "JUSTIFY_DAYS", "JUSTIFY_HOURS", "JUSTIFY_INTERVAL",
                "MAKE_DATE", "MAKE_TIME", "MAKE_TIMESTAMP", "MAKE_TIMESTAMPTZ",
                "TO_TIMESTAMP", "TO_DATE", "EPOCH", "TIMEZONE",
        }

        for _, fn := range dateFuncs </span><span class="cov6" title="96">{
                esc.dateFunctions[fn] = true
        }</span>

        // System functions
        <span class="cov2" title="4">systemFuncs := []string{
                "VERSION", "USER", "CURRENT_USER", "SESSION_USER", "SYSTEM_USER",
                "DATABASE", "SCHEMA", "CATALOG", "CONNECTION_ID", "LAST_INSERT_ID",
                "ROW_COUNT", "FOUND_ROWS", "UUID", "RANDOM_UUID", "NEWID",
        }

        for _, fn := range systemFuncs </span><span class="cov5" title="60">{
                esc.systemFunctions[fn] = true
        }</span>
}

// AnalyzeStatement performs comprehensive analysis of a SQL statement.
func (esc *EnterpriseStatementClassifier) AnalyzeStatement(sql string) (*StatementInfo, error) <span class="cov5" title="64">{
        if sql == "" </span><span class="cov2" title="4">{
                return nil, fmt.Errorf("SQL statement cannot be empty")
        }</span>

        <span class="cov5" title="60">esc.mu.RLock()
        defer esc.mu.RUnlock()

        normalized := strings.TrimSpace(sql)
        upperSQL := strings.ToUpper(normalized)

        info := &amp;StatementInfo{
                Keywords:   esc.extractKeywords(upperSQL),
                Tables:     esc.extractTables(upperSQL),
                Operations: esc.extractOperations(upperSQL),
        }

        // Classify statement type
        info.Type = esc.classifyStatementType(upperSQL)

        // Estimate complexity
        info.Complexity = esc.estimateComplexity(upperSQL)

        // Determine JDBC expectations
        esc.setJDBCExpectations(info)

        // Analyze security risks
        info.IsDangerous = esc.isDangerous(upperSQL)
        info.HasSQLInjectionRisk = esc.hasSQLInjectionRisk(upperSQL)
        info.SecurityRisk = esc.assessSecurityRisk(info)

        // Determine transaction requirements
        info.RequiresTransaction = esc.requiresTransaction(upperSQL, info.Type)

        return info, nil</span>
}

// classifyStatementType determines the statement type using regex patterns.
func (esc *EnterpriseStatementClassifier) classifyStatementType(upperSQL string) StatementType <span class="cov5" title="60">{
        // Check DDL patterns
        for _, pattern := range esc.ddlPatterns </span><span class="cov7" title="303">{
                if pattern.MatchString(upperSQL) </span><span class="cov4" title="14">{
                        return StatementTypeDDL
                }</span>
        }

        // Check DML patterns
        <span class="cov5" title="46">for _, pattern := range esc.dmlPatterns </span><span class="cov7" title="276">{
                if pattern.MatchString(upperSQL) </span><span class="cov4" title="16">{
                        return StatementTypeDML
                }</span>
        }

        // Check DQL patterns
        <span class="cov5" title="30">for _, pattern := range esc.dqlPatterns </span><span class="cov6" title="106">{
                if pattern.MatchString(upperSQL) </span><span class="cov3" title="12">{
                        return StatementTypeDQL
                }</span>
        }

        // Check TCL patterns
        <span class="cov4" title="18">for _, pattern := range esc.tclPatterns </span><span class="cov6" title="126">{
                if pattern.MatchString(upperSQL) </span><span class="cov0" title="0">{
                        return StatementTypeTCL
                }</span>
        }

        // Check DCL patterns
        <span class="cov4" title="18">for _, pattern := range esc.dclPatterns </span><span class="cov6" title="144">{
                if pattern.MatchString(upperSQL) </span><span class="cov0" title="0">{
                        return StatementTypeDCL
                }</span>
        }

        // Check utility patterns
        <span class="cov4" title="18">for _, pattern := range esc.utilityPatterns </span><span class="cov6" title="88">{
                if pattern.MatchString(upperSQL) </span><span class="cov4" title="15">{
                        return StatementTypeUtility
                }</span>
        }

        <span class="cov2" title="3">return StatementTypeOther</span>
}

// estimateComplexity estimates the complexity of a SQL statement.
func (esc *EnterpriseStatementClassifier) estimateComplexity(upperSQL string) StatementComplexity <span class="cov5" title="60">{
        complexityScore := 0

        // Count complexity indicators
        for pattern, weight := range esc.complexityPatterns </span><span class="cov9" title="1800">{
                count := strings.Count(upperSQL, pattern)
                complexityScore += count * weight
        }</span>

        // Additional complexity factors

        // Subqueries (count SELECT occurrences beyond the first)
        <span class="cov5" title="60">selectCount := strings.Count(upperSQL, "SELECT")
        if selectCount &gt; 1 </span><span class="cov2" title="4">{
                complexityScore += (selectCount - 1) * 3
        }</span>

        // Nested parentheses depth
        <span class="cov5" title="60">maxDepth := esc.calculateParenthesesDepth(upperSQL)
        if maxDepth &gt; 2 </span><span class="cov0" title="0">{
                complexityScore += (maxDepth - 2) * 2
        }</span>

        // Function calls
        <span class="cov5" title="60">functionCount := esc.countFunctionCalls(upperSQL)
        complexityScore += functionCount / 2

        // Determine complexity level
        switch </span>{
        case complexityScore == 0:<span class="cov5" title="36">
                return ComplexitySimple</span>
        case complexityScore &lt;= 3:<span class="cov4" title="20">
                return ComplexityModerate</span>
        case complexityScore &lt;= 8:<span class="cov0" title="0">
                return ComplexityComplex</span>
        default:<span class="cov2" title="4">
                return ComplexityVeryComplex</span>
        }
}

// setJDBCExpectations sets JDBC-specific expectations based on statement type.
func (esc *EnterpriseStatementClassifier) setJDBCExpectations(info *StatementInfo) <span class="cov5" title="60">{
        switch info.Type </span>{
        case StatementTypeDDL, StatementTypeDML:<span class="cov5" title="30">
                info.ExpectsUpdateCount = true
                info.ExpectsResultSet = false
                info.IsReadOnly = false</span>
        case StatementTypeDQL:<span class="cov3" title="12">
                info.ExpectsUpdateCount = false
                info.ExpectsResultSet = true
                info.IsReadOnly = true</span>
        case StatementTypeTCL:<span class="cov0" title="0">
                info.ExpectsUpdateCount = true
                info.ExpectsResultSet = false
                info.IsReadOnly = false</span>
        case StatementTypeDCL:<span class="cov0" title="0">
                info.ExpectsUpdateCount = true
                info.ExpectsResultSet = false
                info.IsReadOnly = false</span>
        case StatementTypeUtility:<span class="cov4" title="15">
                info.ExpectsUpdateCount = false
                info.ExpectsResultSet = true
                info.IsReadOnly = true</span>
        default:<span class="cov2" title="3">
                info.ExpectsUpdateCount = false
                info.ExpectsResultSet = true
                info.IsReadOnly = true</span>
        }
}

// isDangerous checks if a statement contains dangerous operations.
func (esc *EnterpriseStatementClassifier) isDangerous(upperSQL string) bool <span class="cov5" title="60">{
        for _, pattern := range esc.dangerousPatterns </span><span class="cov8" title="660">{
                if pattern.MatchString(upperSQL) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov5" title="60">return false</span>
}

// hasSQLInjectionRisk checks for SQL injection patterns.
func (esc *EnterpriseStatementClassifier) hasSQLInjectionRisk(upperSQL string) bool <span class="cov5" title="60">{
        for _, pattern := range esc.injectionPatterns </span><span class="cov8" title="769">{
                if pattern.MatchString(upperSQL) </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov5" title="59">return false</span>
}

// assessSecurityRisk determines the overall security risk level.
func (esc *EnterpriseStatementClassifier) assessSecurityRisk(info *StatementInfo) SecurityRiskLevel <span class="cov5" title="60">{
        if info.HasSQLInjectionRisk </span><span class="cov1" title="1">{
                return SecurityRiskCritical
        }</span>

        <span class="cov5" title="59">if info.IsDangerous </span><span class="cov0" title="0">{
                return SecurityRiskHigh
        }</span>

        <span class="cov5" title="59">switch info.Type </span>{
        case StatementTypeDCL:<span class="cov0" title="0">
                return SecurityRiskHigh</span>
        case StatementTypeDDL:<span class="cov4" title="14">
                return SecurityRiskMedium</span>
        case StatementTypeDML:<span class="cov4" title="16">
                return SecurityRiskLow</span>
        case StatementTypeTCL:<span class="cov0" title="0">
                return SecurityRiskLow</span>
        default:<span class="cov5" title="29">
                return SecurityRiskNone</span>
        }
}

// requiresTransaction determines if a statement requires a transaction context.
func (esc *EnterpriseStatementClassifier) requiresTransaction(upperSQL string, stmtType StatementType) bool <span class="cov5" title="60">{
        // DML always requires transactions
        if stmtType == StatementTypeDML </span><span class="cov4" title="16">{
                return true
        }</span>

        // Some DDL operations might require transactions
        <span class="cov5" title="44">if stmtType == StatementTypeDDL </span><span class="cov4" title="14">{
                transactionRequiredPatterns := []string{
                        "CREATE.*INDEX",
                        "DROP.*INDEX",
                        "ALTER.*TABLE.*ADD.*CONSTRAINT",
                        "ALTER.*TABLE.*DROP.*CONSTRAINT",
                }

                for _, pattern := range transactionRequiredPatterns </span><span class="cov5" title="51">{
                        matched, _ := regexp.MatchString(pattern, upperSQL)
                        if matched </span><span class="cov1" title="2">{
                                return true
                        }</span>
                }
        }

        <span class="cov5" title="42">return false</span>
}

// extractKeywords extracts SQL keywords from the statement.
func (esc *EnterpriseStatementClassifier) extractKeywords(upperSQL string) []string <span class="cov5" title="60">{
        words := regexp.MustCompile(`\b\w+\b`).FindAllString(upperSQL, -1)
        var keywords []string

        for _, word := range words </span><span class="cov7" title="281">{
                if esc.sqlKeywords[word] </span><span class="cov7" title="157">{
                        keywords = append(keywords, word)
                }</span>
        }

        <span class="cov5" title="60">return keywords</span>
}

// extractTables attempts to extract table names from the statement.
func (esc *EnterpriseStatementClassifier) extractTables(upperSQL string) []string <span class="cov5" title="60">{
        var tables []string

        // Simple table extraction patterns
        patterns := []*regexp.Regexp{
                regexp.MustCompile(`(?i)FROM\s+(\w+)`),
                regexp.MustCompile(`(?i)JOIN\s+(\w+)`),
                regexp.MustCompile(`(?i)UPDATE\s+(\w+)`),
                regexp.MustCompile(`(?i)INSERT\s+INTO\s+(\w+)`),
                regexp.MustCompile(`(?i)DELETE\s+FROM\s+(\w+)`),
                regexp.MustCompile(`(?i)CREATE\s+TABLE\s+(\w+)`),
                regexp.MustCompile(`(?i)DROP\s+TABLE\s+(\w+)`),
                regexp.MustCompile(`(?i)ALTER\s+TABLE\s+(\w+)`),
                regexp.MustCompile(`(?i)TRUNCATE\s+TABLE\s+(\w+)`),
        }

        for _, pattern := range patterns </span><span class="cov8" title="540">{
                matches := pattern.FindAllStringSubmatch(upperSQL, -1)
                for _, match := range matches </span><span class="cov5" title="50">{
                        if len(match) &gt; 1 </span><span class="cov5" title="50">{
                                tables = append(tables, match[1])
                        }</span>
                }
        }

        <span class="cov5" title="60">return tables</span>
}

// extractOperations extracts the main operations from the statement.
func (esc *EnterpriseStatementClassifier) extractOperations(upperSQL string) []string <span class="cov5" title="60">{
        var operations []string

        operationPatterns := map[string]*regexp.Regexp{
                "CREATE":   regexp.MustCompile(`(?i)\bCREATE\b`),
                "DROP":     regexp.MustCompile(`(?i)\bDROP\b`),
                "ALTER":    regexp.MustCompile(`(?i)\bALTER\b`),
                "INSERT":   regexp.MustCompile(`(?i)\bINSERT\b`),
                "UPDATE":   regexp.MustCompile(`(?i)\bUPDATE\b`),
                "DELETE":   regexp.MustCompile(`(?i)\bDELETE\b`),
                "SELECT":   regexp.MustCompile(`(?i)\bSELECT\b`),
                "JOIN":     regexp.MustCompile(`(?i)\bJOIN\b`),
                "UNION":    regexp.MustCompile(`(?i)\bUNION\b`),
                "GROUP BY": regexp.MustCompile(`(?i)\bGROUP\s+BY\b`),
                "ORDER BY": regexp.MustCompile(`(?i)\bORDER\s+BY\b`),
                "HAVING":   regexp.MustCompile(`(?i)\bHAVING\b`),
                "WHERE":    regexp.MustCompile(`(?i)\bWHERE\b`),
        }

        for operation, pattern := range operationPatterns </span><span class="cov8" title="780">{
                if pattern.MatchString(upperSQL) </span><span class="cov5" title="46">{
                        operations = append(operations, operation)
                }</span>
        }

        <span class="cov5" title="60">return operations</span>
}

// calculateParenthesesDepth calculates the maximum nesting depth of parentheses.
func (esc *EnterpriseStatementClassifier) calculateParenthesesDepth(sql string) int <span class="cov5" title="60">{
        maxDepth := 0
        currentDepth := 0
        inString := false
        var stringChar rune

        for _, char := range sql </span><span class="cov9" title="1506">{
                if !inString </span><span class="cov9" title="1506">{
                        if char == '\'' || char == '"' </span><span class="cov0" title="0">{
                                inString = true
                                stringChar = char
                        }</span> else<span class="cov9" title="1506"> if char == '(' </span><span class="cov4" title="20">{
                                currentDepth++
                                if currentDepth &gt; maxDepth </span><span class="cov4" title="20">{
                                        maxDepth = currentDepth
                                }</span>
                        } else<span class="cov9" title="1486"> if char == ')' </span><span class="cov4" title="20">{
                                currentDepth--
                        }</span>
                } else<span class="cov0" title="0"> {
                        if char == stringChar </span><span class="cov0" title="0">{
                                inString = false
                        }</span>
                }
        }

        <span class="cov5" title="60">return maxDepth</span>
}

// countFunctionCalls counts the number of function calls in the statement.
func (esc *EnterpriseStatementClassifier) countFunctionCalls(upperSQL string) int <span class="cov5" title="60">{
        functionPattern := regexp.MustCompile(`\b\w+\s*\(`)
        matches := functionPattern.FindAllString(upperSQL, -1)
        return len(matches)
}</span>

// ValidateStatement performs basic SQL statement validation.
func (esc *EnterpriseStatementClassifier) ValidateStatement(sql string) error <span class="cov0" title="0">{
        if sql == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("SQL statement cannot be empty")
        }</span>

        <span class="cov0" title="0">normalized := strings.TrimSpace(sql)
        if normalized == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("SQL statement contains only whitespace")
        }</span>

        // Check for balanced parentheses
        <span class="cov0" title="0">if !esc.hasBalancedParentheses(sql) </span><span class="cov0" title="0">{
                return fmt.Errorf("SQL statement has unbalanced parentheses")
        }</span>

        // Check for balanced quotes
        <span class="cov0" title="0">if !esc.hasBalancedQuotes(sql) </span><span class="cov0" title="0">{
                return fmt.Errorf("SQL statement has unbalanced quotes")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// hasBalancedParentheses checks if parentheses are balanced.
func (esc *EnterpriseStatementClassifier) hasBalancedParentheses(sql string) bool <span class="cov0" title="0">{
        count := 0
        inString := false
        var stringChar rune

        for _, char := range sql </span><span class="cov0" title="0">{
                if !inString </span><span class="cov0" title="0">{
                        if char == '\'' || char == '"' </span><span class="cov0" title="0">{
                                inString = true
                                stringChar = char
                        }</span> else<span class="cov0" title="0"> if char == '(' </span><span class="cov0" title="0">{
                                count++
                        }</span> else<span class="cov0" title="0"> if char == ')' </span><span class="cov0" title="0">{
                                count--
                                if count &lt; 0 </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        if char == stringChar </span><span class="cov0" title="0">{
                                inString = false
                        }</span>
                }
        }

        <span class="cov0" title="0">return count == 0</span>
}

// hasBalancedQuotes checks if quotes are balanced.
func (esc *EnterpriseStatementClassifier) hasBalancedQuotes(sql string) bool <span class="cov0" title="0">{
        singleQuoteCount := 0
        doubleQuoteCount := 0

        for _, char := range sql </span><span class="cov0" title="0">{
                if char == '\'' </span><span class="cov0" title="0">{
                        singleQuoteCount++
                }</span> else<span class="cov0" title="0"> if char == '"' </span><span class="cov0" title="0">{
                        doubleQuoteCount++
                }</span>
        }

        <span class="cov0" title="0">return singleQuoteCount%2 == 0 &amp;&amp; doubleQuoteCount%2 == 0</span>
}

// Legacy methods for backward compatibility

// ClassifyStatement determines the type of a SQL statement (legacy method for compatibility).
func (esc *EnterpriseStatementClassifier) ClassifyStatement(sql string) StatementType <span class="cov5" title="64">{
        info, err := esc.AnalyzeStatement(sql)
        if err != nil </span><span class="cov2" title="4">{
                return StatementTypeOther
        }</span>
        <span class="cov5" title="60">return info.Type</span>
}

// IsUpdateStatement returns true if the statement is a DDL or DML statement
// that should return an update count rather than a result set.
func (esc *EnterpriseStatementClassifier) IsUpdateStatement(sql string) bool <span class="cov4" title="13">{
        stmtType := esc.ClassifyStatement(sql)
        return stmtType == StatementTypeDDL || stmtType == StatementTypeDML
}</span>

// IsQueryStatement returns true if the statement is a DQL statement
// that should return a result set.
func (esc *EnterpriseStatementClassifier) IsQueryStatement(sql string) bool <span class="cov3" title="10">{
        return esc.ClassifyStatement(sql) == StatementTypeDQL
}</span>

// GetExpectedResponseType returns the expected response type for a statement.
func (esc *EnterpriseStatementClassifier) GetExpectedResponseType(sql string) string <span class="cov3" title="9">{
        stmtType := esc.ClassifyStatement(sql)
        switch stmtType </span>{
        case StatementTypeDDL, StatementTypeDML, StatementTypeTCL, StatementTypeDCL:<span class="cov2" title="4">
                return "UPDATE_COUNT"</span>
        case StatementTypeDQL, StatementTypeUtility:<span class="cov2" title="4">
                return "RESULT_SET"</span>
        default:<span class="cov1" title="1">
                return "RESULT_SET"</span>
        }
}

// GetStatementType returns the statement type (alias for ClassifyStatement).
func (esc *EnterpriseStatementClassifier) GetStatementType(sql string) StatementType <span class="cov0" title="0">{
        return esc.ClassifyStatement(sql)
}</span>

// NewStatementClassifier creates a new statement classifier (legacy compatibility).
func NewStatementClassifier() *EnterpriseStatementClassifier <span class="cov2" title="4">{
        return NewEnterpriseStatementClassifier()
}</span>

// StatementClassifier type alias for backward compatibility.
type StatementClassifier = EnterpriseStatementClassifier
 </pre>
		
		<pre class="file" id="file46" style="display: none">// Package services contains business logic implementations.
package services

import (
        "context"
        "fmt"
        "sync"
        "sync/atomic"
        "time"

        "github.com/google/uuid"

        "github.com/TFMV/porter/pkg/errors"
        "github.com/TFMV/porter/pkg/models"
        "github.com/TFMV/porter/pkg/repositories"
)

// transactionService implements TransactionService interface.
type transactionService struct {
        repo               repositories.TransactionRepository
        activeTransactions *sync.Map
        cleanupInterval    time.Duration
        logger             Logger
        metrics            MetricsCollector

        // Context-based lifecycle management
        ctx    context.Context
        cancel context.CancelFunc
        wg     sync.WaitGroup
}

// NewTransactionService creates a new transaction service.
func NewTransactionService(
        repo repositories.TransactionRepository,
        cleanupInterval time.Duration,
        logger Logger,
        metrics MetricsCollector,
) TransactionService <span class="cov9" title="5">{
        ctx, cancel := context.WithCancel(context.Background())

        ts := &amp;transactionService{
                repo:               repo,
                activeTransactions: &amp;sync.Map{},
                cleanupInterval:    cleanupInterval,
                logger:             logger,
                metrics:            metrics,
                ctx:                ctx,
                cancel:             cancel,
        }

        // Start cleanup routine if interval is set
        if cleanupInterval &gt; 0 </span><span class="cov9" title="5">{
                ts.wg.Add(1)
                go ts.cleanupRoutine(ctx)
        }</span>

        <span class="cov9" title="5">return ts</span>
}

// Begin starts a new transaction.
func (s *transactionService) Begin(ctx context.Context, opts models.TransactionOptions) (string, error) <span class="cov4" title="2">{
        timer := s.metrics.StartTimer("transaction_begin")
        defer timer.Stop()

        s.logger.Debug("Beginning transaction",
                "isolation_level", opts.IsolationLevel,
                "read_only", opts.ReadOnly,
                "timeout", opts.Timeout)

        // Validate options
        if err := s.validateTransactionOptions(opts); err != nil </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("transaction_validation_errors")
                return "", err
        }</span>

        // Begin transaction in repository
        <span class="cov1" title="1">txn, err := s.repo.Begin(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("transaction_begin_errors")
                s.logger.Error("Failed to begin transaction", "error", err)
                return "", errors.Wrap(err, errors.CodeTransactionFailed, "failed to begin transaction")
        }</span>

        // Generate transaction ID if not provided by repository
        <span class="cov1" title="1">txnID := txn.ID()
        if txnID == "" </span><span class="cov0" title="0">{
                txnID = uuid.New().String()
        }</span>

        // Store in active transactions map
        <span class="cov1" title="1">s.activeTransactions.Store(txnID, &amp;transactionInfo{
                transaction: txn,
                startTime:   time.Now(),
                options:     opts,
        })

        // Update metrics
        s.metrics.IncrementCounter("transactions_created")
        s.updateActiveTransactionGauge()

        s.logger.Info("Transaction started", "transaction_id", txnID)

        return txnID, nil</span>
}

// Get retrieves an existing transaction by ID.
func (s *transactionService) Get(ctx context.Context, id string) (repositories.Transaction, error) <span class="cov10" title="6">{
        timer := s.metrics.StartTimer("transaction_get")
        defer timer.Stop()

        s.logger.Debug("Getting transaction", "transaction_id", id)

        // Check active transactions first
        if info, ok := s.activeTransactions.Load(id); ok </span><span class="cov0" title="0">{
                txnInfo := info.(*transactionInfo)

                // Check if transaction is still valid
                if !txnInfo.transaction.IsActive() </span><span class="cov0" title="0">{
                        s.metrics.IncrementCounter("transaction_inactive_access")
                        s.activeTransactions.Delete(id)
                        s.updateActiveTransactionGauge()
                        return nil, errors.ErrTransactionNotFound.WithDetail("transaction_id", id)
                }</span>

                // Check timeout
                <span class="cov0" title="0">if txnInfo.options.Timeout &gt; 0 </span><span class="cov0" title="0">{
                        if time.Since(txnInfo.startTime) &gt; txnInfo.options.Timeout </span><span class="cov0" title="0">{
                                s.metrics.IncrementCounter("transaction_timeouts")
                                s.logger.Warn("Transaction timed out", "transaction_id", id)
                                // Rollback timed out transaction
                                _ = s.Rollback(ctx, id)
                                return nil, errors.New(errors.CodeDeadlineExceeded, "transaction timed out")
                        }</span>
                }

                <span class="cov0" title="0">return txnInfo.transaction, nil</span>
        }

        // Try to get from repository
        <span class="cov10" title="6">txn, err := s.repo.Get(ctx, id)
        if err != nil </span><span class="cov6" title="3">{
                if errors.IsNotFound(err) </span><span class="cov1" title="1">{
                        s.metrics.IncrementCounter("transaction_not_found")
                        return nil, errors.ErrTransactionNotFound.WithDetail("transaction_id", id)
                }</span>
                <span class="cov4" title="2">s.metrics.IncrementCounter("transaction_get_errors")
                s.logger.Error("Failed to get transaction", "error", err, "transaction_id", id)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to get transaction")</span>
        }

        // Add to active transactions if found
        <span class="cov6" title="3">if txn != nil &amp;&amp; txn.IsActive() </span><span class="cov6" title="3">{
                s.activeTransactions.Store(id, &amp;transactionInfo{
                        transaction: txn,
                        startTime:   time.Now(),
                        options:     models.TransactionOptions{},
                })
                s.updateActiveTransactionGauge()
        }</span>

        <span class="cov6" title="3">return txn, nil</span>
}

// Commit commits a transaction.
func (s *transactionService) Commit(ctx context.Context, id string) error <span class="cov4" title="2">{
        timer := s.metrics.StartTimer("transaction_commit")
        defer timer.Stop()

        s.logger.Debug("Committing transaction", "transaction_id", id)

        // Get transaction
        txn, err := s.Get(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Commit transaction
        <span class="cov1" title="1">if err := txn.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("transaction_commit_errors")
                s.logger.Error("Failed to commit transaction", "error", err, "transaction_id", id)
                return errors.Wrap(err, errors.CodeTransactionFailed, "failed to commit transaction")
        }</span>

        // Remove from active transactions
        <span class="cov1" title="1">if info, ok := s.activeTransactions.LoadAndDelete(id); ok </span><span class="cov1" title="1">{
                txnInfo := info.(*transactionInfo)
                duration := time.Since(txnInfo.startTime)
                s.metrics.RecordHistogram("transaction_duration", duration.Seconds())
        }</span>

        // Remove from repository
        <span class="cov1" title="1">_ = s.repo.Remove(ctx, id)

        // Update metrics
        s.metrics.IncrementCounter("transactions_committed")
        s.updateActiveTransactionGauge()

        s.logger.Info("Transaction committed", "transaction_id", id)

        return nil</span>
}

// Rollback rolls back a transaction.
func (s *transactionService) Rollback(ctx context.Context, id string) error <span class="cov4" title="2">{
        timer := s.metrics.StartTimer("transaction_rollback")
        defer timer.Stop()

        s.logger.Debug("Rolling back transaction", "transaction_id", id)

        // Get transaction
        txn, err := s.Get(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Rollback transaction
        <span class="cov1" title="1">if err := txn.Rollback(ctx); err != nil </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("transaction_rollback_errors")
                s.logger.Error("Failed to rollback transaction", "error", err, "transaction_id", id)
                return errors.Wrap(err, errors.CodeTransactionFailed, "failed to rollback transaction")
        }</span>

        // Remove from active transactions
        <span class="cov1" title="1">if info, ok := s.activeTransactions.LoadAndDelete(id); ok </span><span class="cov1" title="1">{
                txnInfo := info.(*transactionInfo)
                duration := time.Since(txnInfo.startTime)
                s.metrics.RecordHistogram("transaction_duration", duration.Seconds())
        }</span>

        // Remove from repository
        <span class="cov1" title="1">_ = s.repo.Remove(ctx, id)

        // Update metrics
        s.metrics.IncrementCounter("transactions_rolled_back")
        s.updateActiveTransactionGauge()

        s.logger.Info("Transaction rolled back", "transaction_id", id)

        return nil</span>
}

// List returns all active transactions.
func (s *transactionService) List(ctx context.Context) ([]repositories.Transaction, error) <span class="cov4" title="2">{
        timer := s.metrics.StartTimer("transaction_list")
        defer timer.Stop()

        s.logger.Debug("Listing active transactions")

        // Get from repository
        txns, err := s.repo.List(ctx)
        if err != nil </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("transaction_list_errors")
                s.logger.Error("Failed to list transactions", "error", err)
                return nil, errors.Wrap(err, errors.CodeInternal, "failed to list transactions")
        }</span>

        // Filter out inactive transactions
        <span class="cov1" title="1">active := make([]repositories.Transaction, 0, len(txns))
        for _, txn := range txns </span><span class="cov1" title="1">{
                if txn.IsActive() </span><span class="cov1" title="1">{
                        active = append(active, txn)
                }</span>
        }

        <span class="cov1" title="1">s.logger.Info("Listed active transactions", "count", len(active))

        return active, nil</span>
}

// CleanupInactive removes inactive transactions.
func (s *transactionService) CleanupInactive(ctx context.Context) error <span class="cov0" title="0">{
        timer := s.metrics.StartTimer("transaction_cleanup")
        defer timer.Stop()

        s.logger.Debug("Cleaning up inactive transactions")

        cleanupCount := atomic.Int32{}
        now := time.Now()

        // Clean up from active transactions map
        s.activeTransactions.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                // Check if context is cancelled
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">txnID := key.(string)
                txnInfo := value.(*transactionInfo)

                // Check if transaction is inactive
                if !txnInfo.transaction.IsActive() </span><span class="cov0" title="0">{
                        s.activeTransactions.Delete(txnID)
                        cleanupCount.Add(1)
                        return true
                }</span>

                // Check if transaction has timed out
                <span class="cov0" title="0">if txnInfo.options.Timeout &gt; 0 </span><span class="cov0" title="0">{
                        if now.Sub(txnInfo.startTime) &gt; txnInfo.options.Timeout </span><span class="cov0" title="0">{
                                s.logger.Warn("Cleaning up timed out transaction", "transaction_id", txnID)

                                // Create a timeout context for rollback
                                rollbackCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
                                if err := txnInfo.transaction.Rollback(rollbackCtx); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("Failed to rollback timed out transaction",
                                                "error", err,
                                                "transaction_id", txnID)
                                }</span>
                                <span class="cov0" title="0">cancel()

                                s.activeTransactions.Delete(txnID)
                                _ = s.repo.Remove(ctx, txnID)
                                cleanupCount.Add(1)</span>
                        }
                }

                <span class="cov0" title="0">return true</span>
        })

        // Update metrics
        <span class="cov0" title="0">count := cleanupCount.Load()
        if count &gt; 0 </span><span class="cov0" title="0">{
                s.metrics.IncrementCounter("transactions_cleaned_up", "count", fmt.Sprintf("%d", count))
                s.updateActiveTransactionGauge()
        }</span>

        <span class="cov0" title="0">s.logger.Info("Cleaned up inactive transactions", "count", count)

        return nil</span>
}

// cleanupRoutine runs periodic cleanup of inactive transactions until ctx is cancelled.
func (s *transactionService) cleanupRoutine(ctx context.Context) <span class="cov9" title="5">{
        defer s.wg.Done()

        ticker := time.NewTicker(s.cleanupInterval)
        defer ticker.Stop()

        s.logger.Info("Transaction cleanup routine started", "interval", s.cleanupInterval)

        for </span><span class="cov9" title="5">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        s.logger.Info("Transaction cleanup routine stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Create a per-cleanup timeout
                        cleanupCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
                        if err := s.CleanupInactive(cleanupCtx); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Cleanup routine failed", "error", err)
                        }</span>
                        <span class="cov0" title="0">cancel()</span> // Immediate cleanup
                }
        }
}

// Stop stops the transaction service gracefully.
func (s *transactionService) Stop() <span class="cov0" title="0">{
        s.logger.Info("Stopping transaction service")

        // Cancel context to signal shutdown
        s.cancel()

        // Wait for cleanup routine to finish
        s.wg.Wait()

        s.logger.Info("Transaction service stopped")
}</span>

// validateTransactionOptions validates transaction options.
func (s *transactionService) validateTransactionOptions(opts models.TransactionOptions) error <span class="cov4" title="2">{
        // Validate isolation level
        validIsolationLevels := map[string]bool{
                "":                   true, // Empty means default
                "READ UNCOMMITTED":   true,
                "READ COMMITTED":     true,
                "REPEATABLE READ":    true,
                "SERIALIZABLE":       true,
                "SNAPSHOT":           true,
                "SNAPSHOT ISOLATION": true,
        }

        if !validIsolationLevels[string(opts.IsolationLevel)] </span><span class="cov1" title="1">{
                return errors.New(errors.CodeInvalidRequest, "invalid isolation level: "+string(opts.IsolationLevel))
        }</span>

        // Validate timeout
        <span class="cov1" title="1">if opts.Timeout &lt; 0 </span><span class="cov0" title="0">{
                return errors.New(errors.CodeInvalidRequest, "timeout cannot be negative")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// updateActiveTransactionGauge updates the active transaction count metric.
func (s *transactionService) updateActiveTransactionGauge() <span class="cov10" title="6">{
        count := 0
        s.activeTransactions.Range(func(_, _ interface{}) bool </span><span class="cov7" title="4">{
                count++
                return true
        }</span>)
        <span class="cov10" title="6">s.metrics.RecordGauge("active_transactions", float64(count))</span>
}

// transactionInfo holds information about an active transaction.
type transactionInfo struct {
        transaction repositories.Transaction
        startTime   time.Time
        options     models.TransactionOptions
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package streaming

import (
        "context"
        "database/sql/driver"
        "fmt"
        "strings"

        "github.com/TFMV/porter/pkg/infrastructure/pool"
        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/array"
        "github.com/apache/arrow-go/v18/arrow/flight"
        "github.com/apache/arrow-go/v18/arrow/ipc"
        "github.com/apache/arrow-go/v18/arrow/memory"
        "github.com/marcboeker/go-duckdb/v2"
        "github.com/rs/zerolog"
)

// duckDBStreamingRepository implements the StreamingRepository interface for DuckDB.
type duckDBStreamingRepository struct {
        pool      pool.ConnectionPool
        allocator memory.Allocator
        logger    zerolog.Logger
}

// NewDuckDBStreamingRepository creates a new DuckDBStreamingRepository.
func NewDuckDBStreamingRepository(p pool.ConnectionPool, alloc memory.Allocator, logger zerolog.Logger) StreamingRepository <span class="cov0" title="0">{
        return &amp;duckDBStreamingRepository{
                pool:      p,
                allocator: alloc,
                logger:    logger,
        }
}</span>

// FlightDataReader is an interface that flight.NewRecordReader expects.
// flight.FlightService_DoPutServer implements this.
type FlightDataReader interface {
        Schema() *arrow.Schema
        Recv() (*flight.FlightData, error)
}

// IngestStream ingests Arrow RecordBatches into DuckDB using the Appender API.
func (r *duckDBStreamingRepository) IngestStream(ctx context.Context, transactionID string, targetTable string, schema *arrow.Schema, reader flight.MessageReader) (int64, error) <span class="cov0" title="0">{
        r.logger.Debug().Str("target_table", targetTable).Str("transaction_id", transactionID).Msg("IngestStream called")

        sqlDB, err := r.pool.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to acquire DB from pool: %w", err)
        }</span>

        <span class="cov0" title="0">sqlConn, err := sqlDB.Conn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get *sql.Conn from *sql.DB: %w", err)
        }</span>
        <span class="cov0" title="0">defer sqlConn.Close()

        safeTableIdentifier := r.quoteIdentifier(targetTable)

        createTableStmt := r.generateCreateTableStmt(safeTableIdentifier, schema)
        if _, err = sqlConn.ExecContext(ctx, createTableStmt); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create table %s: %w", safeTableIdentifier, err)
        }</span>

        <span class="cov0" title="0">var totalRows int64
        var appender *duckdb.Appender

        rawConnErr := sqlConn.Raw(func(driverConnRaw interface{}) error </span><span class="cov0" title="0">{
                driverConn, ok := driverConnRaw.(driver.Conn)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("expected driverConn to be driver.Conn, got %T", driverConnRaw)
                }</span>
                <span class="cov0" title="0">appender, err = duckdb.NewAppenderFromConn(driverConn, "", safeTableIdentifier)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create DuckDB appender for table %s: %w", safeTableIdentifier, err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if rawConnErr != nil </span><span class="cov0" title="0">{
                return 0, rawConnErr
        }</span>
        <span class="cov0" title="0">if appender == nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("appender is nil after Raw connection setup")
        }</span>

        <span class="cov0" title="0">appenderCloseErr := fmt.Errorf("appender not closed yet")
        defer func() </span><span class="cov0" title="0">{
                if appender != nil </span><span class="cov0" title="0">{
                        appenderCloseErr = appender.Close()
                        if appenderCloseErr != nil </span><span class="cov0" title="0">{
                                r.logger.Error().Err(appenderCloseErr).Str("table", safeTableIdentifier).Msg("Failed to close DuckDB appender")
                        }</span>
                }
        }()

        <span class="cov0" title="0">flightDataReaderAdapter, ok := reader.(FlightDataReader)
        if !ok </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("IngestStream reader is not a FlightDataReader; got %T", reader)
        }</span>

        <span class="cov0" title="0">recordReader, err := flight.NewRecordReader(flightDataReaderAdapter, ipc.WithAllocator(r.allocator), ipc.WithSchema(schema))
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create flight record reader: %w", err)
        }</span>
        <span class="cov0" title="0">defer recordReader.Release()

        for recordReader.Next() </span><span class="cov0" title="0">{
                rec := recordReader.Record()
                numRows := int(rec.NumRows())
                numCols := int(rec.NumCols())

                for i := 0; i &lt; numRows; i++ </span><span class="cov0" title="0">{
                        rowArgs := make([]driver.Value, numCols)
                        for j := 0; j &lt; numCols; j++ </span><span class="cov0" title="0">{
                                col := rec.Column(j)
                                if col.IsNull(i) </span><span class="cov0" title="0">{
                                        rowArgs[j] = nil
                                        continue</span>
                                }
                                <span class="cov0" title="0">switch typedCol := col.(type) </span>{
                                case *array.Boolean:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span>
                                case *array.Int8:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span>
                                case *array.Int16:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span>
                                case *array.Int32:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span>
                                case *array.Int64:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span>
                                case *array.Uint8:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span>
                                case *array.Uint16:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span>
                                case *array.Uint32:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span>
                                case *array.Uint64:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span>
                                case *array.Float32:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span>
                                case *array.Float64:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span>
                                case *array.String:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span>
                                case *array.LargeString:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span>
                                case *array.Binary:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span>
                                case *array.LargeBinary:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span>
                                case *array.FixedSizeBinary:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i)</span> // Potentially convert to []byte if driver expects that
                                case *array.Date32:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i).ToTime()</span>
                                case *array.Date64:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i).ToTime()</span>
                                case *array.Timestamp:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i).ToTime(typedCol.DataType().(*arrow.TimestampType).Unit)</span>
                                case *array.Time32:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i).ToTime(typedCol.DataType().(*arrow.Time32Type).Unit)</span>
                                case *array.Time64:<span class="cov0" title="0">
                                        rowArgs[j] = typedCol.Value(i).ToTime(typedCol.DataType().(*arrow.Time64Type).Unit)</span>
                                case *array.Decimal128:<span class="cov0" title="0">
                                        // driver.Value might not directly support Decimal128.
                                        // DuckDB itself handles decimals, but the Go driver might expect string or float.
                                        // This might require specific handling or string conversion.
                                        // For now, using ValueStr for simplicity, but this needs verification.
                                        // Consider converting to string: typedCol.Value(i).String()
                                        // Or if your driver/DB supports it, find the appropriate Go type.
                                        rowArgs[j] = typedCol.ValueStr(i)</span> // Placeholder - review for actual DB driver compatibility
                                case *array.Decimal256:<span class="cov0" title="0">
                                        // Similar to Decimal128
                                        rowArgs[j] = typedCol.ValueStr(i)</span> // Placeholder - review
                                // TODO: Add cases for List, Struct, Map, Duration, Interval if they are expected
                                // These will require more complex handling (e.g., converting to JSON string or nested slices/maps if supported)
                                default:<span class="cov0" title="0">
                                        // Fallback to ValueStr, but this might not be ideal for all types.
                                        // Or return an error for unsupported types.
                                        r.logger.Warn().Str("arrow_type", col.DataType().String()).Msg("Unsupported Arrow type for appender, attempting ValueStr")
                                        rowArgs[j] = col.ValueStr(i)</span> // This is a fallback, may not be correct for all unhandled types
                                        // Alternatively, return an error:
                                        // rec.Release()
                                        // return totalRows, fmt.Errorf("unsupported arrow column type for appender: %s", col.DataType().Name())
                                }
                        }
                        <span class="cov0" title="0">if err = appender.AppendRow(rowArgs...); err != nil </span><span class="cov0" title="0">{
                                rec.Release() // Release before returning error
                                return totalRows, fmt.Errorf("appender failed to append row %d of batch: %w. Appender close status: %v", i, err, appenderCloseErr)
                        }</span>
                        <span class="cov0" title="0">totalRows++</span> // Correctly increment after each successful row append
                }
                // totalRows += rec.NumRows() // This was the original logic, assuming AppendArrowRecord.
                // If AppendRow is used, totalRows should be incremented inside the inner loop after a successful AppendRow,
                // or simply use rec.NumRows() after the inner loop if all rows in the batch are processed.
                // For now, keeping it similar to original structure, but this counts the whole batch even if a row fails.
                // Correct would be: totalRows += int64(numRows) if the inner loop completes. Or increment inside.

                <span class="cov0" title="0">rec.Release()</span> // Release the current record after processing all its rows
        }

        <span class="cov0" title="0">if recordReader.Err() != nil </span><span class="cov0" title="0">{
                return totalRows, fmt.Errorf("error reading records from flight stream: %w. Appender close status: %v", recordReader.Err(), appenderCloseErr)
        }</span>

        <span class="cov0" title="0">if errFlush := appender.Flush(); errFlush != nil </span><span class="cov0" title="0">{
                return totalRows, fmt.Errorf("failed to flush DuckDB appender for table %s: %w. Appender close status: %v", safeTableIdentifier, errFlush, appenderCloseErr)
        }</span>

        <span class="cov0" title="0">if appenderCloseErr != nil &amp;&amp; appenderCloseErr.Error() != "appender not closed yet" </span><span class="cov0" title="0">{
                return totalRows, appenderCloseErr
        }</span>

        <span class="cov0" title="0">r.logger.Info().Str("target_table", safeTableIdentifier).Int64("rows_affected", totalRows).Msg("Successfully ingested stream using Appender")
        return totalRows, nil</span>
}

func (r *duckDBStreamingRepository) quoteIdentifier(name string) string <span class="cov8" title="3">{
        return fmt.Sprintf("\"%s\"", strings.ReplaceAll(name, "\"", "\"\""))
}</span>

func (r *duckDBStreamingRepository) generateCreateTableStmt(tableName string, schema *arrow.Schema) string <span class="cov1" title="1">{
        var sb strings.Builder
        sb.WriteString(fmt.Sprintf("CREATE TABLE IF NOT EXISTS %s (", tableName))
        for i, field := range schema.Fields() </span><span class="cov5" title="2">{
                if i &gt; 0 </span><span class="cov1" title="1">{
                        sb.WriteString(", ")
                }</span>
                <span class="cov5" title="2">sb.WriteString(r.quoteIdentifier(field.Name))
                sb.WriteString(" ")
                sb.WriteString(r.arrowToDuckDBType(field.Type))
                if !field.Nullable </span><span class="cov1" title="1">{
                        sb.WriteString(" NOT NULL")
                }</span>
        }
        <span class="cov1" title="1">sb.WriteString(")")
        return sb.String()</span>
}

func (r *duckDBStreamingRepository) arrowToDuckDBType(dt arrow.DataType) string <span class="cov10" title="4">{
        switch dt := dt.(type) </span>{
        case *arrow.NullType:<span class="cov0" title="0">
                return "NULL"</span>
        case *arrow.BooleanType:<span class="cov0" title="0">
                return "BOOLEAN"</span>
        case *arrow.Int8Type:<span class="cov0" title="0">
                return "TINYINT"</span>
        case *arrow.Int16Type:<span class="cov0" title="0">
                return "SMALLINT"</span>
        case *arrow.Int32Type:<span class="cov0" title="0">
                return "INTEGER"</span>
        case *arrow.Int64Type:<span class="cov1" title="1">
                return "BIGINT"</span>
        case *arrow.Uint8Type:<span class="cov0" title="0">
                return "UTINYINT"</span>
        case *arrow.Uint16Type:<span class="cov0" title="0">
                return "USMALLINT"</span>
        case *arrow.Uint32Type:<span class="cov0" title="0">
                return "UINTEGER"</span>
        case *arrow.Uint64Type:<span class="cov0" title="0">
                return "UBIGINT"</span>
        case *arrow.Float16Type:<span class="cov0" title="0">
                return "FLOAT"</span>
        case *arrow.Float32Type:<span class="cov0" title="0">
                return "FLOAT"</span>
        case *arrow.Float64Type:<span class="cov0" title="0">
                return "DOUBLE"</span>
        case *arrow.StringType:<span class="cov1" title="1">
                return "VARCHAR"</span>
        case *arrow.LargeStringType:<span class="cov0" title="0">
                return "VARCHAR"</span>
        case *arrow.BinaryType:<span class="cov0" title="0">
                return "BLOB"</span>
        case *arrow.LargeBinaryType:<span class="cov0" title="0">
                return "BLOB"</span>
        case *arrow.FixedSizeBinaryType:<span class="cov0" title="0">
                return "BLOB"</span>
        case *arrow.Date32Type, *arrow.Date64Type:<span class="cov0" title="0">
                return "DATE"</span>
        case *arrow.TimestampType:<span class="cov0" title="0">
                switch dt.Unit </span>{
                case arrow.Nanosecond:<span class="cov0" title="0">
                        return "TIMESTAMP_NS"</span>
                case arrow.Microsecond:<span class="cov0" title="0">
                        return "TIMESTAMP"</span>
                case arrow.Millisecond:<span class="cov0" title="0">
                        return "TIMESTAMP_MS"</span>
                case arrow.Second:<span class="cov0" title="0">
                        return "TIMESTAMP_S"</span>
                }
                <span class="cov0" title="0">if dt.TimeZone != "" </span><span class="cov0" title="0">{
                        return "TIMESTAMPTZ"
                }</span>
                <span class="cov0" title="0">return "TIMESTAMP"</span>
        case *arrow.Time32Type, *arrow.Time64Type:<span class="cov0" title="0">
                return "TIME"</span>
        case *arrow.Decimal128Type:<span class="cov0" title="0">
                return fmt.Sprintf("DECIMAL(%d, %d)", dt.Precision, dt.Scale)</span>
        case *arrow.Decimal256Type:<span class="cov1" title="1">
                precision := dt.Precision
                if precision &gt; 38 </span><span class="cov1" title="1">{
                        r.logger.Warn().Int32("arrow_precision", precision).Msg("Arrow Decimal256 precision &gt; 38, clamping to 38 for DuckDB")
                        precision = 38
                }</span>
                <span class="cov1" title="1">return fmt.Sprintf("DECIMAL(%d, %d)", precision, dt.Scale)</span>
        case *arrow.ListType:<span class="cov0" title="0">
                return r.arrowToDuckDBType(dt.Elem()) + "[]"</span>
        case *arrow.LargeListType:<span class="cov0" title="0">
                return r.arrowToDuckDBType(dt.Elem()) + "[]"</span>
        case *arrow.FixedSizeListType:<span class="cov0" title="0">
                return r.arrowToDuckDBType(dt.Elem()) + "[]"</span>
        case *arrow.MapType:<span class="cov0" title="0">
                keyType := r.arrowToDuckDBType(dt.KeyType())
                valueType := r.arrowToDuckDBType(dt.ItemType())
                return fmt.Sprintf("MAP(%s, %s)", keyType, valueType)</span>
        case *arrow.StructType:<span class="cov0" title="0">
                var fields []string
                for _, field := range dt.Fields() </span><span class="cov0" title="0">{
                        fields = append(fields, fmt.Sprintf("%s %s", r.quoteIdentifier(field.Name), r.arrowToDuckDBType(field.Type)))
                }</span>
                <span class="cov0" title="0">return "STRUCT(" + strings.Join(fields, ", ") + ")"</span>
        case *arrow.DurationType:<span class="cov0" title="0">
                return "INTERVAL"</span>
        case *arrow.MonthIntervalType, *arrow.DayTimeIntervalType, *arrow.MonthDayNanoIntervalType:<span class="cov0" title="0">
                return "INTERVAL"</span>
        default:<span class="cov1" title="1">
                r.logger.Warn().Str("arrow_type", dt.String()).Msg("Unsupported Arrow type for DDL generation, defaulting to BLOB")
                return "BLOB"</span>
        }
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package streaming

import (
        "context"
        "encoding/binary"
        "time"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/flight"
        "github.com/rs/zerolog"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// MetricsCollector defines a subset of metrics collection capabilities needed by the service.
// This should align with the one in cmd/server/server/server.go or a shared package.
type MetricsCollector interface {
        IncrementCounter(name string, labels ...string)
        StartTimer(name string) Timer
        RecordHistogram(name string, value float64, labels ...string)
}

// Timer defines a simple timer interface for metrics, compatible with server.Timer.
type Timer interface {
        Stop() float64
}

// service implements the StreamingService interface.
type service struct {
        repository StreamingRepository
        logger     zerolog.Logger
        metrics    MetricsCollector
}

func getClientID(ctx context.Context) string <span class="cov10" title="6">{
        if md, ok := metadata.FromIncomingContext(ctx); ok </span><span class="cov1" title="1">{
                if ids := md.Get("client_id"); len(ids) &gt; 0 </span><span class="cov1" title="1">{
                        return ids[0]
                }</span>
        }
        <span class="cov9" title="5">return ""</span>
}

// NewService creates a new StreamingService.
func NewService(repository StreamingRepository, logger zerolog.Logger, metrics MetricsCollector) StreamingService <span class="cov0" title="0">{
        return &amp;service{
                repository: repository,
                logger:     logger,
                metrics:    metrics,
        }
}</span>

// HandleDoPut streams data into a specified target.
func (s *service) HandleDoPut(ctx context.Context, desc *flight.FlightDescriptor, schema *arrow.Schema, reader flight.MessageReader, writer flight.MetadataWriter) error <span class="cov9" title="5">{
        if desc == nil || schema == nil || reader == nil || writer == nil </span><span class="cov1" title="1">{
                return status.Error(codes.InvalidArgument, "invalid stream inputs")
        }</span>

        <span class="cov7" title="4">s.logger.Debug().Fields(map[string]interface{}{"descriptor_path": desc.Path}).Msg("HandleDoPut called")

        clientID := getClientID(ctx)
        start := time.Now()
        timer := s.metrics.StartTimer("streaming_service_handle_do_put_duration_seconds")
        defer timer.Stop()
        defer func(start time.Time) </span><span class="cov7" title="4">{
                duration := time.Since(start).Seconds()
                s.metrics.RecordHistogram("flight_sql_rpc_duration_seconds", duration, "rpc", "DoPut")
        }</span>(start)

        <span class="cov7" title="4">if len(desc.Path) == 0 </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("streaming_service_handle_do_put_errors_total", "reason", "missing_target_path")
                s.metrics.IncrementCounter("flight_sql_rpc_total", "rpc", "DoPut", "status", "error")
                s.logger.Error().Str("rpc_name", "DoPut").Str("client_id", clientID).Float64("duration_ms", time.Since(start).Seconds()*1000).Str("error_type", "missing_target_path").Msg("failed to ingest stream")
                return status.Error(codes.InvalidArgument, "missing target path in FlightDescriptor")
        }</span>
        <span class="cov6" title="3">if schema == nil || len(schema.Fields()) == 0 </span><span class="cov0" title="0">{
                return status.Error(codes.InvalidArgument, "missing schema")
        }</span>
        <span class="cov6" title="3">targetTable := desc.Path[0]

        transactionID := ""

        rowsAffected, err := s.repository.IngestStream(ctx, transactionID, targetTable, schema, reader)
        if err != nil </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("streaming_service_handle_do_put_errors_total", "reason", "ingestion_failed")
                s.metrics.IncrementCounter("flight_sql_rpc_total", "rpc", "DoPut", "status", "error")
                s.logger.Error().Err(err).Str("target_table", targetTable).Str("rpc_name", "DoPut").Str("client_id", clientID).Float64("duration_ms", time.Since(start).Seconds()*1000).Str("error_type", "ingestion_failed").Msg("failed to ingest stream")
                return status.Errorf(codes.Internal, "failed to ingest stream: %v", err)
        }</span>

        <span class="cov4" title="2">s.metrics.IncrementCounter("streaming_service_handle_do_put_success_total")
        s.metrics.IncrementCounter("flight_sql_rpc_total", "rpc", "DoPut", "status", "success")
        s.logger.Info().Str("target_table", targetTable).Int64("rows_affected", rowsAffected).Str("rpc_name", "DoPut").Str("client_id", clientID).Float64("duration_ms", time.Since(start).Seconds()*1000).Int64("record_count", rowsAffected).Msg("successfully ingested stream")

        // Encode rowsAffected as the PutResult metadata
        result := make([]byte, 8)
        binary.LittleEndian.PutUint64(result, uint64(rowsAffected))
        if err := writer.WriteMetadata(result); err != nil </span><span class="cov1" title="1">{
                s.metrics.IncrementCounter("streaming_service_handle_do_put_errors_total", "reason", "write_put_result")
                s.metrics.IncrementCounter("flight_sql_rpc_total", "rpc", "DoPut", "status", "error")
                s.logger.Error().Err(err).Str("rpc_name", "DoPut").Str("client_id", clientID).Float64("duration_ms", time.Since(start).Seconds()*1000).Str("error_type", "write_put_result").Msg("failed to write PutResult")
                return status.Errorf(codes.Internal, "failed to write PutResult: %v", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package utils

import (
        server "github.com/TFMV/porter/pkg/server"
)

type Timer interface {
        Stop() float64
}

// MetricsCollector defines the interface for collecting metrics.
// This should match the server.MetricsCollector interface.
type MetricsCollector interface {
        IncrementCounter(name string, labels ...string)
        RecordHistogram(name string, value float64, labels ...string)
        RecordGauge(name string, value float64, labels ...string)
        StartTimer(name string) Timer
}

// noOpTimer implements the server.Timer interface with no operations.
type noOpTimer struct{}

// Stop does nothing and returns 0.
func (t *noOpTimer) Stop() float64 <span class="cov0" title="0">{
        return 0.0
}</span>

// NoOpMetricsCollector implements the server.MetricsCollector interface with no operations.
// It will be used in tests where metrics collection is not the focus.
// server.MetricsCollector expects:
//
//        IncrementCounter(name string, labels ...string)
//        RecordHistogram(name string, value float64, labels ...string)
//        RecordGauge(name string, value float64, labels ...string)
//        StartTimer(name string) server.Timer
type NoOpMetricsCollector struct{}

// NewNoOpMetricsCollector creates a new NoOpMetricsCollector.
func NewNoOpMetricsCollector() *NoOpMetricsCollector <span class="cov0" title="0">{
        return &amp;NoOpMetricsCollector{}
}</span>

// IncrementCounter does nothing.
func (c *NoOpMetricsCollector) IncrementCounter(name string, labels ...string) {<span class="cov0" title="0">}</span>

// RecordHistogram does nothing.
func (c *NoOpMetricsCollector) RecordHistogram(name string, value float64, labels ...string) {<span class="cov0" title="0">}</span>

// RecordGauge does nothing.
func (c *NoOpMetricsCollector) RecordGauge(name string, value float64, labels ...string) {<span class="cov0" title="0">}</span>

// StartTimer returns a no-op timer that satisfies server.Timer.
func (c *NoOpMetricsCollector) StartTimer(name string) server.Timer <span class="cov0" title="0">{ // Return type is now server.Timer
        return &amp;noOpTimer{}
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package main

import (
        "context"
        "log"

        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/array"
        "github.com/apache/arrow-go/v18/arrow/flight/flightsql"
        "github.com/apache/arrow-go/v18/arrow/memory"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

func main() <span class="cov0" title="0">{
        // Connect to Porter server
        client, err := flightsql.NewClient("localhost:32010", nil, nil, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        // Create a test table with some data
        log.Println("Creating test table...")
        _, err = client.Execute(ctx, "CREATE TABLE test_table (id INTEGER, name VARCHAR, value DOUBLE)")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create table: %v", err)
        }</span>

        // Insert test data
        <span class="cov0" title="0">log.Println("Inserting test data...")
        _, err = client.Execute(ctx, "INSERT INTO test_table VALUES (1, 'Alice', 100.5), (2, 'Bob', 200.7), (3, 'Charlie', 300.9)")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to insert data: %v", err)
        }</span>

        // Test basic query first
        <span class="cov0" title="0">log.Println("Testing basic query...")
        info, err := client.Execute(ctx, "SELECT COUNT(*) FROM test_table")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to execute basic query: %v", err)
        }</span>

        <span class="cov0" title="0">for _, endpoint := range info.Endpoint </span><span class="cov0" title="0">{
                reader, err := client.DoGet(ctx, endpoint.Ticket)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to get results: %v", err)
                }</span>

                <span class="cov0" title="0">for reader.Next() </span><span class="cov0" title="0">{
                        record := reader.Record()
                        log.Printf("Basic query result: %d rows, %d cols", record.NumRows(), record.NumCols())
                        record.Release()
                }</span>
                <span class="cov0" title="0">reader.Release()</span>
        }

        // Test prepared statement
        <span class="cov0" title="0">log.Println("Testing prepared statement...")
        stmt, err := client.Prepare(ctx, "SELECT * FROM test_table WHERE id = ?")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to prepare statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close(ctx)

        // Create parameter record
        allocator := memory.NewGoAllocator()
        schema := arrow.NewSchema([]arrow.Field{
                {Name: "id", Type: arrow.PrimitiveTypes.Int64},
        }, nil)

        builder := array.NewRecordBuilder(allocator, schema)
        builder.Field(0).(*array.Int64Builder).Append(int64(2))
        paramRecord := builder.NewRecord()
        builder.Release()

        // Set parameters
        log.Println("Setting parameters...")
        stmt.SetParameters(paramRecord)
        paramRecord.Release()

        // Execute prepared statement
        log.Println("Executing prepared statement...")
        info, err = stmt.Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to execute prepared statement: %v", err)
        }</span>

        // Read results
        <span class="cov0" title="0">for _, endpoint := range info.Endpoint </span><span class="cov0" title="0">{
                reader, err := client.DoGet(ctx, endpoint.Ticket)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to get prepared statement results: %v", err)
                }</span>

                <span class="cov0" title="0">for reader.Next() </span><span class="cov0" title="0">{
                        record := reader.Record()
                        log.Printf("Prepared statement result: %d rows, %d cols", record.NumRows(), record.NumCols())

                        // Print the actual data
                        if record.NumRows() &gt; 0 </span><span class="cov0" title="0">{
                                for i := int64(0); i &lt; record.NumRows(); i++ </span><span class="cov0" title="0">{
                                        idCol := record.Column(0).(*array.Int64)
                                        nameCol := record.Column(1).(*array.String)
                                        valueCol := record.Column(2).(*array.Float64)

                                        log.Printf("Row %d: id=%d, name=%s, value=%f",
                                                i, idCol.Value(int(i)), nameCol.Value(int(i)), valueCol.Value(int(i)))
                                }</span>
                        }
                        <span class="cov0" title="0">record.Release()</span>
                }
                <span class="cov0" title="0">reader.Release()</span>
        }

        <span class="cov0" title="0">log.Println("Prepared statement test completed successfully!")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
